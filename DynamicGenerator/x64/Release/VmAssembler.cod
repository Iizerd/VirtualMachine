; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	printf
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
PUBLIC	??0bad_cast@std@@QEAA@XZ			; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	??_G_CODE_LINK@@QEAAPEAXI@Z			; _CODE_LINK::`scalar deleting destructor'
PUBLIC	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z ; std::allocator<_VM_INSTRUCTION *>::deallocate
PUBLIC	?_Xlength@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@CAXXZ ; std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Xlength
PUBLIC	?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; VmTokenizeLine
PUBLIC	?VmGetInstructionId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ; VmGetInstructionId
PUBLIC	?VmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ; VmGetRegisterId
PUBLIC	?VmGetInstructionLength@@YAHE@Z			; VmGetInstructionLength
PUBLIC	?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z ; VmLoadDefaultInstructions
PUBLIC	?VmGetInverseStackChange@@YAHPEAU_CODE_LINK@@@Z	; VmGetInverseStackChange
PUBLIC	?VmGetInverseStackChangeForRange@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@H@Z ; VmGetInverseStackChangeForRange
PUBLIC	?VmAddOpaqueBranch@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@HH@Z ; VmAddOpaqueBranch
PUBLIC	?VmAddInstruction@@YAHPEAU_VM_ASSEMBLER@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; VmAddInstruction
PUBLIC	?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; VmLoadFile
PUBLIC	?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z	; VmAppendJumpsToUsed
PUBLIC	?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z ; VmShuffleUsedHandlerOder
PUBLIC	?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z		; VmFoldTable
PUBLIC	?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z ; VmGenerateRandomOpCodes
PUBLIC	?VmGetCodeSize@@YAKPEAU_VM_ASSEMBLER@@@Z	; VmGetCodeSize
PUBLIC	?VmGetVmSize@@YAKPEAU_VM_ASSEMBLER@@@Z		; VmGetVmSize
PUBLIC	?VmGetJumpDelta@@YAHPEAU_CODE_LINK@@@Z		; VmGetJumpDelta
PUBLIC	?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ; VmAssembleCodeToBuffer
PUBLIC	?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ; VmAssembleVmToBuffer
PUBLIC	?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z ; VmBuildHandlerTable
PUBLIC	?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ; VmBuildSymbolTable
PUBLIC	?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z	; VmGetVmEnterOpCode
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z ; std::shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> &>
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z ; std::allocator<_VM_SYMBOL>::deallocate
PUBLIC	??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::~vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >
PUBLIC	?_Xlength@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@CAXXZ ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Xlength
PUBLIC	??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Emplace_reallocate<>
PUBLIC	??$_Unfancy_maybe_null@U_VM_SYMBOL@@@std@@YAPEAU_VM_SYMBOL@@PEAU1@@Z ; std::_Unfancy_maybe_null<_VM_SYMBOL>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z ; std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Emplace_reallocate<_VM_INSTRUCTION *>
PUBLIC	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
PUBLIC	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$_Destroy_range@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAXPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z ; std::_Destroy_range<std::allocator<_VM_INSTRUCTION *> >
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_range@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAXPEAU_VM_SYMBOL@@QEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z ; std::_Destroy_range<std::allocator<_VM_SYMBOL> >
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::_Rng_from_urng<__int64,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> > >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PEAU_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAPEAU_VM_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z ; std::_Uninitialized_move<_VM_SYMBOL *,std::allocator<_VM_SYMBOL> >
PUBLIC	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_move@PEAPEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z ; std::_Uninitialized_move<_VM_INSTRUCTION * *,std::allocator<_VM_INSTRUCTION *> >
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Copy_memmove@PEAU_VM_SYMBOL@@PEAU1@@std@@YAPEAU_VM_SYMBOL@@PEAU1@00@Z ; std::_Copy_memmove<_VM_SYMBOL *,_VM_SYMBOL *>
PUBLIC	??$_Copy_memmove@PEAPEAU_VM_INSTRUCTION@@PEAPEAU1@@std@@YAPEAPEAU_VM_INSTRUCTION@@PEAPEAU1@00@Z ; std::_Copy_memmove<_VM_INSTRUCTION * *,_VM_INSTRUCTION * *>
PUBLIC	??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z		; std::_Refancy<char const *,0>
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@	; `string'
PUBLIC	??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	?InstructionBindings@@3PAPEBDA			; InstructionBindings
PUBLIC	??_C@_07COKNFLJB@VMENTER@			; `string'
PUBLIC	??_C@_06KOGGDLNF@VMEXIT@			; `string'
PUBLIC	??_C@_03GEANJIEE@NOP@				; `string'
PUBLIC	??_C@_04NKMOJAI@LDIB@				; `string'
PUBLIC	??_C@_04DKBJAPBM@LDIW@				; `string'
PUBLIC	??_C@_04FLPGEOIO@LDID@				; `string'
PUBLIC	??_C@_04GMEDKIJK@LDIQ@				; `string'
PUBLIC	??_C@_07BACCOCAE@LDIBSXW@			; `string'
PUBLIC	??_C@_07HBMNKDJG@LDIBSXD@			; `string'
PUBLIC	??_C@_07EGHIEFIC@LDIBSXQ@			; `string'
PUBLIC	??_C@_07NJMNLLGE@LDIWSXD@			; `string'
PUBLIC	??_C@_07OOHIFNHA@LDIWSXQ@			; `string'
PUBLIC	??_C@_07MJDILACC@LDIDSXQ@			; `string'
PUBLIC	??_C@_07GNCKKNIO@LDIBZXW@			; `string'
PUBLIC	??_C@_07MMFOMBM@LDIBZXD@			; `string'
PUBLIC	??_C@_07DLHAAKAI@LDIBZXQ@			; `string'
PUBLIC	??_C@_07KEMFPEOO@LDIWZXD@			; `string'
PUBLIC	??_C@_07JDHABCPK@LDIWZXQ@			; `string'
PUBLIC	??_C@_07LEDAPPKI@LDIDZXQ@			; `string'
PUBLIC	??_C@_04DLPLILA@LDAB@				; `string'
PUBLIC	??_C@_04DEAKFOKE@LDAW@				; `string'
PUBLIC	??_C@_04FFOFBPDG@LDAD@				; `string'
PUBLIC	??_C@_04GCFAPJCC@LDAQ@				; `string'
PUBLIC	??_C@_04LBBGOPHM@STAB@				; `string'
PUBLIC	??_C@_04IGKDAJGI@STAW@				; `string'
PUBLIC	??_C@_04OHEMEIPK@STAD@				; `string'
PUBLIC	??_C@_04NAPJKOOO@STAQ@				; `string'
PUBLIC	??_C@_04MODDAIIJ@SXBW@				; `string'
PUBLIC	??_C@_04KPNMEJBL@SXBD@				; `string'
PUBLIC	??_C@_04JIGJKPAP@SXBQ@				; `string'
PUBLIC	??_C@_04LFDBCIIA@SXWD@				; `string'
PUBLIC	??_C@_04ICIEMOJE@SXWQ@				; `string'
PUBLIC	??_C@_04JMOENDLN@SXDQ@				; `string'
PUBLIC	??_C@_04MDCDGKPI@ZXBW@				; `string'
PUBLIC	??_C@_04KCMMCLGK@ZXBD@				; `string'
PUBLIC	??_C@_04JFHJMNHO@ZXBQ@				; `string'
PUBLIC	??_C@_04LICBEKPB@ZXWD@				; `string'
PUBLIC	??_C@_04IPJEKMOF@ZXWQ@				; `string'
PUBLIC	??_C@_04JBPELBMM@ZXDQ@				; `string'
PUBLIC	??_C@_05NHDOEHKD@PUSHB@				; `string'
PUBLIC	??_C@_05OAILKBLH@PUSHW@				; `string'
PUBLIC	??_C@_05IBGEOACF@PUSHD@				; `string'
PUBLIC	??_C@_05LGNBAGDB@PUSHQ@				; `string'
PUBLIC	??_C@_04GMEKIMHF@POPB@				; `string'
PUBLIC	??_C@_04FLPPGKGB@POPW@				; `string'
PUBLIC	??_C@_04DKBACLPD@POPD@				; `string'
PUBLIC	??_C@_04NKFMNOH@POPQ@				; `string'
PUBLIC	??_C@_05COPILBNH@NPOPB@				; `string'
PUBLIC	??_C@_05BJENFHMD@NPOPW@				; `string'
PUBLIC	??_C@_05HIKCBGFB@NPOPD@				; `string'
PUBLIC	??_C@_05EPBHPAEF@NPOPQ@				; `string'
PUBLIC	??_C@_04PNOELOOK@ADDB@				; `string'
PUBLIC	??_C@_04MKFBFIPO@ADDW@				; `string'
PUBLIC	??_C@_04KLLOBJGM@ADDD@				; `string'
PUBLIC	??_C@_04JMALPPHI@ADDQ@				; `string'
PUBLIC	??_C@_04LOMDGEA@SUBB@				; `string'
PUBLIC	??_C@_04DMFJNAFE@SUBW@				; `string'
PUBLIC	??_C@_04FNLGJBMG@SUBD@				; `string'
PUBLIC	??_C@_04GKADHHNC@SUBQ@				; `string'
PUBLIC	??_C@_04NOKCDCKJ@MULB@				; `string'
PUBLIC	??_C@_04OJBHNELN@MULW@				; `string'
PUBLIC	??_C@_04IIPIJFCP@MULD@				; `string'
PUBLIC	??_C@_04LPENHDDL@MULQ@				; `string'
PUBLIC	??_C@_04NIMMJOFJ@DIVB@				; `string'
PUBLIC	??_C@_04OPHJHIEN@DIVW@				; `string'
PUBLIC	??_C@_04IOJGDJNP@DIVD@				; `string'
PUBLIC	??_C@_04LJCDNPML@DIVQ@				; `string'
PUBLIC	??_C@_04JCFJFOIO@ANDB@				; `string'
PUBLIC	??_C@_04KFOMLIJK@ANDW@				; `string'
PUBLIC	??_C@_04MEADPJAI@ANDD@				; `string'
PUBLIC	??_C@_04PDLGBPBM@ANDQ@				; `string'
PUBLIC	??_C@_03LALLLPNB@ORB@				; `string'
PUBLIC	??_C@_03IHAOFJMF@ORW@				; `string'
PUBLIC	??_C@_03OGOBBIFH@ORD@				; `string'
PUBLIC	??_C@_03NBFEPOED@ORQ@				; `string'
PUBLIC	??_C@_04FPLOBDNK@XORB@				; `string'
PUBLIC	??_C@_04GIALPFMO@XORW@				; `string'
PUBLIC	??_C@_04JOELEFM@XORD@				; `string'
PUBLIC	??_C@_04DOFBFCEI@XORQ@				; `string'
PUBLIC	??_C@_04KDABJEAI@SHLB@				; `string'
PUBLIC	??_C@_04JELEHCBM@SHLW@				; `string'
PUBLIC	??_C@_04PFFLDDIO@SHLD@				; `string'
PUBLIC	??_C@_04MCOONFJK@SHLQ@				; `string'
PUBLIC	??_C@_04LFLJBKHC@SHRB@				; `string'
PUBLIC	??_C@_04ICAMPMGG@SHRW@				; `string'
PUBLIC	??_C@_04ODODLNPE@SHRD@				; `string'
PUBLIC	??_C@_04NEFGFLOA@SHRQ@				; `string'
PUBLIC	??_C@_04OBADKJKM@CMPB@				; `string'
PUBLIC	??_C@_04NGLGEPLI@CMPW@				; `string'
PUBLIC	??_C@_04LHFJAOCK@CMPD@				; `string'
PUBLIC	??_C@_04IAOMOIDO@CMPQ@				; `string'
PUBLIC	??_C@_03OIOLNLHN@JMP@				; `string'
PUBLIC	??_C@_04POHBCBG@JMPI@				; `string'
PUBLIC	??_C@_02CBHPCOPC@JL@				; `string'
PUBLIC	??_C@_03NOJMFHFO@JLE@				; `string'
PUBLIC	??_C@_02MCILPHDJ@JG@				; `string'
PUBLIC	??_C@_03NCMJLILP@JGE@				; `string'
PUBLIC	??_C@_02DNOHJLCF@JZ@				; `string'
PUBLIC	??_C@_03BAECINKO@JNZ@				; `string'
PUBLIC	??_C@_04CAGKGBIO@CALL@				; `string'
PUBLIC	??_C@_03BHDJDALB@RET@				; `string'
PUBLIC	??_C@_07EMAGKOAM@X86CALL@			; `string'
PUBLIC	??_C@_06CFKEFNFF@EDITSP@			; `string'
PUBLIC	??_C@_04NGEAOILB@STSP@				; `string'
PUBLIC	??_C@_04GEOJLPHN@LDSP@				; `string'
PUBLIC	??_C@_04MHPBMOBH@STIP@				; `string'
PUBLIC	??_C@_04HFFIJJNL@LDIP@				; `string'
PUBLIC	??_C@_05MDEPALLB@SWAPB@				; `string'
PUBLIC	??_C@_05PEPKONKF@SWAPW@				; `string'
PUBLIC	??_C@_05JFBFKMDH@SWAPD@				; `string'
PUBLIC	??_C@_05KCKAEKCD@SWAPQ@				; `string'
PUBLIC	??_C@_04IIPHEAHK@DECB@				; `string'
PUBLIC	??_C@_04LPECKGGO@DECW@				; `string'
PUBLIC	??_C@_04NOKNOHPM@DECD@				; `string'
PUBLIC	??_C@_04OJBIABOI@DECQ@				; `string'
PUBLIC	??_C@_04KHGGADMK@INCB@				; `string'
PUBLIC	??_C@_04JANDOFNO@INCW@				; `string'
PUBLIC	??_C@_04PBDMKEEM@INCD@				; `string'
PUBLIC	??_C@_04MGIJECFI@INCQ@				; `string'
PUBLIC	??_C@_06BPAFKAAE@SWAPBQ@			; `string'
PUBLIC	??_C@_06FOIMBJP@SWAPWQ@				; `string'
PUBLIC	??_C@_06BLIINMLG@SWAPDQ@			; `string'
PUBLIC	??_C@_04BMBNMPKO@LDSB@				; `string'
PUBLIC	??_C@_04CLKICJLK@LDSW@				; `string'
PUBLIC	??_C@_04EKEHGICI@LDSD@				; `string'
PUBLIC	??_C@_04HNPCIODM@LDSQ@				; `string'
PUBLIC	??_C@_04KOLEJIGC@STSB@				; `string'
PUBLIC	??_C@_04JJABHOHG@STSW@				; `string'
PUBLIC	??_C@_04PIOODPOE@STSD@				; `string'
PUBLIC	??_C@_04MPFLNJPA@STSQ@				; `string'
PUBLIC	??_C@_05EDKPJED@LDBPB@				; `string'
PUBLIC	??_C@_05DDIPBPFH@LDBPW@				; `string'
PUBLIC	??_C@_05FCGAFOMF@LDBPD@				; `string'
PUBLIC	??_C@_05GFNFLINB@LDBPQ@				; `string'
PUBLIC	??_C@_05JGFKNOIP@STBPB@				; `string'
PUBLIC	??_C@_05KBOPDIJL@STBPW@				; `string'
PUBLIC	??_C@_05MAAAHJAJ@STBPD@				; `string'
PUBLIC	??_C@_05PHLFJPBN@STBPQ@				; `string'
PUBLIC	?RegisterBindings@@3PAPEBDA			; RegisterBindings
PUBLIC	??_C@_02MJBLCCBH@BP@				; `string'
PUBLIC	??_C@_02KJNLNLIB@R1@				; `string'
PUBLIC	??_C@_02ICPGIIEC@R2@				; `string'
PUBLIC	??_C@_02JLONLJAD@R3@				; `string'
PUBLIC	??_C@_02NEKMCPME@R4@				; `string'
PUBLIC	??_C@_02MNLHBOIF@R5@				; `string'
PUBLIC	??_C@_02OGJKENEG@R6@				; `string'
PUBLIC	??_C@_02PPIBHMAH@R7@				; `string'
PUBLIC	??_C@_02HIBJGAMI@R8@				; `string'
PUBLIC	??_C@_02GBACFBIJ@R9@				; `string'
PUBLIC	??_C@_03EFFAFOJO@R10@				; `string'
PUBLIC	??_C@_03FMELGPNP@R11@				; `string'
PUBLIC	??_C@_03HHGGDMBM@R12@				; `string'
PUBLIC	??_C@_03GOHNANFN@R13@				; `string'
PUBLIC	??_C@_03CBDMJLJK@R14@				; `string'
PUBLIC	??_C@_03DICHKKNL@R15@				; `string'
PUBLIC	??_C@_03BDAKPJBI@R16@				; `string'
PUBLIC	??_C@_03KBBMIFJ@R17@				; `string'
PUBLIC	??_C@_03INIJNEJG@R18@				; `string'
PUBLIC	??_C@_03JEJCOFNH@R19@				; `string'
PUBLIC	??_C@_03EHBGOAMH@R20@				; `string'
PUBLIC	??_C@_03FOANNBIG@R21@				; `string'
PUBLIC	??_C@_03HFCAICEF@R22@				; `string'
PUBLIC	??_C@_03GMDLLDAE@R23@				; `string'
PUBLIC	??_C@_03CDHKCFMD@R24@				; `string'
PUBLIC	??_C@_03DKGBBEIC@R25@				; `string'
PUBLIC	??_C@_03BBEMEHEB@R26@				; `string'
PUBLIC	??_C@_03IFHHGAA@R27@				; `string'
PUBLIC	??_C@_03IPMPGKMP@R28@				; `string'
PUBLIC	??_C@_03JGNEFLIO@R29@				; `string'
PUBLIC	??_C@_03EGNEIKPA@R30@				; `string'
PUBLIC	??_C@_03FPMPLLLB@R31@				; `string'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_C@_0BO@EBMDFMC@THIS?5IS?5THE?5START?5XDDDDDD?$CB?$CB?$CB?$CB@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BH@MGKFCHMA@Ur?5out?5of?5memory?5son?4?6@ ; `string'
PUBLIC	??_C@_05PDJBBECF@pause@				; `string'
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__std_terminate:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp__get_stream_buffer_pointers:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_fgetpos:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_fsetpos:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp__lock_file:PROC
EXTRN	__imp__unlock_file:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp_system:PROC
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xinvalid_argument@std@@YAXPEBD@Z:PROC		; std::_Xinvalid_argument
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_toupper:PROC
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_??Bid@locale@std@@QEAA_KXZ:PROC
EXTRN	?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	__imp_?always_noconv@codecvt_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ:PROC
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z:PROC
EXTRN	?_Random_device@std@@YAIXZ:PROC			; std::_Random_device
EXTRN	?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z:PROC	; std::_Fiopen
EXTRN	VmEnter:PROC
EXTRN	ViVmExit:PROC
EXTRN	ViNop:PROC
EXTRN	ViLdib:PROC
EXTRN	ViLdiw:PROC
EXTRN	ViLdid:PROC
EXTRN	ViLdiq:PROC
EXTRN	ViLdibsxw:PROC
EXTRN	ViLdibsxd:PROC
EXTRN	ViLdibsxq:PROC
EXTRN	ViLdiwsxd:PROC
EXTRN	ViLdiwsxq:PROC
EXTRN	ViLdidsxq:PROC
EXTRN	ViLdibzxw:PROC
EXTRN	ViLdibzxd:PROC
EXTRN	ViLdibzxq:PROC
EXTRN	ViLdiwzxd:PROC
EXTRN	ViLdiwzxq:PROC
EXTRN	ViLdidzxq:PROC
EXTRN	ViLdab:PROC
EXTRN	ViLdaw:PROC
EXTRN	ViLdad:PROC
EXTRN	ViLdaq:PROC
EXTRN	ViStab:PROC
EXTRN	ViStaw:PROC
EXTRN	ViStad:PROC
EXTRN	ViStaq:PROC
EXTRN	ViSxbw:PROC
EXTRN	ViSxbd:PROC
EXTRN	ViSxbq:PROC
EXTRN	ViSxwd:PROC
EXTRN	ViSxwq:PROC
EXTRN	ViSxdq:PROC
EXTRN	ViZxbw:PROC
EXTRN	ViZxbd:PROC
EXTRN	ViZxbq:PROC
EXTRN	ViZxwd:PROC
EXTRN	ViZxwq:PROC
EXTRN	ViZxdq:PROC
EXTRN	ViPushb:PROC
EXTRN	ViPushw:PROC
EXTRN	ViPushd:PROC
EXTRN	ViPushq:PROC
EXTRN	ViPopb:PROC
EXTRN	ViPopw:PROC
EXTRN	ViPopd:PROC
EXTRN	ViPopq:PROC
EXTRN	ViNpopb:PROC
EXTRN	ViNpopw:PROC
EXTRN	ViNpopd:PROC
EXTRN	ViNpopq:PROC
EXTRN	ViAddb:PROC
EXTRN	ViAddw:PROC
EXTRN	ViAddd:PROC
EXTRN	ViAddq:PROC
EXTRN	ViSubb:PROC
EXTRN	ViSubw:PROC
EXTRN	ViSubd:PROC
EXTRN	ViSubq:PROC
EXTRN	ViMulb:PROC
EXTRN	ViMulw:PROC
EXTRN	ViMuld:PROC
EXTRN	ViMulq:PROC
EXTRN	ViDivb:PROC
EXTRN	ViDivw:PROC
EXTRN	ViDivd:PROC
EXTRN	ViDivq:PROC
EXTRN	ViAndb:PROC
EXTRN	ViAndw:PROC
EXTRN	ViAndd:PROC
EXTRN	ViAndq:PROC
EXTRN	ViOrb:PROC
EXTRN	ViOrw:PROC
EXTRN	ViOrd:PROC
EXTRN	ViOrq:PROC
EXTRN	ViXorb:PROC
EXTRN	ViXorw:PROC
EXTRN	ViXord:PROC
EXTRN	ViXorq:PROC
EXTRN	ViShlb:PROC
EXTRN	ViShlw:PROC
EXTRN	ViShld:PROC
EXTRN	ViShlq:PROC
EXTRN	ViShrb:PROC
EXTRN	ViShrw:PROC
EXTRN	ViShrd:PROC
EXTRN	ViShrq:PROC
EXTRN	ViCmpb:PROC
EXTRN	ViCmpw:PROC
EXTRN	ViCmpd:PROC
EXTRN	ViCmpq:PROC
EXTRN	ViJmp:PROC
EXTRN	ViJmpi:PROC
EXTRN	ViJl:PROC
EXTRN	ViJle:PROC
EXTRN	ViJg:PROC
EXTRN	ViJge:PROC
EXTRN	ViJz:PROC
EXTRN	ViJnz:PROC
EXTRN	ViCall:PROC
EXTRN	ViRet:PROC
EXTRN	ViX86Call:PROC
EXTRN	ViEditsp:PROC
EXTRN	ViStsp:PROC
EXTRN	ViLdsp:PROC
EXTRN	ViStip:PROC
EXTRN	ViLdip:PROC
EXTRN	ViSwapb:PROC
EXTRN	ViSwapw:PROC
EXTRN	ViSwapd:PROC
EXTRN	ViSwapq:PROC
EXTRN	ViDecb:PROC
EXTRN	ViDecw:PROC
EXTRN	ViDecd:PROC
EXTRN	ViDecq:PROC
EXTRN	ViIncb:PROC
EXTRN	ViIncw:PROC
EXTRN	ViIncd:PROC
EXTRN	ViIncq:PROC
EXTRN	ViSwapbq:PROC
EXTRN	ViSwapwq:PROC
EXTRN	ViSwapdq:PROC
EXTRN	ViLdsb:PROC
EXTRN	ViLdsw:PROC
EXTRN	ViLdsd:PROC
EXTRN	ViLdsq:PROC
EXTRN	ViStsb:PROC
EXTRN	ViStsw:PROC
EXTRN	ViStsd:PROC
EXTRN	ViStsq:PROC
EXTRN	ViLdbpb:PROC
EXTRN	ViLdbpw:PROC
EXTRN	ViLdbpd:PROC
EXTRN	ViLdbpq:PROC
EXTRN	ViStbpb:PROC
EXTRN	ViStbpw:PROC
EXTRN	ViStbpd:PROC
EXTRN	ViStbpq:PROC
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
EXTRN	??1_Lockit@std@@QEAA@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+82
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+66
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+60
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+60
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+66
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+43
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN27
	DD	imagerel $LN27+89
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+23
	DD	imagerel $unwind$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+21
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN50
	DD	imagerel $LN50+218
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN29
	DD	imagerel $LN29+83
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN16
	DD	imagerel $LN16+59
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN44
	DD	imagerel $LN44+230
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN30
	DD	imagerel $LN30+95
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN14
	DD	imagerel $LN14+42
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD imagerel $LN14
	DD	imagerel $LN14+86
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN20
	DD	imagerel $LN20+54
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77
	DD	imagerel $LN77+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77+139
	DD	imagerel $LN77+330
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77+330
	DD	imagerel $LN77+343
	DD	imagerel $chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77+343
	DD	imagerel $LN77+349
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+45
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD imagerel $LN22
	DD	imagerel $LN22+88
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z DD imagerel $LN53
	DD	imagerel $LN53+149
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN38
	DD	imagerel $LN38+81
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN38+81
	DD	imagerel $LN38+222
	DD	imagerel $chain$2$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN38+222
	DD	imagerel $LN38+230
	DD	imagerel $chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN38+230
	DD	imagerel $LN38+246
	DD	imagerel $chain$5$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN34
	DD	imagerel $LN34+92
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z DD imagerel $LN21
	DD	imagerel $LN21+60
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD imagerel $LN19
	DD	imagerel $LN19+67
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN27
	DD	imagerel $LN27+95
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD imagerel $LN35
	DD	imagerel $LN35+128
	DD	imagerel $unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z DD imagerel $LN19
	DD	imagerel $LN19+156
	DD	imagerel $unwind$?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+60
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_cast@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_cast@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+47
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN10
	DD	imagerel $LN10+75
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_CODE_LINK@@QEAA@XZ DD imagerel $LN34
	DD	imagerel $LN34+97
	DD	imagerel $unwind$??1_CODE_LINK@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_CODE_LINK@@QEAAPEAXI@Z DD imagerel $LN39
	DD	imagerel $LN39+130
	DD	imagerel $unwind$??_G_CODE_LINK@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD imagerel $LN27
	DD	imagerel $LN27+89
	DD	imagerel $unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEPEAE00@Z DD imagerel $LN8
	DD	imagerel $LN8+43
	DD	imagerel $unwind$?_Umove@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEPEAE00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+132
	DD	imagerel $unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+112
	DD	imagerel $unwind$?allocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAPEAPEAU_VM_INSTRUCTION@@PEAPEAU3@00@Z DD imagerel $LN8
	DD	imagerel $LN8+49
	DD	imagerel $unwind$?_Umove@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAPEAPEAU_VM_INSTRUCTION@@PEAPEAU3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAXQEAPEAU_VM_INSTRUCTION@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAXQEAPEAU_VM_INSTRUCTION@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD imagerel $LN134
	DD	imagerel $LN134+545
	DD	imagerel $unwind$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA DD imagerel ?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
	DD	imagerel ?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmGetInstructionId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z DD imagerel $LN35
	DD	imagerel $LN35+149
	DD	imagerel $unwind$?VmGetInstructionId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z DD imagerel $LN35
	DD	imagerel $LN35+146
	DD	imagerel $unwind$?VmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN21
	DD	imagerel $LN21+1618
	DD	imagerel $unwind$?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN21+1618
	DD	imagerel $LN21+2132
	DD	imagerel $chain$0$?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmAddInstruction@@YAHPEAU_VM_ASSEMBLER@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD imagerel $LN165
	DD	imagerel $LN165+807
	DD	imagerel $unwind$?VmAddInstruction@@YAHPEAU_VM_ASSEMBLER@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN616
	DD	imagerel $LN616+1870
	DD	imagerel $unwind$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN18+29
	DD	imagerel $LN18+150
	DD	imagerel $chain$2$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN18+150
	DD	imagerel $LN18+161
	DD	imagerel $chain$3$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN43
	DD	imagerel $LN43+198
	DD	imagerel $unwind$?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN75
	DD	imagerel $LN75+86
	DD	imagerel $unwind$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN75+86
	DD	imagerel $LN75+428
	DD	imagerel $chain$2$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN75+428
	DD	imagerel $LN75+456
	DD	imagerel $chain$3$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN92
	DD	imagerel $LN92+183
	DD	imagerel $unwind$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN92+183
	DD	imagerel $LN92+485
	DD	imagerel $chain$0$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN92+485
	DD	imagerel $LN92+524
	DD	imagerel $chain$1$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmGetJumpDelta@@YAHPEAU_CODE_LINK@@@Z DD imagerel $LN67
	DD	imagerel $LN67+259
	DD	imagerel $unwind$?VmGetJumpDelta@@YAHPEAU_CODE_LINK@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN105
	DD	imagerel $LN105+91
	DD	imagerel $unwind$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN105+91
	DD	imagerel $LN105+111
	DD	imagerel $chain$0$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN105+111
	DD	imagerel $LN105+628
	DD	imagerel $chain$2$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN105+628
	DD	imagerel $LN105+648
	DD	imagerel $chain$3$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN105+648
	DD	imagerel $LN105+811
	DD	imagerel $chain$4$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN21
	DD	imagerel $LN21+128
	DD	imagerel $unwind$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN21+128
	DD	imagerel $LN21+183
	DD	imagerel $chain$2$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN21+183
	DD	imagerel $LN21+208
	DD	imagerel $chain$3$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN18
	DD	imagerel $LN18+82
	DD	imagerel $unwind$?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD imagerel $LN87
	DD	imagerel $LN87+500
	DD	imagerel $unwind$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z DD imagerel $LN9
	DD	imagerel $LN9+53
	DD	imagerel $unwind$?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+66
	DD	imagerel $unwind$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+108
	DD	imagerel $unwind$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN11
	DD	imagerel $LN11+54
	DD	imagerel $unwind$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z DD imagerel $LN90
	DD	imagerel $LN90+124
	DD	imagerel $unwind$?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z DD imagerel $LN27
	DD	imagerel $LN27+157
	DD	imagerel $unwind$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN27
	DD	imagerel $LN27+107
	DD	imagerel $unwind$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD imagerel $LN60
	DD	imagerel $LN60+515
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD imagerel $LN13
	DD	imagerel $LN13+76
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN17
	DD	imagerel $LN17+81
	DD	imagerel $unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+105
	DD	imagerel $unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel $LN35
	DD	imagerel $LN35+316
	DD	imagerel $unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN20
	DD	imagerel $LN20+126
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN46
	DD	imagerel $LN46+96
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN46+96
	DD	imagerel $LN46+386
	DD	imagerel $chain$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN46+386
	DD	imagerel $LN46+416
	DD	imagerel $chain$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN57
	DD	imagerel $LN57+224
	DD	imagerel $unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN22
	DD	imagerel $LN22+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN22+51
	DD	imagerel $LN22+77
	DD	imagerel $chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN22+77
	DD	imagerel $LN22+101
	DD	imagerel $chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN276
	DD	imagerel $LN276+719
	DD	imagerel $unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN39
	DD	imagerel $LN39+60
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN39+60
	DD	imagerel $LN39+336
	DD	imagerel $chain$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN39+336
	DD	imagerel $LN39+341
	DD	imagerel $chain$3$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD imagerel $LN20
	DD	imagerel $LN20+212
	DD	imagerel $unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN16
	DD	imagerel $LN16+219
	DD	imagerel $unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN22
	DD	imagerel $LN22+211
	DD	imagerel $unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN19
	DD	imagerel $LN19+77
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN19+77
	DD	imagerel $LN19+221
	DD	imagerel $chain$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN19+221
	DD	imagerel $LN19+243
	DD	imagerel $chain$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN9
	DD	imagerel $LN9+71
	DD	imagerel $unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD imagerel $LN14
	DD	imagerel $LN14+80
	DD	imagerel $unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+192
	DD	imagerel $unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN19
	DD	imagerel $LN19+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN19+53
	DD	imagerel $LN19+148
	DD	imagerel $chain$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN19+148
	DD	imagerel $LN19+211
	DD	imagerel $chain$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN19+211
	DD	imagerel $LN19+232
	DD	imagerel $chain$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+52
	DD	imagerel $unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+101
	DD	imagerel $unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z DD imagerel $LN15
	DD	imagerel $LN15+88
	DD	imagerel $unwind$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD imagerel $LN33
	DD	imagerel $LN33+116
	DD	imagerel $unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD imagerel $LN33+116
	DD	imagerel $LN33+330
	DD	imagerel $chain$0$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD imagerel $LN33+330
	DD	imagerel $LN33+395
	DD	imagerel $chain$1$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ DD imagerel $LN19
	DD	imagerel $LN19+239
	DD	imagerel $unwind$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z DD imagerel $LN13
	DD	imagerel $LN13+68
	DD	imagerel $unwind$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z DD imagerel $LN23
	DD	imagerel $LN23+60
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAPEAU_VM_SYMBOL@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+116
	DD	imagerel $unwind$?allocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAPEAU_VM_SYMBOL@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+122
	DD	imagerel $unwind$??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAPEAU_VM_SYMBOL@@PEAU3@00@Z DD imagerel $LN8
	DD	imagerel $LN8+75
	DD	imagerel $unwind$?_Umove@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAPEAU_VM_SYMBOL@@PEAU3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAXQEAU_VM_SYMBOL@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+176
	DD	imagerel $unwind$?_Change_array@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAXQEAU_VM_SYMBOL@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+122
	DD	imagerel $unwind$?_Tidy@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z DD imagerel $LN94
	DD	imagerel $LN94+512
	DD	imagerel $unwind$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA+40
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel $LN41
	DD	imagerel $LN41+250
	DD	imagerel $unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD imagerel $LN9
	DD	imagerel $LN9+61
	DD	imagerel $unwind$??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DD imagerel $LN328
	DD	imagerel $LN328+636
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA DD imagerel ?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
	DD	imagerel ?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA+58
	DD	imagerel $unwind$?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z DD imagerel $LN92
	DD	imagerel $LN92+411
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA+40
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z DD imagerel $LN89
	DD	imagerel $LN89+375
	DD	imagerel $unwind$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA+40
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN23
	DD	imagerel $LN23+199
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z DD imagerel $LN7
	DD	imagerel $LN7+57
	DD	imagerel $unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel $LN71
	DD	imagerel $LN71+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel $LN71+46
	DD	imagerel $LN71+338
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel $LN71+338
	DD	imagerel $LN71+344
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel $LN71+344
	DD	imagerel $LN71+350
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD imagerel $LN7
	DD	imagerel $LN7+42
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN66
	DD	imagerel $LN66+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN66+39
	DD	imagerel $LN66+289
	DD	imagerel $chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN66+289
	DD	imagerel $LN66+302
	DD	imagerel $chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN66+302
	DD	imagerel $LN66+308
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN18
	DD	imagerel $LN18+53
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD imagerel $LN51
	DD	imagerel $LN51+15
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD imagerel $LN51+15
	DD	imagerel $LN51+125
	DD	imagerel $chain$0$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD imagerel $LN51+125
	DD	imagerel $LN51+126
	DD	imagerel $chain$1$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD imagerel $LN51+126
	DD	imagerel $LN51+133
	DD	imagerel $chain$2$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+89
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD imagerel $LN83
	DD	imagerel $LN83+418
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD imagerel ?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	imagerel ?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+59
	DD	imagerel $unwind$?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAA_J_J@Z DD imagerel $LN59
	DD	imagerel $LN59+608
	DD	imagerel $unwind$??R?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAA_J_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_bits@?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KXZ DD imagerel $LN43
	DD	imagerel $LN43+451
	DD	imagerel $unwind$?_Get_bits@?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD imagerel $LN78
	DD	imagerel $LN78+22
	DD	imagerel $unwind$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD imagerel $LN78+22
	DD	imagerel $LN78+54
	DD	imagerel $chain$0$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD imagerel $LN78+54
	DD	imagerel $LN78+691
	DD	imagerel $chain$6$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD imagerel $LN78+691
	DD	imagerel $LN78+702
	DD	imagerel $chain$7$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD imagerel $LN78+702
	DD	imagerel $LN78+703
	DD	imagerel $chain$8$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN38
	DD	imagerel $LN38+95
	DD	imagerel $unwind$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAU_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAPEAU_VM_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$??$_Uninitialized_move@PEAU_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAPEAU_VM_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CE@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$0CE@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+37
	DD	imagerel $unwind$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+49
	DD	imagerel $unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD imagerel $LN9
	DD	imagerel $LN9+41
	DD	imagerel $unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD imagerel $LN11
	DD	imagerel $LN11+79
	DD	imagerel $unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+36
	DD	imagerel $unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAU_VM_SYMBOL@@PEAU1@@std@@YAPEAU_VM_SYMBOL@@PEAU1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAU_VM_SYMBOL@@PEAU1@@std@@YAPEAU_VM_SYMBOL@@PEAU1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAU_VM_INSTRUCTION@@PEAPEAU1@@std@@YAPEAPEAU_VM_INSTRUCTION@@PEAPEAU1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAU_VM_INSTRUCTION@@PEAPEAU1@@std@@YAPEAPEAU_VM_INSTRUCTION@@PEAPEAU1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
pdata	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b0H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause@
CONST	SEGMENT
??_C@_05PDJBBECF@pause@ DB 'pause', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MGKFCHMA@Ur?5out?5of?5memory?5son?4?6@
CONST	SEGMENT
??_C@_0BH@MGKFCHMA@Ur?5out?5of?5memory?5son?4?6@ DB 'Ur out of memory son'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EBMDFMC@THIS?5IS?5THE?5START?5XDDDDDD?$CB?$CB?$CB?$CB@
CONST	SEGMENT
??_C@_0BO@EBMDFMC@THIS?5IS?5THE?5START?5XDDDDDD?$CB?$CB?$CB?$CB@ DB 'THIS'
	DB	' IS THE START XDDDDDD!!!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	0b0H
CONST	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_C@_03FPMPLLLB@R31@
CONST	SEGMENT
??_C@_03FPMPLLLB@R31@ DB 'R31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EGNEIKPA@R30@
CONST	SEGMENT
??_C@_03EGNEIKPA@R30@ DB 'R30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JGNEFLIO@R29@
CONST	SEGMENT
??_C@_03JGNEFLIO@R29@ DB 'R29', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IPMPGKMP@R28@
CONST	SEGMENT
??_C@_03IPMPGKMP@R28@ DB 'R28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IFHHGAA@R27@
CONST	SEGMENT
??_C@_03IFHHGAA@R27@ DB 'R27', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBEMEHEB@R26@
CONST	SEGMENT
??_C@_03BBEMEHEB@R26@ DB 'R26', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKGBBEIC@R25@
CONST	SEGMENT
??_C@_03DKGBBEIC@R25@ DB 'R25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CDHKCFMD@R24@
CONST	SEGMENT
??_C@_03CDHKCFMD@R24@ DB 'R24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GMDLLDAE@R23@
CONST	SEGMENT
??_C@_03GMDLLDAE@R23@ DB 'R23', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HFCAICEF@R22@
CONST	SEGMENT
??_C@_03HFCAICEF@R22@ DB 'R22', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FOANNBIG@R21@
CONST	SEGMENT
??_C@_03FOANNBIG@R21@ DB 'R21', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EHBGOAMH@R20@
CONST	SEGMENT
??_C@_03EHBGOAMH@R20@ DB 'R20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JEJCOFNH@R19@
CONST	SEGMENT
??_C@_03JEJCOFNH@R19@ DB 'R19', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03INIJNEJG@R18@
CONST	SEGMENT
??_C@_03INIJNEJG@R18@ DB 'R18', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KBBMIFJ@R17@
CONST	SEGMENT
??_C@_03KBBMIFJ@R17@ DB 'R17', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDAKPJBI@R16@
CONST	SEGMENT
??_C@_03BDAKPJBI@R16@ DB 'R16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DICHKKNL@R15@
CONST	SEGMENT
??_C@_03DICHKKNL@R15@ DB 'R15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CBDMJLJK@R14@
CONST	SEGMENT
??_C@_03CBDMJLJK@R14@ DB 'R14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GOHNANFN@R13@
CONST	SEGMENT
??_C@_03GOHNANFN@R13@ DB 'R13', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HHGGDMBM@R12@
CONST	SEGMENT
??_C@_03HHGGDMBM@R12@ DB 'R12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FMELGPNP@R11@
CONST	SEGMENT
??_C@_03FMELGPNP@R11@ DB 'R11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EFFAFOJO@R10@
CONST	SEGMENT
??_C@_03EFFAFOJO@R10@ DB 'R10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GBACFBIJ@R9@
CONST	SEGMENT
??_C@_02GBACFBIJ@R9@ DB 'R9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBJGAMI@R8@
CONST	SEGMENT
??_C@_02HIBJGAMI@R8@ DB 'R8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PPIBHMAH@R7@
CONST	SEGMENT
??_C@_02PPIBHMAH@R7@ DB 'R7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OGJKENEG@R6@
CONST	SEGMENT
??_C@_02OGJKENEG@R6@ DB 'R6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MNLHBOIF@R5@
CONST	SEGMENT
??_C@_02MNLHBOIF@R5@ DB 'R5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEKMCPME@R4@
CONST	SEGMENT
??_C@_02NEKMCPME@R4@ DB 'R4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JLONLJAD@R3@
CONST	SEGMENT
??_C@_02JLONLJAD@R3@ DB 'R3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ICPGIIEC@R2@
CONST	SEGMENT
??_C@_02ICPGIIEC@R2@ DB 'R2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KJNLNLIB@R1@
CONST	SEGMENT
??_C@_02KJNLNLIB@R1@ DB 'R1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MJBLCCBH@BP@
CONST	SEGMENT
??_C@_02MJBLCCBH@BP@ DB 'BP', 00H			; `string'
CONST	ENDS
;	COMDAT ?RegisterBindings@@3PAPEBDA
_DATA	SEGMENT
?RegisterBindings@@3PAPEBDA DQ FLAT:??_C@_02MJBLCCBH@BP@ ; RegisterBindings
	DQ	FLAT:??_C@_02KJNLNLIB@R1@
	DQ	FLAT:??_C@_02ICPGIIEC@R2@
	DQ	FLAT:??_C@_02JLONLJAD@R3@
	DQ	FLAT:??_C@_02NEKMCPME@R4@
	DQ	FLAT:??_C@_02MNLHBOIF@R5@
	DQ	FLAT:??_C@_02OGJKENEG@R6@
	DQ	FLAT:??_C@_02PPIBHMAH@R7@
	DQ	FLAT:??_C@_02HIBJGAMI@R8@
	DQ	FLAT:??_C@_02GBACFBIJ@R9@
	DQ	FLAT:??_C@_03EFFAFOJO@R10@
	DQ	FLAT:??_C@_03FMELGPNP@R11@
	DQ	FLAT:??_C@_03HHGGDMBM@R12@
	DQ	FLAT:??_C@_03GOHNANFN@R13@
	DQ	FLAT:??_C@_03CBDMJLJK@R14@
	DQ	FLAT:??_C@_03DICHKKNL@R15@
	DQ	FLAT:??_C@_03BDAKPJBI@R16@
	DQ	FLAT:??_C@_03KBBMIFJ@R17@
	DQ	FLAT:??_C@_03INIJNEJG@R18@
	DQ	FLAT:??_C@_03JEJCOFNH@R19@
	DQ	FLAT:??_C@_03EHBGOAMH@R20@
	DQ	FLAT:??_C@_03FOANNBIG@R21@
	DQ	FLAT:??_C@_03HFCAICEF@R22@
	DQ	FLAT:??_C@_03GMDLLDAE@R23@
	DQ	FLAT:??_C@_03CDHKCFMD@R24@
	DQ	FLAT:??_C@_03DKGBBEIC@R25@
	DQ	FLAT:??_C@_03BBEMEHEB@R26@
	DQ	FLAT:??_C@_03IFHHGAA@R27@
	DQ	FLAT:??_C@_03IPMPGKMP@R28@
	DQ	FLAT:??_C@_03JGNEFLIO@R29@
	DQ	FLAT:??_C@_03EGNEIKPA@R30@
	DQ	FLAT:??_C@_03FPMPLLLB@R31@
_DATA	ENDS
;	COMDAT ??_C@_05PHLFJPBN@STBPQ@
CONST	SEGMENT
??_C@_05PHLFJPBN@STBPQ@ DB 'STBPQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAAAHJAJ@STBPD@
CONST	SEGMENT
??_C@_05MAAAHJAJ@STBPD@ DB 'STBPD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KBOPDIJL@STBPW@
CONST	SEGMENT
??_C@_05KBOPDIJL@STBPW@ DB 'STBPW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JGFKNOIP@STBPB@
CONST	SEGMENT
??_C@_05JGFKNOIP@STBPB@ DB 'STBPB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFNFLINB@LDBPQ@
CONST	SEGMENT
??_C@_05GFNFLINB@LDBPQ@ DB 'LDBPQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FCGAFOMF@LDBPD@
CONST	SEGMENT
??_C@_05FCGAFOMF@LDBPD@ DB 'LDBPD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DDIPBPFH@LDBPW@
CONST	SEGMENT
??_C@_05DDIPBPFH@LDBPW@ DB 'LDBPW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EDKPJED@LDBPB@
CONST	SEGMENT
??_C@_05EDKPJED@LDBPB@ DB 'LDBPB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MPFLNJPA@STSQ@
CONST	SEGMENT
??_C@_04MPFLNJPA@STSQ@ DB 'STSQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PIOODPOE@STSD@
CONST	SEGMENT
??_C@_04PIOODPOE@STSD@ DB 'STSD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JJABHOHG@STSW@
CONST	SEGMENT
??_C@_04JJABHOHG@STSW@ DB 'STSW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KOLEJIGC@STSB@
CONST	SEGMENT
??_C@_04KOLEJIGC@STSB@ DB 'STSB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HNPCIODM@LDSQ@
CONST	SEGMENT
??_C@_04HNPCIODM@LDSQ@ DB 'LDSQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKEHGICI@LDSD@
CONST	SEGMENT
??_C@_04EKEHGICI@LDSD@ DB 'LDSD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLKICJLK@LDSW@
CONST	SEGMENT
??_C@_04CLKICJLK@LDSW@ DB 'LDSW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMBNMPKO@LDSB@
CONST	SEGMENT
??_C@_04BMBNMPKO@LDSB@ DB 'LDSB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BLIINMLG@SWAPDQ@
CONST	SEGMENT
??_C@_06BLIINMLG@SWAPDQ@ DB 'SWAPDQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOIMBJP@SWAPWQ@
CONST	SEGMENT
??_C@_06FOIMBJP@SWAPWQ@ DB 'SWAPWQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPAFKAAE@SWAPBQ@
CONST	SEGMENT
??_C@_06BPAFKAAE@SWAPBQ@ DB 'SWAPBQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MGIJECFI@INCQ@
CONST	SEGMENT
??_C@_04MGIJECFI@INCQ@ DB 'INCQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PBDMKEEM@INCD@
CONST	SEGMENT
??_C@_04PBDMKEEM@INCD@ DB 'INCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JANDOFNO@INCW@
CONST	SEGMENT
??_C@_04JANDOFNO@INCW@ DB 'INCW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KHGGADMK@INCB@
CONST	SEGMENT
??_C@_04KHGGADMK@INCB@ DB 'INCB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OJBIABOI@DECQ@
CONST	SEGMENT
??_C@_04OJBIABOI@DECQ@ DB 'DECQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NOKNOHPM@DECD@
CONST	SEGMENT
??_C@_04NOKNOHPM@DECD@ DB 'DECD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LPECKGGO@DECW@
CONST	SEGMENT
??_C@_04LPECKGGO@DECW@ DB 'DECW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IIPHEAHK@DECB@
CONST	SEGMENT
??_C@_04IIPHEAHK@DECB@ DB 'DECB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KCKAEKCD@SWAPQ@
CONST	SEGMENT
??_C@_05KCKAEKCD@SWAPQ@ DB 'SWAPQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JFBFKMDH@SWAPD@
CONST	SEGMENT
??_C@_05JFBFKMDH@SWAPD@ DB 'SWAPD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PEPKONKF@SWAPW@
CONST	SEGMENT
??_C@_05PEPKONKF@SWAPW@ DB 'SWAPW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MDEPALLB@SWAPB@
CONST	SEGMENT
??_C@_05MDEPALLB@SWAPB@ DB 'SWAPB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HFFIJJNL@LDIP@
CONST	SEGMENT
??_C@_04HFFIJJNL@LDIP@ DB 'LDIP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MHPBMOBH@STIP@
CONST	SEGMENT
??_C@_04MHPBMOBH@STIP@ DB 'STIP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GEOJLPHN@LDSP@
CONST	SEGMENT
??_C@_04GEOJLPHN@LDSP@ DB 'LDSP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NGEAOILB@STSP@
CONST	SEGMENT
??_C@_04NGEAOILB@STSP@ DB 'STSP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CFKEFNFF@EDITSP@
CONST	SEGMENT
??_C@_06CFKEFNFF@EDITSP@ DB 'EDITSP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EMAGKOAM@X86CALL@
CONST	SEGMENT
??_C@_07EMAGKOAM@X86CALL@ DB 'X86CALL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHDJDALB@RET@
CONST	SEGMENT
??_C@_03BHDJDALB@RET@ DB 'RET', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAGKGBIO@CALL@
CONST	SEGMENT
??_C@_04CAGKGBIO@CALL@ DB 'CALL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BAECINKO@JNZ@
CONST	SEGMENT
??_C@_03BAECINKO@JNZ@ DB 'JNZ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DNOHJLCF@JZ@
CONST	SEGMENT
??_C@_02DNOHJLCF@JZ@ DB 'JZ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCMJLILP@JGE@
CONST	SEGMENT
??_C@_03NCMJLILP@JGE@ DB 'JGE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCILPHDJ@JG@
CONST	SEGMENT
??_C@_02MCILPHDJ@JG@ DB 'JG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NOJMFHFO@JLE@
CONST	SEGMENT
??_C@_03NOJMFHFO@JLE@ DB 'JLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CBHPCOPC@JL@
CONST	SEGMENT
??_C@_02CBHPCOPC@JL@ DB 'JL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04POHBCBG@JMPI@
CONST	SEGMENT
??_C@_04POHBCBG@JMPI@ DB 'JMPI', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OIOLNLHN@JMP@
CONST	SEGMENT
??_C@_03OIOLNLHN@JMP@ DB 'JMP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAOMOIDO@CMPQ@
CONST	SEGMENT
??_C@_04IAOMOIDO@CMPQ@ DB 'CMPQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LHFJAOCK@CMPD@
CONST	SEGMENT
??_C@_04LHFJAOCK@CMPD@ DB 'CMPD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NGLGEPLI@CMPW@
CONST	SEGMENT
??_C@_04NGLGEPLI@CMPW@ DB 'CMPW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OBADKJKM@CMPB@
CONST	SEGMENT
??_C@_04OBADKJKM@CMPB@ DB 'CMPB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEFGFLOA@SHRQ@
CONST	SEGMENT
??_C@_04NEFGFLOA@SHRQ@ DB 'SHRQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODODLNPE@SHRD@
CONST	SEGMENT
??_C@_04ODODLNPE@SHRD@ DB 'SHRD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ICAMPMGG@SHRW@
CONST	SEGMENT
??_C@_04ICAMPMGG@SHRW@ DB 'SHRW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFLJBKHC@SHRB@
CONST	SEGMENT
??_C@_04LFLJBKHC@SHRB@ DB 'SHRB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MCOONFJK@SHLQ@
CONST	SEGMENT
??_C@_04MCOONFJK@SHLQ@ DB 'SHLQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFFLDDIO@SHLD@
CONST	SEGMENT
??_C@_04PFFLDDIO@SHLD@ DB 'SHLD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JELEHCBM@SHLW@
CONST	SEGMENT
??_C@_04JELEHCBM@SHLW@ DB 'SHLW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDABJEAI@SHLB@
CONST	SEGMENT
??_C@_04KDABJEAI@SHLB@ DB 'SHLB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DOFBFCEI@XORQ@
CONST	SEGMENT
??_C@_04DOFBFCEI@XORQ@ DB 'XORQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JOELEFM@XORD@
CONST	SEGMENT
??_C@_04JOELEFM@XORD@ DB 'XORD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GIALPFMO@XORW@
CONST	SEGMENT
??_C@_04GIALPFMO@XORW@ DB 'XORW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FPLOBDNK@XORB@
CONST	SEGMENT
??_C@_04FPLOBDNK@XORB@ DB 'XORB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NBFEPOED@ORQ@
CONST	SEGMENT
??_C@_03NBFEPOED@ORQ@ DB 'ORQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OGOBBIFH@ORD@
CONST	SEGMENT
??_C@_03OGOBBIFH@ORD@ DB 'ORD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IHAOFJMF@ORW@
CONST	SEGMENT
??_C@_03IHAOFJMF@ORW@ DB 'ORW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LALLLPNB@ORB@
CONST	SEGMENT
??_C@_03LALLLPNB@ORB@ DB 'ORB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDLGBPBM@ANDQ@
CONST	SEGMENT
??_C@_04PDLGBPBM@ANDQ@ DB 'ANDQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEADPJAI@ANDD@
CONST	SEGMENT
??_C@_04MEADPJAI@ANDD@ DB 'ANDD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KFOMLIJK@ANDW@
CONST	SEGMENT
??_C@_04KFOMLIJK@ANDW@ DB 'ANDW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JCFJFOIO@ANDB@
CONST	SEGMENT
??_C@_04JCFJFOIO@ANDB@ DB 'ANDB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJCDNPML@DIVQ@
CONST	SEGMENT
??_C@_04LJCDNPML@DIVQ@ DB 'DIVQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOJGDJNP@DIVD@
CONST	SEGMENT
??_C@_04IOJGDJNP@DIVD@ DB 'DIVD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OPHJHIEN@DIVW@
CONST	SEGMENT
??_C@_04OPHJHIEN@DIVW@ DB 'DIVW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIMMJOFJ@DIVB@
CONST	SEGMENT
??_C@_04NIMMJOFJ@DIVB@ DB 'DIVB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LPENHDDL@MULQ@
CONST	SEGMENT
??_C@_04LPENHDDL@MULQ@ DB 'MULQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IIPIJFCP@MULD@
CONST	SEGMENT
??_C@_04IIPIJFCP@MULD@ DB 'MULD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OJBHNELN@MULW@
CONST	SEGMENT
??_C@_04OJBHNELN@MULW@ DB 'MULW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NOKCDCKJ@MULB@
CONST	SEGMENT
??_C@_04NOKCDCKJ@MULB@ DB 'MULB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKADHHNC@SUBQ@
CONST	SEGMENT
??_C@_04GKADHHNC@SUBQ@ DB 'SUBQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FNLGJBMG@SUBD@
CONST	SEGMENT
??_C@_04FNLGJBMG@SUBD@ DB 'SUBD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DMFJNAFE@SUBW@
CONST	SEGMENT
??_C@_04DMFJNAFE@SUBW@ DB 'SUBW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOMDGEA@SUBB@
CONST	SEGMENT
??_C@_04LOMDGEA@SUBB@ DB 'SUBB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JMALPPHI@ADDQ@
CONST	SEGMENT
??_C@_04JMALPPHI@ADDQ@ DB 'ADDQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLLOBJGM@ADDD@
CONST	SEGMENT
??_C@_04KLLOBJGM@ADDD@ DB 'ADDD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKFBFIPO@ADDW@
CONST	SEGMENT
??_C@_04MKFBFIPO@ADDW@ DB 'ADDW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNOELOOK@ADDB@
CONST	SEGMENT
??_C@_04PNOELOOK@ADDB@ DB 'ADDB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EPBHPAEF@NPOPQ@
CONST	SEGMENT
??_C@_05EPBHPAEF@NPOPQ@ DB 'NPOPQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HIKCBGFB@NPOPD@
CONST	SEGMENT
??_C@_05HIKCBGFB@NPOPD@ DB 'NPOPD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BJENFHMD@NPOPW@
CONST	SEGMENT
??_C@_05BJENFHMD@NPOPW@ DB 'NPOPW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05COPILBNH@NPOPB@
CONST	SEGMENT
??_C@_05COPILBNH@NPOPB@ DB 'NPOPB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKFMNOH@POPQ@
CONST	SEGMENT
??_C@_04NKFMNOH@POPQ@ DB 'POPQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKBACLPD@POPD@
CONST	SEGMENT
??_C@_04DKBACLPD@POPD@ DB 'POPD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FLPPGKGB@POPW@
CONST	SEGMENT
??_C@_04FLPPGKGB@POPW@ DB 'POPW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMEKIMHF@POPB@
CONST	SEGMENT
??_C@_04GMEKIMHF@POPB@ DB 'POPB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LGNBAGDB@PUSHQ@
CONST	SEGMENT
??_C@_05LGNBAGDB@PUSHQ@ DB 'PUSHQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IBGEOACF@PUSHD@
CONST	SEGMENT
??_C@_05IBGEOACF@PUSHD@ DB 'PUSHD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAILKBLH@PUSHW@
CONST	SEGMENT
??_C@_05OAILKBLH@PUSHW@ DB 'PUSHW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NHDOEHKD@PUSHB@
CONST	SEGMENT
??_C@_05NHDOEHKD@PUSHB@ DB 'PUSHB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBPELBMM@ZXDQ@
CONST	SEGMENT
??_C@_04JBPELBMM@ZXDQ@ DB 'ZXDQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPJEKMOF@ZXWQ@
CONST	SEGMENT
??_C@_04IPJEKMOF@ZXWQ@ DB 'ZXWQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LICBEKPB@ZXWD@
CONST	SEGMENT
??_C@_04LICBEKPB@ZXWD@ DB 'ZXWD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFHJMNHO@ZXBQ@
CONST	SEGMENT
??_C@_04JFHJMNHO@ZXBQ@ DB 'ZXBQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCMMCLGK@ZXBD@
CONST	SEGMENT
??_C@_04KCMMCLGK@ZXBD@ DB 'ZXBD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDCDGKPI@ZXBW@
CONST	SEGMENT
??_C@_04MDCDGKPI@ZXBW@ DB 'ZXBW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JMOENDLN@SXDQ@
CONST	SEGMENT
??_C@_04JMOENDLN@SXDQ@ DB 'SXDQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ICIEMOJE@SXWQ@
CONST	SEGMENT
??_C@_04ICIEMOJE@SXWQ@ DB 'SXWQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFDBCIIA@SXWD@
CONST	SEGMENT
??_C@_04LFDBCIIA@SXWD@ DB 'SXWD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JIGJKPAP@SXBQ@
CONST	SEGMENT
??_C@_04JIGJKPAP@SXBQ@ DB 'SXBQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KPNMEJBL@SXBD@
CONST	SEGMENT
??_C@_04KPNMEJBL@SXBD@ DB 'SXBD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MODDAIIJ@SXBW@
CONST	SEGMENT
??_C@_04MODDAIIJ@SXBW@ DB 'SXBW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NAPJKOOO@STAQ@
CONST	SEGMENT
??_C@_04NAPJKOOO@STAQ@ DB 'STAQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHEMEIPK@STAD@
CONST	SEGMENT
??_C@_04OHEMEIPK@STAD@ DB 'STAD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IGKDAJGI@STAW@
CONST	SEGMENT
??_C@_04IGKDAJGI@STAW@ DB 'STAW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBBGOPHM@STAB@
CONST	SEGMENT
??_C@_04LBBGOPHM@STAB@ DB 'STAB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GCFAPJCC@LDAQ@
CONST	SEGMENT
??_C@_04GCFAPJCC@LDAQ@ DB 'LDAQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFOFBPDG@LDAD@
CONST	SEGMENT
??_C@_04FFOFBPDG@LDAD@ DB 'LDAD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DEAKFOKE@LDAW@
CONST	SEGMENT
??_C@_04DEAKFOKE@LDAW@ DB 'LDAW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DLPLILA@LDAB@
CONST	SEGMENT
??_C@_04DLPLILA@LDAB@ DB 'LDAB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LEDAPPKI@LDIDZXQ@
CONST	SEGMENT
??_C@_07LEDAPPKI@LDIDZXQ@ DB 'LDIDZXQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDHABCPK@LDIWZXQ@
CONST	SEGMENT
??_C@_07JDHABCPK@LDIWZXQ@ DB 'LDIWZXQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEMFPEOO@LDIWZXD@
CONST	SEGMENT
??_C@_07KEMFPEOO@LDIWZXD@ DB 'LDIWZXD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHAAKAI@LDIBZXQ@
CONST	SEGMENT
??_C@_07DLHAAKAI@LDIBZXQ@ DB 'LDIBZXQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMFOMBM@LDIBZXD@
CONST	SEGMENT
??_C@_07MMFOMBM@LDIBZXD@ DB 'LDIBZXD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GNCKKNIO@LDIBZXW@
CONST	SEGMENT
??_C@_07GNCKKNIO@LDIBZXW@ DB 'LDIBZXW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MJDILACC@LDIDSXQ@
CONST	SEGMENT
??_C@_07MJDILACC@LDIDSXQ@ DB 'LDIDSXQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOHIFNHA@LDIWSXQ@
CONST	SEGMENT
??_C@_07OOHIFNHA@LDIWSXQ@ DB 'LDIWSXQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NJMNLLGE@LDIWSXD@
CONST	SEGMENT
??_C@_07NJMNLLGE@LDIWSXD@ DB 'LDIWSXD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGHIEFIC@LDIBSXQ@
CONST	SEGMENT
??_C@_07EGHIEFIC@LDIBSXQ@ DB 'LDIBSXQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HBMNKDJG@LDIBSXD@
CONST	SEGMENT
??_C@_07HBMNKDJG@LDIBSXD@ DB 'LDIBSXD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BACCOCAE@LDIBSXW@
CONST	SEGMENT
??_C@_07BACCOCAE@LDIBSXW@ DB 'LDIBSXW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMEDKIJK@LDIQ@
CONST	SEGMENT
??_C@_04GMEDKIJK@LDIQ@ DB 'LDIQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FLPGEOIO@LDID@
CONST	SEGMENT
??_C@_04FLPGEOIO@LDID@ DB 'LDID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKBJAPBM@LDIW@
CONST	SEGMENT
??_C@_04DKBJAPBM@LDIW@ DB 'LDIW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKMOJAI@LDIB@
CONST	SEGMENT
??_C@_04NKMOJAI@LDIB@ DB 'LDIB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GEANJIEE@NOP@
CONST	SEGMENT
??_C@_03GEANJIEE@NOP@ DB 'NOP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KOGGDLNF@VMEXIT@
CONST	SEGMENT
??_C@_06KOGGDLNF@VMEXIT@ DB 'VMEXIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07COKNFLJB@VMENTER@
CONST	SEGMENT
??_C@_07COKNFLJB@VMENTER@ DB 'VMENTER', 00H		; `string'
CONST	ENDS
;	COMDAT ?InstructionBindings@@3PAPEBDA
_DATA	SEGMENT
?InstructionBindings@@3PAPEBDA DQ FLAT:??_C@_07COKNFLJB@VMENTER@ ; InstructionBindings
	DQ	FLAT:??_C@_06KOGGDLNF@VMEXIT@
	DQ	FLAT:??_C@_03GEANJIEE@NOP@
	DQ	FLAT:??_C@_04NKMOJAI@LDIB@
	DQ	FLAT:??_C@_04DKBJAPBM@LDIW@
	DQ	FLAT:??_C@_04FLPGEOIO@LDID@
	DQ	FLAT:??_C@_04GMEDKIJK@LDIQ@
	DQ	FLAT:??_C@_07BACCOCAE@LDIBSXW@
	DQ	FLAT:??_C@_07HBMNKDJG@LDIBSXD@
	DQ	FLAT:??_C@_07EGHIEFIC@LDIBSXQ@
	DQ	FLAT:??_C@_07NJMNLLGE@LDIWSXD@
	DQ	FLAT:??_C@_07OOHIFNHA@LDIWSXQ@
	DQ	FLAT:??_C@_07MJDILACC@LDIDSXQ@
	DQ	FLAT:??_C@_07GNCKKNIO@LDIBZXW@
	DQ	FLAT:??_C@_07MMFOMBM@LDIBZXD@
	DQ	FLAT:??_C@_07DLHAAKAI@LDIBZXQ@
	DQ	FLAT:??_C@_07KEMFPEOO@LDIWZXD@
	DQ	FLAT:??_C@_07JDHABCPK@LDIWZXQ@
	DQ	FLAT:??_C@_07LEDAPPKI@LDIDZXQ@
	DQ	FLAT:??_C@_04DLPLILA@LDAB@
	DQ	FLAT:??_C@_04DEAKFOKE@LDAW@
	DQ	FLAT:??_C@_04FFOFBPDG@LDAD@
	DQ	FLAT:??_C@_04GCFAPJCC@LDAQ@
	DQ	FLAT:??_C@_04LBBGOPHM@STAB@
	DQ	FLAT:??_C@_04IGKDAJGI@STAW@
	DQ	FLAT:??_C@_04OHEMEIPK@STAD@
	DQ	FLAT:??_C@_04NAPJKOOO@STAQ@
	DQ	FLAT:??_C@_04MODDAIIJ@SXBW@
	DQ	FLAT:??_C@_04KPNMEJBL@SXBD@
	DQ	FLAT:??_C@_04JIGJKPAP@SXBQ@
	DQ	FLAT:??_C@_04LFDBCIIA@SXWD@
	DQ	FLAT:??_C@_04ICIEMOJE@SXWQ@
	DQ	FLAT:??_C@_04JMOENDLN@SXDQ@
	DQ	FLAT:??_C@_04MDCDGKPI@ZXBW@
	DQ	FLAT:??_C@_04KCMMCLGK@ZXBD@
	DQ	FLAT:??_C@_04JFHJMNHO@ZXBQ@
	DQ	FLAT:??_C@_04LICBEKPB@ZXWD@
	DQ	FLAT:??_C@_04IPJEKMOF@ZXWQ@
	DQ	FLAT:??_C@_04JBPELBMM@ZXDQ@
	DQ	FLAT:??_C@_05NHDOEHKD@PUSHB@
	DQ	FLAT:??_C@_05OAILKBLH@PUSHW@
	DQ	FLAT:??_C@_05IBGEOACF@PUSHD@
	DQ	FLAT:??_C@_05LGNBAGDB@PUSHQ@
	DQ	FLAT:??_C@_04GMEKIMHF@POPB@
	DQ	FLAT:??_C@_04FLPPGKGB@POPW@
	DQ	FLAT:??_C@_04DKBACLPD@POPD@
	DQ	FLAT:??_C@_04NKFMNOH@POPQ@
	DQ	FLAT:??_C@_05COPILBNH@NPOPB@
	DQ	FLAT:??_C@_05BJENFHMD@NPOPW@
	DQ	FLAT:??_C@_05HIKCBGFB@NPOPD@
	DQ	FLAT:??_C@_05EPBHPAEF@NPOPQ@
	DQ	FLAT:??_C@_04PNOELOOK@ADDB@
	DQ	FLAT:??_C@_04MKFBFIPO@ADDW@
	DQ	FLAT:??_C@_04KLLOBJGM@ADDD@
	DQ	FLAT:??_C@_04JMALPPHI@ADDQ@
	DQ	FLAT:??_C@_04LOMDGEA@SUBB@
	DQ	FLAT:??_C@_04DMFJNAFE@SUBW@
	DQ	FLAT:??_C@_04FNLGJBMG@SUBD@
	DQ	FLAT:??_C@_04GKADHHNC@SUBQ@
	DQ	FLAT:??_C@_04NOKCDCKJ@MULB@
	DQ	FLAT:??_C@_04OJBHNELN@MULW@
	DQ	FLAT:??_C@_04IIPIJFCP@MULD@
	DQ	FLAT:??_C@_04LPENHDDL@MULQ@
	DQ	FLAT:??_C@_04NIMMJOFJ@DIVB@
	DQ	FLAT:??_C@_04OPHJHIEN@DIVW@
	DQ	FLAT:??_C@_04IOJGDJNP@DIVD@
	DQ	FLAT:??_C@_04LJCDNPML@DIVQ@
	DQ	FLAT:??_C@_04JCFJFOIO@ANDB@
	DQ	FLAT:??_C@_04KFOMLIJK@ANDW@
	DQ	FLAT:??_C@_04MEADPJAI@ANDD@
	DQ	FLAT:??_C@_04PDLGBPBM@ANDQ@
	DQ	FLAT:??_C@_03LALLLPNB@ORB@
	DQ	FLAT:??_C@_03IHAOFJMF@ORW@
	DQ	FLAT:??_C@_03OGOBBIFH@ORD@
	DQ	FLAT:??_C@_03NBFEPOED@ORQ@
	DQ	FLAT:??_C@_04FPLOBDNK@XORB@
	DQ	FLAT:??_C@_04GIALPFMO@XORW@
	DQ	FLAT:??_C@_04JOELEFM@XORD@
	DQ	FLAT:??_C@_04DOFBFCEI@XORQ@
	DQ	FLAT:??_C@_04KDABJEAI@SHLB@
	DQ	FLAT:??_C@_04JELEHCBM@SHLW@
	DQ	FLAT:??_C@_04PFFLDDIO@SHLD@
	DQ	FLAT:??_C@_04MCOONFJK@SHLQ@
	DQ	FLAT:??_C@_04LFLJBKHC@SHRB@
	DQ	FLAT:??_C@_04ICAMPMGG@SHRW@
	DQ	FLAT:??_C@_04ODODLNPE@SHRD@
	DQ	FLAT:??_C@_04NEFGFLOA@SHRQ@
	DQ	FLAT:??_C@_04OBADKJKM@CMPB@
	DQ	FLAT:??_C@_04NGLGEPLI@CMPW@
	DQ	FLAT:??_C@_04LHFJAOCK@CMPD@
	DQ	FLAT:??_C@_04IAOMOIDO@CMPQ@
	DQ	FLAT:??_C@_03OIOLNLHN@JMP@
	DQ	FLAT:??_C@_04POHBCBG@JMPI@
	DQ	FLAT:??_C@_02CBHPCOPC@JL@
	DQ	FLAT:??_C@_03NOJMFHFO@JLE@
	DQ	FLAT:??_C@_02MCILPHDJ@JG@
	DQ	FLAT:??_C@_03NCMJLILP@JGE@
	DQ	FLAT:??_C@_02DNOHJLCF@JZ@
	DQ	FLAT:??_C@_03BAECINKO@JNZ@
	DQ	FLAT:??_C@_04CAGKGBIO@CALL@
	DQ	FLAT:??_C@_03BHDJDALB@RET@
	DQ	FLAT:??_C@_07EMAGKOAM@X86CALL@
	DQ	FLAT:??_C@_06CFKEFNFF@EDITSP@
	DQ	FLAT:??_C@_04NGEAOILB@STSP@
	DQ	FLAT:??_C@_04GEOJLPHN@LDSP@
	DQ	FLAT:??_C@_04MHPBMOBH@STIP@
	DQ	FLAT:??_C@_04HFFIJJNL@LDIP@
	DQ	FLAT:??_C@_05MDEPALLB@SWAPB@
	DQ	FLAT:??_C@_05PEPKONKF@SWAPW@
	DQ	FLAT:??_C@_05JFBFKMDH@SWAPD@
	DQ	FLAT:??_C@_05KCKAEKCD@SWAPQ@
	DQ	FLAT:??_C@_04IIPHEAHK@DECB@
	DQ	FLAT:??_C@_04LPECKGGO@DECW@
	DQ	FLAT:??_C@_04NOKNOHPM@DECD@
	DQ	FLAT:??_C@_04OJBIABOI@DECQ@
	DQ	FLAT:??_C@_04KHGGADMK@INCB@
	DQ	FLAT:??_C@_04JANDOFNO@INCW@
	DQ	FLAT:??_C@_04PBDMKEEM@INCD@
	DQ	FLAT:??_C@_04MGIJECFI@INCQ@
	DQ	FLAT:??_C@_06BPAFKAAE@SWAPBQ@
	DQ	FLAT:??_C@_06FOIMBJP@SWAPWQ@
	DQ	FLAT:??_C@_06BLIINMLG@SWAPDQ@
	DQ	FLAT:??_C@_04BMBNMPKO@LDSB@
	DQ	FLAT:??_C@_04CLKICJLK@LDSW@
	DQ	FLAT:??_C@_04EKEHGICI@LDSD@
	DQ	FLAT:??_C@_04HNPCIODM@LDSQ@
	DQ	FLAT:??_C@_04KOLEJIGC@STSB@
	DQ	FLAT:??_C@_04JJABHOHG@STSW@
	DQ	FLAT:??_C@_04PIOODPOE@STSD@
	DQ	FLAT:??_C@_04MPFLNJPA@STSQ@
	DQ	FLAT:??_C@_05EDKPJED@LDBPB@
	DQ	FLAT:??_C@_05DDIPBPFH@LDBPW@
	DQ	FLAT:??_C@_05FCGAFOMF@LDBPD@
	DQ	FLAT:??_C@_05GFNFLINB@LDBPQ@
	DQ	FLAT:??_C@_05JGFKNOIP@STBPB@
	DQ	FLAT:??_C@_05KBOPDIJL@STBPW@
	DQ	FLAT:??_C@_05MAAAHJAJ@STBPD@
	DQ	FLAT:??_C@_05PHLFJPBN@STBPQ@
_DATA	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ DB 'stoi argument out '
	DB	'of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
CONST	SEGMENT
??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@ DB 'invalid stoi argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAU_VM_INSTRUCTION@@PEAPEAU1@@std@@YAPEAPEAU_VM_INSTRUCTION@@PEAPEAU1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAU_VM_SYMBOL@@PEAU1@@std@@YAPEAU_VM_SYMBOL@@PEAU1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 04H
	DB	'Z'
	DB	00H
	DB	016H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	imagerel $ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CE@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAU_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAPEAU_VM_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD 021H
	DD	imagerel $LN78
	DD	imagerel $LN78+22
	DD	imagerel $unwind$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD 021H
	DD	imagerel $LN78+22
	DD	imagerel $LN78+54
	DD	imagerel $chain$0$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD 0c1821H
	DD	02f418H
	DD	04c414H
	DD	057410H
	DD	0b640cH
	DD	095408H
	DD	083404H
	DD	imagerel $LN78+22
	DD	imagerel $LN78+54
	DD	imagerel $chain$0$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD 020421H
	DD	03d404H
	DD	imagerel $LN78
	DD	imagerel $LN78+22
	DD	imagerel $unwind$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z DD 021201H
	DD	0e00e5212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_bits@?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KXZ DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAA_J_J@Z DD 0b1a01H
	DD	07741aH
	DD	06641aH
	DD	05541aH
	DD	04341aH
	DD	0e018f01aH
	DD	0c016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 010H
	DB	0a0H
	DB	00H
	DB	012H
	DB	02H
	DB	'd'
	DB	06H
	DB	0a4H
	DB	04H
	DB	'n'
	DB	06H
	DB	'L'
	DB	04H
	DB	'd'
	DB	0aH
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DB	0e9H, 04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 0aH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 038H
	DD	imagerel $stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	imagerel $tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	imagerel $ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0a1719H
	DD	0116417H
	DD	0103417H
	DD	0f0137217H
	DD	0d00fe011H
	DD	0700bc00dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 020021H
	DD	076400H
	DD	imagerel $LN51
	DD	imagerel $LN51+15
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+15
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 020521H
	DD	076405H
	DD	imagerel $LN51
	DD	imagerel $LN51+15
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 040f01H
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 040021H
	DD	045400H
	DD	0c3400H
	DD	imagerel $LN66
	DD	imagerel $LN66+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 043c21H
	DD	0c343cH
	DD	045405H
	DD	imagerel $LN66
	DD	imagerel $LN66+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 050b01H
	DD	0f007420bH
	DD	07003e005H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 021H
	DD	imagerel $LN71
	DD	imagerel $LN71+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 060021H
	DD	04e400H
	DD	0dc400H
	DD	0c7400H
	DD	imagerel $LN71
	DD	imagerel $LN71+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 064521H
	DD	0c7445H
	DD	04e411H
	DD	0dc405H
	DD	imagerel $LN71
	DD	imagerel $LN71+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 050a01H
	DD	0f006420aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z DB 06H
	DB	'1', 02H
	DB	00H
	DB	'j'
	DB	02H
	DB	0a9H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z DD 0a1719H
	DD	0116417H
	DD	0103417H
	DD	0f0137217H
	DD	0d00fe011H
	DD	0700bc00dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z DB 06H
	DB	0b1H, 02H
	DB	00H
	DB	'j'
	DB	02H
	DB	0b9H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z DD 0a1719H
	DD	0116417H
	DD	0103417H
	DD	0f0137217H
	DD	0d00fe011H
	DD	0700bc00dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA DD 030b01H
	DD	05007420bH
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 06H
	DB	'y', 02H
	DB	00H
	DB	0b4H
	DB	02H
	DB	01H, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DD 081019H
	DD	0f00c9210H
	DD	0d008e00aH
	DD	07004c006H
	DD	030026003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 08H
	DB	084H
	DB	02H
	DB	0d4H
	DB	04H
	DB	':'
	DB	00H
	DB	'V'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 04H
	DB	0aH
	DD	imagerel __imp_??1_Lockit@std@@QEAA@XZ
	DB	050H
	DB	032H
	DD	imagerel ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z DB 06H
	DB	091H, 03H
	DB	00H
	DB	'j'
	DB	02H
	DB	'm', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z DD 0a1719H
	DD	0116417H
	DD	0103417H
	DD	0f0137217H
	DD	0d00fe011H
	DD	0700bc00dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAXQEAU_VM_SYMBOL@@_K1@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@AEAAPEAU_VM_SYMBOL@@PEAU3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAPEAU_VM_SYMBOL@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+116
	DD	imagerel $unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD 020421H
	DD	03404H
	DD	imagerel $LN33
	DD	imagerel $LN33+116
	DD	imagerel $unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 020021H
	DD	0f7400H
	DD	imagerel $LN19
	DD	imagerel $LN19+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 020521H
	DD	0f7405H
	DD	imagerel $LN19
	DD	imagerel $LN19+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 021519H
	DD	03002b206H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD 061e19H
	DD	0d640fH
	DD	0c340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+77
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 020521H
	DD	087405H
	DD	imagerel $LN19
	DD	imagerel $LN19+77
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 031619H
	DD	060038207H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 041719H
	DD	070045208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 051819H
	DD	070056209H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD 0a4501H
	DD	076445H
	DD	065440H
	DD	097410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 040021H
	DD	047400H
	DD	053400H
	DD	imagerel $LN39
	DD	imagerel $LN39+60
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 041f21H
	DD	05341fH
	DD	047405H
	DD	imagerel $LN39
	DD	imagerel $LN39+60
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 040901H
	DD	0e0055209H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 04H
	DB	0b1H, 04H
	DB	02H
	DB	'Q', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 028H
	DD	imagerel $stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	imagerel $ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 062319H
	DD	0147415H
	DD	0133415H
	DD	0500bf215H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020021H
	DD	067400H
	DD	imagerel $LN22
	DD	imagerel $LN22+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020521H
	DD	067405H
	DD	imagerel $LN22
	DD	imagerel $LN22+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+96
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 020821H
	DD	0146408H
	DD	imagerel $LN46
	DD	imagerel $LN46+96
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 041c19H
	DD	015340dH
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 06H
	DB	't'
	DB	00H
	DB	']', 02H
	DB	02H
	DB	'X'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 02H
	DB	0aH
	DD	imagerel ??1locale@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 028H
	DD	imagerel $stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	imagerel $ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 041719H
	DD	070049208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 02H
	DB	0aaH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 04H
	DB	01cH
	DB	00H
	DB	'8'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0cH
	DD	imagerel __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020611H
	DD	030025206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 010H
	DB	0a0H
	DB	00H
	DB	'>'
	DB	02H
	DB	'd'
	DB	04H
	DB	'8'
	DB	06H
	DB	'N'
	DB	08H
	DB	'U', 02H
	DB	0aH
	DB	'X'
	DB	08H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02cH
	DD	imagerel __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DB	080H
	DB	05eH
	DD	imagerel ?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02aH
	DD	imagerel ??1locale@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	imagerel $ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD 071c19H
	DD	0f009c20dH
	DD	07005e007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z DD 011719H
	DD	02209H
	DD	imagerel __GSHandlerCheck
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DB 04H
	DB	'E', 02H
	DB	02H
	DB	015H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DB 028H
	DD	imagerel $stateUnwindMap$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
	DD	imagerel $ip2state$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 0a2519H
	DD	0115416H
	DD	0103416H
	DD	0f0127216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+128
	DD	imagerel $unwind$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 020521H
	DD	063405H
	DD	imagerel $LN21
	DD	imagerel $LN21+128
	DD	imagerel $unwind$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 087801H
	DD	086478H
	DD	075465H
	DD	09740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 021H
	DD	imagerel $LN105
	DD	imagerel $LN105+91
	DD	imagerel $unwind$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 021H
	DD	imagerel $LN105+91
	DD	imagerel $LN105+111
	DD	imagerel $chain$0$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 040a21H
	DD	04f40aH
	DD	0e5405H
	DD	imagerel $LN105+91
	DD	imagerel $LN105+111
	DD	imagerel $chain$0$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 020521H
	DD	05e405H
	DD	imagerel $LN105
	DD	imagerel $LN105+91
	DD	imagerel $unwind$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z DD 060c01H
	DD	0d008520cH
	DD	07004c006H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmGetJumpDelta@@YAHPEAU_CODE_LINK@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z DD 021H
	DD	imagerel $LN92
	DD	imagerel $LN92+183
	DD	imagerel $unwind$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z DD 020821H
	DD	0285c408H
	DD	imagerel $LN92
	DD	imagerel $LN92+183
	DD	imagerel $unwind$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z DD 092b19H
	DD	02863419H
	DD	027e0119H
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	013e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z DD 021H
	DD	imagerel $LN75
	DD	imagerel $LN75+86
	DD	imagerel $unwind$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z DD 061821H
	DD	0283f418H
	DD	02825410H
	DD	02813408H
	DD	imagerel $LN75
	DD	imagerel $LN75+86
	DD	imagerel $unwind$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z DD 052419H
	DD	027c0112H
	DD	07003e005H
	DD	06002H
	DD	imagerel __GSHandlerCheck
	DD	013d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z DD 032119H
	DD	027c010fH
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	013d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z DD 061921H
	DD	08e419H
	DD	07540aH
	DD	063405H
	DD	imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 016H
	DB	09H, 02H
	DB	00H
	DB	092H
	DB	02H
	DB	0d8H
	DB	04H
	DB	019H, 05H
	DB	06H
	DB	0c5H, 03H
	DB	04H
	DB	','
	DB	08H
	DB	'u', 03H
	DB	0cH
	DB	0f5H, 03H
	DB	04H
	DB	'9', 05H
	DB	02H
	DB	'Z'
	DB	00H
	DB	0deH
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0cH
	DB	0aH
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	05H
	DB	03eH
	DD	imagerel __std_terminate
	DB	062H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	032H
	DD	imagerel ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
	DB	01H
	DB	06H
	DB	0caH
	DD	imagerel ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
	DB	01H
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0b3219H
	DD	03d6421H
	DD	03c3421H
	DD	0340121H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	019aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmAddInstruction@@YAHPEAU_VM_ASSEMBLER@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0d5d01H
	DD	04f45dH
	DD	0cd458H
	DD	0b744fH
	DD	0a5447H
	DD	0e007420bH
	DD	06003c005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z DD 020421H
	DD	010a7404H
	DD	imagerel $LN21
	DD	imagerel $LN21+1618
	DD	imagerel $unwind$?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z DD 0b2201H
	DD	010c6422H
	DD	010b3422H
	DD	01040122H
	DD	0e012f014H
	DD	0c00ed010H
	DD	0500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmGetInstructionId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DB 06H
	DB	'-', 05H
	DB	02H
	DB	'R'
	DB	04H
	DB	'P'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DB 028H
	DD	imagerel $stateUnwindMap$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
	DD	imagerel $ip2state$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD 0a2319H
	DD	0193414H
	DD	0f010d214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAXQEAPEAU_VM_INSTRUCTION@@_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAPEAPEAU_VM_INSTRUCTION@@PEAPEAU3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEPEAE00@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_CODE_LINK@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_CODE_LINK@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_cast@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z DD 061b19H
	DD	0d340cH
	DD	07008520cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+81
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 060021H
	DD	0af400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN38
	DD	imagerel $LN38+81
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 061721H
	DD	0af417H
	DD	09540aH
	DD	083405H
	DD	imagerel $LN38
	DD	imagerel $LN38+81
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 040901H
	DD	0e0053209H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z DB 02H
	DB	'=', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z DB 060H
	DD	imagerel $ip2state$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z DD 060f19H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020021H
	DD	0d6400H
	DD	imagerel $LN77
	DD	imagerel $LN77+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	0d6405H
	DD	imagerel $LN77
	DD	imagerel $LN77+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 085001H
	DD	065450H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 083201H
	DD	066432H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 031a01H
	DD	07016621aH
	DD	03015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z PROC		; std::_Refancy<char const *,0>, COMDAT

; 262  :     return _Ptr;

  00000	48 8b c1	 mov	 rax, rcx

; 263  : }

  00003	c3		 ret	 0
??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z ENDP		; std::_Refancy<char const *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z PROC	; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00021	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 4120 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z ENDP	; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAU_VM_INSTRUCTION@@PEAPEAU1@@std@@YAPEAPEAU_VM_INSTRUCTION@@PEAPEAU1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAU_VM_INSTRUCTION@@PEAPEAU1@@std@@YAPEAPEAU_VM_INSTRUCTION@@PEAPEAU1@00@Z PROC ; std::_Copy_memmove<_VM_INSTRUCTION * *,_VM_INSTRUCTION * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00021	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 4120 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
??$_Copy_memmove@PEAPEAU_VM_INSTRUCTION@@PEAPEAU1@@std@@YAPEAPEAU_VM_INSTRUCTION@@PEAPEAU1@00@Z ENDP ; std::_Copy_memmove<_VM_INSTRUCTION * *,_VM_INSTRUCTION * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PEAU_VM_SYMBOL@@PEAU1@@std@@YAPEAU_VM_SYMBOL@@PEAU1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAU_VM_SYMBOL@@PEAU1@@std@@YAPEAU_VM_SYMBOL@@PEAU1@00@Z PROC ; std::_Copy_memmove<_VM_SYMBOL *,_VM_SYMBOL *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00021	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 4120 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
??$_Copy_memmove@PEAU_VM_SYMBOL@@PEAU1@@std@@YAPEAU_VM_SYMBOL@@PEAU1@00@Z ENDP ; std::_Copy_memmove<_VM_SYMBOL *,_VM_SYMBOL *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
$LN12:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 89   :             const auto _Rdbuf = _Myistr.rdbuf();

  00004	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00007	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  0000e	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream

; 90   :             if (_Rdbuf) {

  00013	48 85 c9	 test	 rcx, rcx
  00016	74 07		 je	 SHORT $LN9@sentry

; 91   :                 _Rdbuf->_Unlock();

  00018	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001b	ff 50 10	 call	 QWORD PTR [rax+16]
  0001e	90		 npad	 1
$LN9@sentry:
  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 88   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 89   :             const auto _Rdbuf = _Myistr.rdbuf();

  00004	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00007	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  0000e	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream

; 90   :             if (_Rdbuf) {

  00013	48 85 c9	 test	 rcx, rcx
  00016	74 07		 je	 SHORT $LN2@Sentry_bas

; 91   :                 _Rdbuf->_Unlock();

  00018	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001b	ff 50 10	 call	 QWORD PTR [rax+16]
  0001e	90		 npad	 1
$LN2@Sentry_bas:

; 92   :             }
; 93   :         }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$ = 88
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN6:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00008	49 8b f0	 mov	 rsi, r8
  0000b	48 8b fa	 mov	 rdi, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	4c 8b c2	 mov	 r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00011	48 8b d9	 mov	 rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00014	4c 2b c1	 sub	 r8, rcx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00017	48 8b d1	 mov	 rdx, rcx
  0001a	48 8b ce	 mov	 rcx, rsi
  0001d	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1656 :         return _Dest + (_ULast - _UFirst);

  00022	48 2b f3	 sub	 rsi, rbx
  00025	48 8d 04 37	 lea	 rax, QWORD PTR [rdi+rsi]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	5e		 pop	 rsi
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_move@PEAPEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z PROC ; std::_Uninitialized_move<_VM_INSTRUCTION * *,std::allocator<_VM_INSTRUCTION *> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN6:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1656 :         return _Dest + (_ULast - _UFirst);

  00021	48 c1 fb 03	 sar	 rbx, 3
  00025	48 8d 04 df	 lea	 rax, QWORD PTR [rdi+rbx*8]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00029	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
??$_Uninitialized_move@PEAPEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z ENDP ; std::_Uninitialized_move<_VM_INSTRUCTION * *,std::allocator<_VM_INSTRUCTION *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$ = 32
??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	49 8b c0	 mov	 rax, r8

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00003	48 3b ca	 cmp	 rcx, rdx
  00006	74 53		 je	 SHORT $LN82@Uninitiali

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00008	4c 8b c8	 mov	 r9, rax
  0000b	4c 8d 41 18	 lea	 r8, QWORD PTR [rcx+24]
  0000f	4c 2b c9	 sub	 r9, rcx
  00012	45 33 d2	 xor	 r10d, r10d
  00015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00020	4f 89 54 01 f8	 mov	 QWORD PTR [r9+r8-8], r10
  00025	4f 89 14 01	 mov	 QWORD PTR [r9+r8], r10

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00029	41 0f 10 40 e8	 movups	 xmm0, XMMWORD PTR [r8-24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  0002e	4d 8d 40 20	 lea	 r8, QWORD PTR [r8+32]

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00032	49 8d 48 e8	 lea	 rcx, QWORD PTR [r8-24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00036	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  00039	41 0f 10 48 d8	 movups	 xmm1, XMMWORD PTR [r8-40]
  0003e	0f 11 48 10	 movups	 XMMWORD PTR [rax+16], xmm1

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00042	4d 89 50 d8	 mov	 QWORD PTR [r8-40], r10
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00046	48 83 c0 20	 add	 rax, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0004a	49 c7 40 e0 0f
	00 00 00	 mov	 QWORD PTR [r8-32], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00052	45 88 50 c8	 mov	 BYTE PTR [r8-56], r10b
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00056	48 3b ca	 cmp	 rcx, rdx
  00059	75 c5		 jne	 SHORT $LL4@Uninitiali
$LN82@Uninitiali:

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  0005b	c3		 ret	 0
??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAU_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAPEAU_VM_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_move@PEAU_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAPEAU_VM_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z PROC ; std::_Uninitialized_move<_VM_SYMBOL *,std::allocator<_VM_SYMBOL> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN6:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1656 :         return _Dest + (_ULast - _UFirst);

  00021	48 b8 39 8e e3
	38 8e e3 38 0e	 mov	 rax, 1024819115206086201 ; 0e38e38e38e38e39H
  0002b	48 f7 eb	 imul	 rbx

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  0002e	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00033	48 d1 fa	 sar	 rdx, 1
  00036	48 8b c2	 mov	 rax, rdx
  00039	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0003d	48 03 d0	 add	 rdx, rax
  00040	48 8d 04 d2	 lea	 rax, QWORD PTR [rdx+rdx*8]
  00044	48 8d 04 87	 lea	 rax, QWORD PTR [rdi+rax*4]
  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
??$_Uninitialized_move@PEAU_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAPEAU_VM_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z ENDP ; std::_Uninitialized_move<_VM_SYMBOL *,std::allocator<_VM_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00004	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 116  :     if (_Block_size <= _Bytes) {

  00008	48 3b c1	 cmp	 rax, rcx
  0000b	76 28		 jbe	 SHORT $LN16@Allocate_m

; 77   :         return ::operator new(_Bytes);

  0000d	48 8b c8	 mov	 rcx, rax
  00010	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00015	48 8b c8	 mov	 rcx, rax

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00018	48 85 c0	 test	 rax, rax
  0001b	74 11		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0001d	48 83 c0 27	 add	 rax, 39			; 00000027H
  00021	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00025	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
$LN7@Allocate_m:

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00034	cc		 int	 3
$LN16@Allocate_m:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00035	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0003a	cc		 int	 3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z
_TEXT	SEGMENT
_UTarget$1$ = 0
_First$ = 64
_Last$ = 72
_RngFunc$ = 80
??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z PROC ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::_Rng_from_urng<__int64,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> > >, COMDAT

; 2832 : void _Random_shuffle1(_RanIt _First, _RanIt _Last, _RngFn& _RngFunc) {

$LN78:

; 2833 :     // shuffle [_First, _Last) using random function _RngFunc
; 2834 :     _Adl_verify_range(_First, _Last);
; 2835 :     auto _UFirst      = _Get_unwrapped(_First);
; 2836 :     const auto _ULast = _Get_unwrapped(_Last);
; 2837 :     if (_UFirst == _ULast) {

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	0f 84 b5 02 00
	00		 je	 $LN75@Random_shu
  00009	4c 8b dc	 mov	 r11, rsp
  0000c	41 56		 push	 r14
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2844 :     for (; ++_UTarget != _ULast; ++_Target_index) { // randomly place an element from [_First, _Target] at _Target

  00012	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  00016	4d 89 6b e0	 mov	 QWORD PTR [r11-32], r13
  0001a	48 89 04 24	 mov	 QWORD PTR _UTarget$1$[rsp], rax
  0001e	4d 8b f0	 mov	 r14, r8
  00021	4c 8b ca	 mov	 r9, rdx
  00024	4c 8b d1	 mov	 r10, rcx
  00027	41 bd 01 00 00
	00		 mov	 r13d, 1
  0002d	48 3b c2	 cmp	 rax, rdx
  00030	0f 84 7d 02 00
	00		 je	 $LN74@Random_shu
  00036	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  0003a	49 89 6b 10	 mov	 QWORD PTR [r11+16], rbp
  0003e	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  00042	49 89 7b f0	 mov	 QWORD PTR [r11-16], rdi
  00046	4d 89 63 e8	 mov	 QWORD PTR [r11-24], r12
  0004a	4d 89 7b d8	 mov	 QWORD PTR [r11-40], r15
  0004e	66 90		 npad	 2
$LL4@Random_shu:

; 2845 :         _Diff _Off = _RngFunc(static_cast<_Diff>(_Target_index + 1));

  00050	4d 8d 65 01	 lea	 r12, QWORD PTR [r13+1]
  00054	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL9@Random_shu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5752 :             _Udiff _Ret  = 0; // random bits

  00060	33 ed		 xor	 ebp, ebp

; 5753 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

  00062	45 33 ff	 xor	 r15d, r15d

; 5754 : 
; 5755 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

  00065	4d 85 ed	 test	 r13, r13
  00068	0f 84 d0 01 00
	00		 je	 $LN13@Random_shu
  0006e	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  00072	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL12@Random_shu:

; 5756 :                 _Ret <<= _Bits - 1; // avoid full shift

  00080	8d 8a ff 00 00
	00		 lea	 ecx, DWORD PTR [rdx+255]
  00086	48 d3 e5	 shl	 rbp, cl

; 5757 :                 _Ret <<= 1;

  00089	48 03 ed	 add	 rbp, rbp
  0008c	0f 1f 40 00	 npad	 4
$LL18@Random_shu:

; 5789 :             _Udiff _Val = _Ref() - (_Urng::min)();

  00090	49 8b 3e	 mov	 rdi, QWORD PTR [r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 1126 :         if (this->_Idx == _Nx) {

  00093	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00095	81 f9 70 02 00
	00		 cmp	 ecx, 624		; 00000270H
  0009b	75 56		 jne	 SHORT $LN24@Random_shu

; 1168 :         for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

  0009d	48 8d 47 08	 lea	 rax, QWORD PTR [rdi+8]
  000a1	44 8b d9	 mov	 r11d, ecx
  000a4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL31@Random_shu:

; 1169 :             _Ty _Tmp       = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  000b0	44 8b 40 fc	 mov	 r8d, DWORD PTR [rax-4]
  000b4	44 33 00	 xor	 r8d, DWORD PTR [rax]
  000b7	48 8d 40 04	 lea	 rax, QWORD PTR [rax+4]
  000bb	41 0f ba f0 1f	 btr	 r8d, 31
  000c0	44 33 40 f8	 xor	 r8d, DWORD PTR [rax-8]

; 1170 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

  000c4	41 8b c8	 mov	 ecx, r8d
  000c7	80 e1 01	 and	 cl, 1
  000ca	f6 d9		 neg	 cl
  000cc	1b d2		 sbb	 edx, edx
  000ce	41 d1 e8	 shr	 r8d, 1
  000d1	81 e2 df b0 08
	99		 and	 edx, -1727483681	; 9908b0dfH
  000d7	33 90 2c 06 00
	00		 xor	 edx, DWORD PTR [rax+1580]
  000dd	41 33 d0	 xor	 edx, r8d
  000e0	89 90 b8 09 00
	00		 mov	 DWORD PTR [rax+2488], edx
  000e6	49 83 eb 01	 sub	 r11, 1
  000ea	75 c4		 jne	 SHORT $LL31@Random_shu

; 1128 :         } else if (2 * _Nx <= this->_Idx) {

  000ec	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  000ee	e9 df 00 00 00	 jmp	 $LN26@Random_shu
$LN24@Random_shu:
  000f3	81 f9 e0 04 00
	00		 cmp	 ecx, 1248		; 000004e0H
  000f9	0f 82 d3 00 00
	00		 jb	 $LN26@Random_shu

; 1151 :         for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix) { // fill in lower region

  000ff	48 8d 9f c4 09
	00 00		 lea	 rbx, QWORD PTR [rdi+2500]
  00106	be e3 00 00 00	 mov	 esi, 227		; 000000e3H
  0010b	8b 03		 mov	 eax, DWORD PTR [rbx]
  0010d	0f 1f 00	 npad	 3
$LL36@Random_shu:

; 1152 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00110	8b d0		 mov	 edx, eax
  00112	4c 8d 43 04	 lea	 r8, QWORD PTR [rbx+4]
  00116	41 33 10	 xor	 edx, DWORD PTR [r8]
  00119	0f ba f2 1f	 btr	 edx, 31
  0011d	33 d0		 xor	 edx, eax

; 1153 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];

  0011f	8b c2		 mov	 eax, edx
  00121	24 01		 and	 al, 1
  00123	f6 d8		 neg	 al
  00125	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00128	1b c9		 sbb	 ecx, ecx
  0012a	d1 ea		 shr	 edx, 1
  0012c	81 e1 df b0 08
	99		 and	 ecx, -1727483681	; 9908b0dfH
  00132	33 8b 34 06 00
	00		 xor	 ecx, DWORD PTR [rbx+1588]
  00138	33 ca		 xor	 ecx, edx
  0013a	89 8b 40 f6 ff
	ff		 mov	 DWORD PTR [rbx-2496], ecx
  00140	49 8d 18	 lea	 rbx, QWORD PTR [r8]
  00143	48 83 ee 01	 sub	 rsi, 1
  00147	75 c7		 jne	 SHORT $LL36@Random_shu

; 1154 :         }
; 1155 : 
; 1156 :         for (; _Ix < _Nx - 1; ++_Ix) { // fill in upper region (avoids modulus operation)

  00149	48 8d 9f 50 0d
	00 00		 lea	 rbx, QWORD PTR [rdi+3408]
  00150	be 8c 01 00 00	 mov	 esi, 396		; 0000018cH
  00155	8b 03		 mov	 eax, DWORD PTR [rbx]
  00157	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL39@Random_shu:

; 1157 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00160	8b d0		 mov	 edx, eax
  00162	4c 8d 43 04	 lea	 r8, QWORD PTR [rbx+4]
  00166	41 33 10	 xor	 edx, DWORD PTR [r8]
  00169	0f ba f2 1f	 btr	 edx, 31
  0016d	33 d0		 xor	 edx, eax

; 1158 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

  0016f	8b c2		 mov	 eax, edx
  00171	24 01		 and	 al, 1
  00173	f6 d8		 neg	 al
  00175	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00178	1b c9		 sbb	 ecx, ecx
  0017a	d1 ea		 shr	 edx, 1
  0017c	81 e1 df b0 08
	99		 and	 ecx, -1727483681	; 9908b0dfH
  00182	33 8b b4 f2 ff
	ff		 xor	 ecx, DWORD PTR [rbx-3404]
  00188	33 ca		 xor	 ecx, edx
  0018a	89 8b 40 f6 ff
	ff		 mov	 DWORD PTR [rbx-2496], ecx
  00190	49 8d 18	 lea	 rbx, QWORD PTR [r8]
  00193	48 83 ee 01	 sub	 rsi, 1
  00197	75 c7		 jne	 SHORT $LL39@Random_shu

; 1159 :         }
; 1160 : 
; 1161 :         _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  00199	8b 97 80 13 00
	00		 mov	 edx, DWORD PTR [rdi+4992]
  0019f	33 57 04	 xor	 edx, DWORD PTR [rdi+4]
  001a2	0f ba f2 1f	 btr	 edx, 31
  001a6	33 97 80 13 00
	00		 xor	 edx, DWORD PTR [rdi+4992]

; 1162 :         this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];

  001ac	8b c2		 mov	 eax, edx
  001ae	24 01		 and	 al, 1
  001b0	f6 d8		 neg	 al
  001b2	1b c9		 sbb	 ecx, ecx
  001b4	d1 ea		 shr	 edx, 1
  001b6	81 e1 df b0 08
	99		 and	 ecx, -1727483681	; 9908b0dfH
  001bc	33 8f 34 06 00
	00		 xor	 ecx, DWORD PTR [rdi+1588]
  001c2	33 ca		 xor	 ecx, edx
  001c4	89 8f c0 09 00
	00		 mov	 DWORD PTR [rdi+2496], ecx

; 1163 :         this->_Idx     = 0;

  001ca	33 c9		 xor	 ecx, ecx
  001cc	c7 07 00 00 00
	00		 mov	 DWORD PTR [rdi], 0
$LN26@Random_shu:

; 1132 :         _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

  001d2	8b c1		 mov	 eax, ecx
  001d4	8b 54 87 04	 mov	 edx, DWORD PTR [rdi+rax*4+4]
  001d8	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  001db	89 07		 mov	 DWORD PTR [rdi], eax

; 1133 :         _Res ^= (_Res >> _Ux) & _Dxval;

  001dd	8b ca		 mov	 ecx, edx
  001df	8b 87 84 13 00
	00		 mov	 eax, DWORD PTR [rdi+4996]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5791 :             if (_Val <= _Bmask) {

  001e5	4d 8b 46 10	 mov	 r8, QWORD PTR [r14+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 1133 :         _Res ^= (_Res >> _Ux) & _Dxval;

  001e9	c1 e9 0b	 shr	 ecx, 11
  001ec	23 c1		 and	 eax, ecx
  001ee	33 d0		 xor	 edx, eax

; 1134 :         _Res ^= (_Res << _Sx) & _Bx;

  001f0	8b c2		 mov	 eax, edx
  001f2	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  001f7	c1 e0 07	 shl	 eax, 7
  001fa	33 d0		 xor	 edx, eax
  001fc	8b c2		 mov	 eax, edx

; 1135 :         _Res ^= (_Res << _Tx) & _Cx;

  001fe	81 e2 8c df ff
	ff		 and	 edx, -8308		; ffffdf8cH
  00204	c1 e2 0f	 shl	 edx, 15
  00207	8b ca		 mov	 ecx, edx
  00209	48 33 c8	 xor	 rcx, rax

; 1136 :         _Res ^= (_Res & _WMSK) >> _Lx;

  0020c	48 8b c1	 mov	 rax, rcx
  0020f	48 c1 e8 12	 shr	 rax, 18
  00213	48 33 c1	 xor	 rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5791 :             if (_Val <= _Bmask) {

  00216	49 3b c0	 cmp	 rax, r8
  00219	0f 87 71 fe ff
	ff		 ja	 $LL18@Random_shu

; 5758 :                 _Ret |= _Get_bits();

  0021f	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  00223	48 0b e8	 or	 rbp, rax

; 5759 :                 _Mask <<= _Bits - 1; // avoid full shift

  00226	8d 8a ff 00 00
	00		 lea	 ecx, DWORD PTR [rdx+255]
  0022c	49 d3 e7	 shl	 r15, cl

; 5760 :                 _Mask <<= 1;

  0022f	4d 03 ff	 add	 r15, r15

; 5761 :                 _Mask |= _Bmask;

  00232	4d 0b f8	 or	 r15, r8
  00235	4d 3b fd	 cmp	 r15, r13
  00238	0f 82 42 fe ff
	ff		 jb	 $LL12@Random_shu
$LN13@Random_shu:

; 5762 :             }
; 5763 : 
; 5764 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 5765 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

  0023e	33 d2		 xor	 edx, edx
  00240	49 8b c7	 mov	 rax, r15
  00243	49 f7 f4	 div	 r12
  00246	48 8b c8	 mov	 rcx, rax
  00249	4c 8b c2	 mov	 r8, rdx
  0024c	33 d2		 xor	 edx, edx
  0024e	48 8b c5	 mov	 rax, rbp
  00251	49 f7 f4	 div	 r12
  00254	48 3b c1	 cmp	 rax, rcx
  00257	72 09		 jb	 SHORT $LN54@Random_shu
  00259	4d 3b c5	 cmp	 r8, r13
  0025c	0f 85 fe fd ff
	ff		 jne	 $LL9@Random_shu
$LN54@Random_shu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2847 :         if (_Off != _Target_index) { // avoid self-move-assignment

  00262	4c 8b 04 24	 mov	 r8, QWORD PTR _UTarget$1$[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5766 :                 return static_cast<_Diff>(_Ret % _Index);

  00266	33 d2		 xor	 edx, edx
  00268	48 8b c5	 mov	 rax, rbp
  0026b	49 f7 f4	 div	 r12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2847 :         if (_Off != _Target_index) { // avoid self-move-assignment

  0026e	49 3b d5	 cmp	 rdx, r13
  00271	74 0e		 je	 SHORT $LN2@Random_shu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 107  :     _Left    = _STD move(_Right);

  00273	49 8b 04 d2	 mov	 rax, QWORD PTR [r10+rdx*8]
  00277	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  0027a	49 89 00	 mov	 QWORD PTR [r8], rax

; 108  :     _Right   = _STD move(_Tmp);

  0027d	49 89 0c d2	 mov	 QWORD PTR [r10+rdx*8], rcx
$LN2@Random_shu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2844 :     for (; ++_UTarget != _ULast; ++_Target_index) { // randomly place an element from [_First, _Target] at _Target

  00281	49 83 c0 08	 add	 r8, 8
  00285	4d 8b ec	 mov	 r13, r12
  00288	4c 89 04 24	 mov	 QWORD PTR _UTarget$1$[rsp], r8
  0028c	4d 3b c1	 cmp	 r8, r9
  0028f	0f 85 bb fd ff
	ff		 jne	 $LL4@Random_shu
  00295	4c 8b 7c 24 10	 mov	 r15, QWORD PTR [rsp+16]
  0029a	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]
  0029f	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
  002a4	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  002a9	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  002ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN74@Random_shu:
  002b3	4c 8b 6c 24 18	 mov	 r13, QWORD PTR [rsp+24]

; 2848 :             _STD iter_swap(_UTarget, _UFirst + _Off);
; 2849 :         }
; 2850 :     }
; 2851 : }

  002b8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002bc	41 5e		 pop	 r14
$LN75@Random_shu:
  002be	c3		 ret	 0
??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z ENDP ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::_Rng_from_urng<__int64,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 112
_Str$ = 120
_Delim$ = 128
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 29   :     const _Elem _Delim) { // get characters into string, discard delimiter

$LN83:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00017	45 0f b6 f8	 movzx	 r15d, r8b
  0001b	48 8b fa	 mov	 rdi, rdx
  0001e	48 8b f1	 mov	 rsi, rcx
  00021	48 89 4c 24 28	 mov	 QWORD PTR _Istr$GSCopy$[rsp], rcx

; 30   :     using _Myis = basic_istream<_Elem, _Traits>;
; 31   : 
; 32   :     typename _Myis::iostate _State = _Myis::goodbit;

  00026	33 db		 xor	 ebx, ebx
  00028	89 5c 24 24	 mov	 DWORD PTR _State$[rsp], ebx

; 33   :     bool _Changed                  = false;

  0002c	45 32 f6	 xor	 r14b, r14b
  0002f	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream

; 81   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

  00034	4c 8b e1	 mov	 r12, rcx
  00037	48 89 4c 24 30	 mov	 QWORD PTR _Ok$[rsp], rcx

; 82   :             const auto _Rdbuf = _Myistr.rdbuf();

  0003c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  00043	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream

; 83   :             if (_Rdbuf) {

  00048	48 85 c9	 test	 rcx, rcx
  0004b	74 07		 je	 SHORT $LN24@getline

; 84   :                 _Rdbuf->_Lock();

  0004d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00050	ff 50 08	 call	 QWORD PTR [rax+8]
  00053	90		 npad	 1
$LN24@getline:

; 103  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

  00054	b2 01		 mov	 dl, 1
  00056	48 8b ce	 mov	 rcx, rsi
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
  0005f	88 44 24 38	 mov	 BYTE PTR _Ok$[rsp+8], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string

; 36   :     if (_Ok) { // state okay, extract characters

  00063	84 c0		 test	 al, al
  00065	0f 84 e8 00 00
	00		 je	 $LN77@getline
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  0006b	48 8b c7	 mov	 rax, rdi

; 2136 :         if (_Large_string_engaged()) {

  0006e	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16
  00073	72 03		 jb	 SHORT $LN78@getline

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00075	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN78@getline:

; 4289 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00078	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx
  0007c	c6 00 00	 mov	 BYTE PTR [rax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string

; 40   :         typename _Traits::int_type _Meta            = _Istr.rdbuf()->sgetc();

  0007f	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00082	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00086	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  00091	8b d0		 mov	 edx, eax
  00093	49 bd ff ff ff
	ff ff ff ff 7f	 mov	 r13, 9223372036854775807 ; 7fffffffffffffffH
  0009d	0f 1f 00	 npad	 3
$LL4@getline:

; 43   :             if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  000a0	83 fa ff	 cmp	 edx, -1
  000a3	75 05		 jne	 SHORT $LN7@getline

; 44   :                 _State |= _Myis::eofbit;

  000a5	8d 5a 02	 lea	 ebx, QWORD PTR [rdx+2]

; 45   :                 break;

  000a8	eb 2f		 jmp	 SHORT $LN80@getline
$LN7@getline:

; 46   :             } else if (_Traits::eq_int_type(_Meta, _Metadelim)) { // got a delimiter, discard it and quit

  000aa	41 3b d7	 cmp	 edx, r15d
  000ad	75 1c		 jne	 SHORT $LN9@getline

; 47   :                 _Changed = true;

  000af	41 b6 01	 mov	 r14b, 1
  000b2	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b

; 48   :                 _Istr.rdbuf()->sbumpc();

  000b7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000ba	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000be	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ

; 49   :                 break;

  000c9	eb 12		 jmp	 SHORT $LN3@getline
$LN9@getline:

; 50   :             } else if (_Str.max_size() <= _Str.size()) { // string too large, quit

  000cb	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  000cf	49 3b cd	 cmp	 rcx, r13
  000d2	72 0b		 jb	 SHORT $LN11@getline

; 51   :                 _State |= _Myis::failbit;

  000d4	bb 02 00 00 00	 mov	 ebx, 2
$LN80@getline:

; 56   :             }
; 57   :         }

  000d9	89 5c 24 24	 mov	 DWORD PTR _State$[rsp], ebx
$LN3@getline:
  000dd	eb 6f		 jmp	 SHORT $LN18@getline
$LN11@getline:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 3609 :         if (_Old_size < _Mypair._Myval2._Myres) {

  000df	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  000e3	49 3b c8	 cmp	 rcx, r8
  000e6	73 1e		 jae	 SHORT $LN57@getline

; 3610 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000e8	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  000ec	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 2135 :         value_type* _Result = _Bx._Buf;

  000f0	48 8b c7	 mov	 rax, rdi

; 2136 :         if (_Large_string_engaged()) {

  000f3	49 83 f8 10	 cmp	 r8, 16
  000f7	72 03		 jb	 SHORT $LN60@getline

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  000f9	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN60@getline:

; 3612 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  000fc	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 3613 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  000ff	c6 44 08 01 00	 mov	 BYTE PTR [rax+rcx+1], 0

; 3614 :             return;

  00104	eb 13		 jmp	 SHORT $LN56@getline
$LN57@getline:

; 3615 :         }
; 3616 : 
; 3617 :         _Reallocate_grow_by(

  00106	44 0f b6 ca	 movzx	 r9d, dl
  0010a	45 33 c0	 xor	 r8d, r8d
  0010d	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00111	48 8b cf	 mov	 rcx, rdi
  00114	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN56@getline:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string

; 55   :                 _Changed = true;

  00119	41 b6 01	 mov	 r14b, 1
  0011c	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b

; 41   : 
; 42   :         for (;; _Meta = _Istr.rdbuf()->snextc()) {

  00121	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00124	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00128	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  00133	8b d0		 mov	 edx, eax
  00135	e9 66 ff ff ff	 jmp	 $LL4@getline
$LN19@getline:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
  0013a	8b 5c 24 24	 mov	 ebx, DWORD PTR _State$[rsp]
  0013e	44 0f b6 74 24
	20		 movzx	 r14d, BYTE PTR _Changed$[rsp]
  00144	4c 8b 64 24 30	 mov	 r12, QWORD PTR _Ok$[rsp]
  00149	48 8b 74 24 28	 mov	 rsi, QWORD PTR _Istr$GSCopy$[rsp]
$LN18@getline:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string

; 58   :         _CATCH_IO_(_Myis, _Istr)
; 59   :     }
; 60   : 
; 61   :     if (!_Changed) {

  0014e	45 84 f6	 test	 r14b, r14b
  00151	75 03		 jne	 SHORT $LN13@getline
$LN77@getline:

; 62   :         _State |= _Myis::failbit;

  00153	83 cb 02	 or	 ebx, 2
$LN13@getline:

; 63   :     }
; 64   : 
; 65   :     _Istr.setstate(_State);

  00156	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00159	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0015d	48 03 ce	 add	 rcx, rsi
  00160	45 33 c0	 xor	 r8d, r8d
  00163	8b d3		 mov	 edx, ebx
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0016b	90		 npad	 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream

; 89   :             const auto _Rdbuf = _Myistr.rdbuf();

  0016c	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00170	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  00174	4a 8b 4c 22 48	 mov	 rcx, QWORD PTR [rdx+r12+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream

; 90   :             if (_Rdbuf) {

  00179	48 85 c9	 test	 rcx, rcx
  0017c	74 07		 je	 SHORT $LN79@getline

; 91   :                 _Rdbuf->_Unlock();

  0017e	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00181	ff 52 10	 call	 QWORD PTR [rdx+16]
  00184	90		 npad	 1
$LN79@getline:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string

; 67   : }

  00185	48 8b c6	 mov	 rax, rsi
  00188	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  0018d	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  00191	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  00195	49 8b e3	 mov	 rsp, r11
  00198	41 5f		 pop	 r15
  0019a	41 5e		 pop	 r14
  0019c	41 5d		 pop	 r13
  0019e	41 5c		 pop	 r12
  001a0	5f		 pop	 rdi
  001a1	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 112
_Str$ = 120
_Delim$ = 128
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 112
_Str$ = 120
_Delim$ = 128
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 112
_Str$ = 120
_Delim$ = 128
?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$4

; 58   :         _CATCH_IO_(_Myis, _Istr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
  0000d	48 8b 55 28	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 112
_Str$ = 120
_Delim$ = 128
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 112
_Str$ = 120
_Delim$ = 128
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 112
_Str$ = 120
_Delim$ = 128
?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$4

; 58   :         _CATCH_IO_(_Myis, _Istr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
  0000d	48 8b 55 28	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT

; 2511 :         if (_Mypair._Myval2) {

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00003	48 85 c9	 test	 rcx, rcx
  00006	74 0b		 je	 SHORT $LN6@unique_ptr

; 2402 :         delete _Ptr;

  00008	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000b	ba 01 00 00 00	 mov	 edx, 1
  00010	48 ff 20	 rex_jmp QWORD PTR [rax]
$LN6@unique_ptr:

; 2512 :             _Mypair._Get_first()(_Mypair._Myval2);
; 2513 :         }
; 2514 :     }

  00013	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

$LN24:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00004	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0000b	72 31		 jb	 SHORT $LN2@Allocate

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0000d	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 116  :     if (_Block_size <= _Bytes) {

  00011	48 3b c1	 cmp	 rax, rcx
  00014	76 3d		 jbe	 SHORT $LN23@Allocate

; 77   :         return ::operator new(_Bytes);

  00016	48 8b c8	 mov	 rcx, rax
  00019	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001e	48 8b c8	 mov	 rcx, rax

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00021	48 85 c0	 test	 rax, rax
  00024	74 11		 je	 SHORT $LN11@Allocate

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00026	48 83 c0 27	 add	 rax, 39			; 00000027H
  0002a	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0002e	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 210  : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
$LN11@Allocate:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0003d	cc		 int	 3
$LN2@Allocate:

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  0003e	48 85 c9	 test	 rcx, rcx
  00041	74 09		 je	 SHORT $LN3@Allocate

; 210  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 77   :         return ::operator new(_Bytes);

  00047	e9 00 00 00 00	 jmp	 ??2@YAPEAX_K@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  0004c	33 c0		 xor	 eax, eax

; 210  : }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
$LN23@Allocate:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00053	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00058	cc		 int	 3
$LN21@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN51:

; 959  :         for (; _First != _Last; ++_First) {

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 78		 je	 SHORT $LN48@Destroy_ra
  00005	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00014	48 8b fa	 mov	 rdi, rdx
  00017	33 f6		 xor	 esi, esi
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	0f 1f 40 00	 npad	 4
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00020	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00024	48 83 fa 10	 cmp	 rdx, 16

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00028	72 2c		 jb	 SHORT $LN23@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0002d	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00030	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00037	72 18		 jb	 SHORT $LN33@Destroy_ra

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00039	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0003d	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00044	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00048	48 83 f8 1f	 cmp	 rax, 31
  0004c	77 30		 ja	 SHORT $LN30@Destroy_ra

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004e	49 8b c8	 mov	 rcx, r8
$LN33@Destroy_ra:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00051	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN23@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  00056	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0005a	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00062	40 88 33	 mov	 BYTE PTR [rbx], sil
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  00065	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00069	48 3b df	 cmp	 rbx, rdi
  0006c	75 b2		 jne	 SHORT $LL4@Destroy_ra

; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  0006e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00073	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5f		 pop	 rdi
$LN48@Destroy_ra:
  0007d	c3		 ret	 0
$LN30@Destroy_ra:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00084	cc		 int	 3
$LN47@Destroy_ra:
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN18:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00004	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0000b	72 18		 jb	 SHORT $LN13@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000d	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00011	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00015	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00018	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0001c	48 83 f8 1f	 cmp	 rax, 31
  00020	77 0c		 ja	 SHORT $LN10@Deallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00022	49 8b c8	 mov	 rcx, r8
$LN13@Deallocate:

; 222  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$LN10@Deallocate:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00034	cc		 int	 3
$LN15@Deallocate:
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAXPEAU_VM_SYMBOL@@QEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAXPEAU_VM_SYMBOL@@QEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z PROC ; std::_Destroy_range<std::allocator<_VM_SYMBOL> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@U_VM_SYMBOL@@@std@@@std@@YAXPEAU_VM_SYMBOL@@QEAU1@AEAV?$allocator@U_VM_SYMBOL@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<_VM_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00006	c3		 ret	 0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 879  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 880  :         _Left = _Right;
; 881  :     }
; 882  : }

  00000	c2 00 00	 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$ = 88
_Fn$ = 96
<_Args_0>$ = 104
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>, COMDAT

; 4244 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN71:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	41 57		 push	 r15
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4245 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4246 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4247 :         auto& _My_data            = _Mypair._Myval2;
; 4248 :         const size_type _Old_size = _My_data._Mysize;

  0000a	48 8b 69 10	 mov	 rbp, QWORD PTR [rcx+16]

; 4249 :         if (max_size() - _Old_size < _Size_increase) {

  0000e	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 8b c3	 mov	 rax, rbx
  0001b	45 0f b6 f9	 movzx	 r15d, r9b
  0001f	48 2b c5	 sub	 rax, rbp
  00022	48 8b f1	 mov	 rsi, rcx
  00025	48 3b c2	 cmp	 rax, rdx
  00028	0f 82 2a 01 00
	00		 jb	 $LN68@Reallocate

; 4251 :         }
; 4252 : 
; 4253 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002e	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00033	4c 8d 24 2a	 lea	 r12, QWORD PTR [rdx+rbp]

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00037	49 8b d4	 mov	 rdx, r12
  0003a	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 4254 :         const size_type _Old_capacity = _My_data._Myres;

  0003f	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00043	48 83 ca 0f	 or	 rdx, 15
  00047	48 3b d3	 cmp	 rdx, rbx

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0004a	77 1f		 ja	 SHORT $LN8@Reallocate

; 4203 :             return _Max;
; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0004c	49 8b ce	 mov	 rcx, r14
  0004f	48 8b c3	 mov	 rax, rbx
  00052	48 d1 e9	 shr	 rcx, 1
  00055	48 2b c1	 sub	 rax, rcx
  00058	4c 3b f0	 cmp	 r14, rax
  0005b	77 0e		 ja	 SHORT $LN8@Reallocate

; 4207 :             return _Max;
; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	4a 8d 04 31	 lea	 rax, QWORD PTR [rcx+r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00061	48 8b da	 mov	 rbx, rdx
  00064	48 3b d0	 cmp	 rdx, rax
  00067	48 0f 42 d8	 cmovb	 rbx, rax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4257 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00073	48 83 c1 01	 add	 rcx, 1
  00077	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0007e	48 0f 42 c8	 cmovb	 rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00082	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00089	72 28		 jb	 SHORT $LN17@Reallocate

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0008b	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 116  :     if (_Block_size <= _Bytes) {

  0008f	48 3b c1	 cmp	 rax, rcx
  00092	0f 86 ba 00 00
	00		 jbe	 $LN69@Reallocate

; 77   :         return ::operator new(_Bytes);

  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000a0	48 85 c0	 test	 rax, rax
  000a3	74 76		 je	 SHORT $LN53@Reallocate

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000a5	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000a9	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000ad	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000b1	eb 11		 jmp	 SHORT $LN16@Reallocate
$LN17@Reallocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  000b3	48 85 c9	 test	 rcx, rcx
  000b6	74 0a		 je	 SHORT $LN18@Reallocate

; 77   :         return ::operator new(_Bytes);

  000b8	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000bd	48 8b f8	 mov	 rdi, rax

; 206  :         return _Traits::_Allocate(_Bytes);

  000c0	eb 02		 jmp	 SHORT $LN16@Reallocate
$LN18@Reallocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  000c2	33 ff		 xor	 edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4259 :         _My_data._Mysize      = _New_size;

  000c4	4c 89 66 10	 mov	 QWORD PTR [rsi+16], r12

; 4260 :         _My_data._Myres       = _New_capacity;
; 4261 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4262 :         if (_BUF_SIZE <= _Old_capacity) {

  000c8	4c 8b c5	 mov	 r8, rbp
  000cb	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx
  000cf	48 8b cf	 mov	 rcx, rdi
  000d2	49 83 fe 10	 cmp	 r14, 16
  000d6	72 4a		 jb	 SHORT $LN3@Reallocate

; 4263 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000d8	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000db	48 8b d3	 mov	 rdx, rbx
  000de	e8 00 00 00 00	 call	 memcpy

; 4264 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4265 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e3	49 8d 56 01	 lea	 rdx, QWORD PTR [r14+1]

; 3621 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  000e7	44 88 3c 2f	 mov	 BYTE PTR [rdi+rbp], r15b

; 3622 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000eb	c6 44 2f 01 00	 mov	 BYTE PTR [rdi+rbp+1], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f0	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  000f7	72 18		 jb	 SHORT $LN56@Reallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f9	48 8b 4b f8	 mov	 rcx, QWORD PTR [rbx-8]
  000fd	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00101	48 2b d9	 sub	 rbx, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00104	48 8d 43 f8	 lea	 rax, QWORD PTR [rbx-8]
  00108	48 83 f8 1f	 cmp	 rax, 31
  0010c	77 0d		 ja	 SHORT $LN53@Reallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0010e	48 8b d9	 mov	 rbx, rcx
$LN56@Reallocate:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00111	48 8b cb	 mov	 rcx, rbx
  00114	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4267 :         } else {

  00119	eb 18		 jmp	 SHORT $LN4@Reallocate
$LN53@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00121	cc		 int	 3
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00122	48 8b d6	 mov	 rdx, rsi
  00125	e8 00 00 00 00	 call	 memcpy

; 3621 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0012a	44 88 3c 2f	 mov	 BYTE PTR [rdi+rbp], r15b

; 3622 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  0012e	c6 44 2f 01 00	 mov	 BYTE PTR [rdi+rbp+1], 0
$LN4@Reallocate:

; 4268 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4269 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4270 :         }
; 4271 : 
; 4272 :         return *this;

  00133	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  00136	48 8b c6	 mov	 rax, rsi
  00139	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  0013e	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00143	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]

; 4273 :     }

  00148	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0014c	41 5f		 pop	 r15
  0014e	5e		 pop	 rsi
  0014f	5d		 pop	 rbp
  00150	5b		 pop	 rbx
  00151	c3		 ret	 0
$LN69@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00152	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00157	cc		 int	 3
$LN68@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4250 :             _Xlen_string(); // result too long

  00158	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0015d	cc		 int	 3
$LN66@Reallocate:
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 268  :     _Obj.~_Ty();
; 269  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAXPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAXPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z PROC ; std::_Destroy_range<std::allocator<_VM_INSTRUCTION *> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAXPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<_VM_INSTRUCTION *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z PROC		; std::_Refancy<char *,0>, COMDAT

; 262  :     return _Ptr;

  00000	48 8b c1	 mov	 rax, rcx

; 263  : }

  00003	c3		 ret	 0
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z
_TEXT	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
<_Val_0>$ = 128
??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>, COMDAT

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN89:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00017	4d 8b e8	 mov	 r13, r8
  0001a	4c 8b e2	 mov	 r12, rdx
  0001d	48 8b f1	 mov	 rsi, rcx
  00020	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	4c 8b fa	 mov	 r15, rdx
  0002b	4c 2b f9	 sub	 r15, rcx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0002e	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00032	48 2b c1	 sub	 rax, rcx

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00035	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  0003f	48 3b c2	 cmp	 rax, rdx
  00042	0f 84 23 01 00
	00		 je	 $LN87@Emplace_re

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00048	4c 8d 70 01	 lea	 r14, QWORD PTR [rax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0004c	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  00050	48 2b c1	 sub	 rax, rcx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00053	48 8b c8	 mov	 rcx, rax
  00056	48 d1 e9	 shr	 rcx, 1
  00059	48 2b d1	 sub	 rdx, rcx
  0005c	48 3b c2	 cmp	 rax, rdx
  0005f	76 05		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00061	49 8b fe	 mov	 rdi, r14
  00064	eb 0b		 jmp	 SHORT $LN83@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00066	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0006a	49 3b fe	 cmp	 rdi, r14
  0006d	49 0f 42 fe	 cmovb	 rdi, r14
$LN83@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00071	48 89 7c 24 28	 mov	 QWORD PTR _Newcapacity$[rsp], rdi
  00076	48 81 ff 00 10
	00 00		 cmp	 rdi, 4096		; 00001000H
  0007d	72 29		 jb	 SHORT $LN20@Emplace_re

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0007f	48 8d 4f 27	 lea	 rcx, QWORD PTR [rdi+39]

; 116  :     if (_Block_size <= _Bytes) {

  00083	48 3b cf	 cmp	 rcx, rdi
  00086	0f 86 e5 00 00
	00		 jbe	 $LN88@Emplace_re

; 77   :         return ::operator new(_Bytes);

  0008c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00091	48 85 c0	 test	 rax, rax
  00094	0f 84 ca 00 00
	00		 je	 $LN75@Emplace_re

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0009a	48 8d 58 27	 lea	 rbx, QWORD PTR [rax+39]
  0009e	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000a2	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a6	eb 14		 jmp	 SHORT $LN84@Emplace_re
$LN20@Emplace_re:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  000a8	48 85 ff	 test	 rdi, rdi
  000ab	74 0d		 je	 SHORT $LN21@Emplace_re

; 77   :         return ::operator new(_Bytes);

  000ad	48 8b cf	 mov	 rcx, rdi
  000b0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000b5	48 8b d8	 mov	 rbx, rax

; 206  :         return _Traits::_Allocate(_Bytes);

  000b8	eb 02		 jmp	 SHORT $LN84@Emplace_re
$LN21@Emplace_re:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  000ba	33 db		 xor	 ebx, ebx
$LN84@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 748  :         _TRY_BEGIN

  000bc	48 89 5c 24 20	 mov	 QWORD PTR $T1[rsp], rbx

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000c1	4c 03 fb	 add	 r15, rbx
  000c4	41 0f b6 45 00	 movzx	 eax, BYTE PTR [r13]
  000c9	41 88 07	 mov	 BYTE PTR [r15], al

; 750  :         _Constructed_first = _Newvec + _Whereoff;
; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000cc	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]
  000d0	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000d3	48 8b cb	 mov	 rcx, rbx
  000d6	4d 3b e0	 cmp	 r12, r8
  000d9	75 05		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000db	4c 2b c2	 sub	 r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 754  :         } else { // provide basic guarantee

  000de	eb 19		 jmp	 SHORT $LN85@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000e0	4d 8b c4	 mov	 r8, r12
  000e3	4c 2b c2	 sub	 r8, rdx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000e6	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000eb	49 8d 4f 01	 lea	 rcx, QWORD PTR [r15+1]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000ef	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000f3	4d 2b c4	 sub	 r8, r12

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000f6	49 8b d4	 mov	 rdx, r12
$LN85@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000f9	e8 00 00 00 00	 call	 memmove
  000fe	90		 npad	 1

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000ff	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00102	48 85 c9	 test	 rcx, rcx
  00105	74 2d		 je	 SHORT $LN68@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00107	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  0010b	48 2b d1	 sub	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0010e	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00115	72 18		 jb	 SHORT $LN78@Emplace_re

; 134  :     _Bytes += _Non_user_size;

  00117	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0011b	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0011f	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00122	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00126	48 83 f8 1f	 cmp	 rax, 31
  0012a	77 38		 ja	 SHORT $LN75@Emplace_re

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0012c	49 8b c8	 mov	 rcx, r8
$LN78@Emplace_re:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0012f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN68@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1680 :         _Myfirst = _Newvec;

  00134	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00137	4a 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+r14]
  0013b	48 89 4e 08	 mov	 QWORD PTR [rsi+8], rcx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0013f	48 8d 0c 3b	 lea	 rcx, QWORD PTR [rbx+rdi]
  00143	48 89 4e 10	 mov	 QWORD PTR [rsi+16], rcx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  00147	49 8b c7	 mov	 rax, r15

; 767  :     }

  0014a	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  0014f	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  00153	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  00157	49 8b e3	 mov	 rsp, r11
  0015a	41 5f		 pop	 r15
  0015c	41 5e		 pop	 r14
  0015e	41 5d		 pop	 r13
  00160	41 5c		 pop	 r12
  00162	5f		 pop	 rdi
  00163	c3		 ret	 0
$LN75@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0016a	cc		 int	 3
$LN87@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 738  :             _Xlength();

  0016b	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
  00170	cc		 int	 3
$LN88@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00171	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00176	cc		 int	 3
$LN82@Emplace_re:
??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
<_Val_0>$ = 128
?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA PROC ; `std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>'::`1'::catch$0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 758  :         }
; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0000d	4c 8b 45 28	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00011	48 8b 55 20	 mov	 rdx, QWORD PTR $T1[rbp]
  00015	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;

  0001e	33 d2		 xor	 edx, edx
  00020	33 c9		 xor	 ecx, ecx
  00022	e8 00 00 00 00	 call	 _CxxThrowException
  00027	90		 npad	 1
?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA ENDP ; `std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
<_Val_0>$ = 128
?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA PROC ; `std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>'::`1'::catch$0

; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z$0:

; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0000d	4c 8b 45 28	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00011	48 8b 55 20	 mov	 rdx, QWORD PTR $T1[rbp]
  00015	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate

; 762  :         _RERAISE;

  0001e	33 d2		 xor	 edx, edx
  00020	33 c9		 xor	 ecx, ecx
  00022	e8 00 00 00 00	 call	 _CxxThrowException
  00027	90		 npad	 1
?catch$0@?0???$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z@4HA ENDP ; `std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z
_TEXT	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
<_Val_0>$ = 128
??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z PROC ; std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Emplace_reallocate<_VM_INSTRUCTION *>, COMDAT

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN92:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00017	4d 8b e8	 mov	 r13, r8
  0001a	4c 8b e2	 mov	 r12, rdx
  0001d	48 8b f9	 mov	 rdi, rcx
  00020	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00025	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00028	4d 8b fc	 mov	 r15, r12
  0002b	4c 2b fa	 sub	 r15, rdx
  0002e	49 c1 ff 03	 sar	 r15, 3

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00032	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00036	48 2b c2	 sub	 rax, rdx
  00039	48 c1 f8 03	 sar	 rax, 3

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0003d	49 b8 ff ff ff
	ff ff ff ff 1f	 mov	 r8, 2305843009213693951	; 1fffffffffffffffH
  00047	49 3b c0	 cmp	 rax, r8
  0004a	0f 84 45 01 00
	00		 je	 $LN91@Emplace_re

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00050	4c 8d 70 01	 lea	 r14, QWORD PTR [rax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00054	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00058	48 2b ca	 sub	 rcx, rdx
  0005b	48 c1 f9 03	 sar	 rcx, 3

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0005f	48 8b d1	 mov	 rdx, rcx
  00062	48 d1 ea	 shr	 rdx, 1
  00065	49 8b c0	 mov	 rax, r8
  00068	48 2b c2	 sub	 rax, rdx
  0006b	48 3b c8	 cmp	 rcx, rax
  0006e	76 05		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00070	49 8b c6	 mov	 rax, r14
  00073	eb 0b		 jmp	 SHORT $LN87@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00075	48 8d 04 0a	 lea	 rax, QWORD PTR [rdx+rcx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00079	49 3b c6	 cmp	 rax, r14
  0007c	49 0f 42 c6	 cmovb	 rax, r14
$LN87@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00080	48 89 44 24 28	 mov	 QWORD PTR _Newcapacity$[rsp], rax
  00085	49 3b c0	 cmp	 rax, r8
  00088	0f 87 01 01 00
	00		 ja	 $LN85@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0008e	48 8d 34 c5 00
	00 00 00	 lea	 rsi, QWORD PTR [rax*8]

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00096	48 81 fe 00 10
	00 00		 cmp	 rsi, 4096		; 00001000H
  0009d	72 29		 jb	 SHORT $LN24@Emplace_re

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0009f	48 8d 4e 27	 lea	 rcx, QWORD PTR [rsi+39]

; 116  :     if (_Block_size <= _Bytes) {

  000a3	48 3b ce	 cmp	 rcx, rsi
  000a6	0f 86 e3 00 00
	00		 jbe	 $LN85@Emplace_re

; 77   :         return ::operator new(_Bytes);

  000ac	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000b1	48 85 c0	 test	 rax, rax
  000b4	0f 84 ce 00 00
	00		 je	 $LN78@Emplace_re

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000ba	48 8d 58 27	 lea	 rbx, QWORD PTR [rax+39]
  000be	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000c2	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c6	eb 14		 jmp	 SHORT $LN88@Emplace_re
$LN24@Emplace_re:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  000c8	48 85 f6	 test	 rsi, rsi
  000cb	74 0d		 je	 SHORT $LN25@Emplace_re

; 77   :         return ::operator new(_Bytes);

  000cd	48 8b ce	 mov	 rcx, rsi
  000d0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d5	48 8b d8	 mov	 rbx, rax

; 206  :         return _Traits::_Allocate(_Bytes);

  000d8	eb 02		 jmp	 SHORT $LN88@Emplace_re
$LN25@Emplace_re:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  000da	33 db		 xor	 ebx, ebx
$LN88@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 748  :         _TRY_BEGIN

  000dc	48 89 5c 24 20	 mov	 QWORD PTR $T1[rsp], rbx

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000e1	4e 8d 3c fb	 lea	 r15, QWORD PTR [rbx+r15*8]
  000e5	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  000e9	49 89 07	 mov	 QWORD PTR [r15], rax

; 750  :         _Constructed_first = _Newvec + _Whereoff;
; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ec	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  000f0	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000f3	48 8b cb	 mov	 rcx, rbx
  000f6	4d 3b e0	 cmp	 r12, r8
  000f9	75 05		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000fb	4c 2b c2	 sub	 r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 754  :         } else { // provide basic guarantee

  000fe	eb 19		 jmp	 SHORT $LN89@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00100	4d 8b c4	 mov	 r8, r12
  00103	4c 2b c2	 sub	 r8, rdx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00106	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0010b	49 8d 4f 08	 lea	 rcx, QWORD PTR [r15+8]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0010f	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00113	4d 2b c4	 sub	 r8, r12

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00116	49 8b d4	 mov	 rdx, r12
$LN89@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00119	e8 00 00 00 00	 call	 memmove
  0011e	90		 npad	 1

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  0011f	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00122	48 85 c9	 test	 rcx, rcx
  00125	74 31		 je	 SHORT $LN71@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00127	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0012b	48 2b d1	 sub	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012e	48 83 e2 f8	 and	 rdx, -8

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00132	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00139	72 18		 jb	 SHORT $LN81@Emplace_re

; 134  :     _Bytes += _Non_user_size;

  0013b	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0013f	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00143	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00146	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0014a	48 83 f8 1f	 cmp	 rax, 31
  0014e	77 38		 ja	 SHORT $LN78@Emplace_re

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00150	49 8b c8	 mov	 rcx, r8
$LN81@Emplace_re:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00153	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN71@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1680 :         _Myfirst = _Newvec;

  00158	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0015b	4a 8d 0c f3	 lea	 rcx, QWORD PTR [rbx+r14*8]
  0015f	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00163	48 8d 0c 1e	 lea	 rcx, QWORD PTR [rsi+rbx]
  00167	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  0016b	49 8b c7	 mov	 rax, r15

; 767  :     }

  0016e	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  00173	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  00177	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0017b	49 8b e3	 mov	 rsp, r11
  0017e	41 5f		 pop	 r15
  00180	41 5e		 pop	 r14
  00182	41 5d		 pop	 r13
  00184	41 5c		 pop	 r12
  00186	5f		 pop	 rdi
  00187	c3		 ret	 0
$LN78@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0018e	cc		 int	 3
$LN85@Emplace_re:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  0018f	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00194	cc		 int	 3
$LN91@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 738  :             _Xlength();

  00195	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@CAXXZ ; std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Xlength
  0019a	cc		 int	 3
$LN86@Emplace_re:
??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z ENDP ; std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Emplace_reallocate<_VM_INSTRUCTION *>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
<_Val_0>$ = 128
?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA PROC ; `std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Emplace_reallocate<_VM_INSTRUCTION *>'::`1'::catch$0

; 758  :         }
; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0000d	4c 8b 45 28	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00011	48 8b 55 20	 mov	 rdx, QWORD PTR $T1[rbp]
  00015	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z ; std::allocator<_VM_INSTRUCTION *>::deallocate

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;

  0001e	33 d2		 xor	 edx, edx
  00020	33 c9		 xor	 ecx, ecx
  00022	e8 00 00 00 00	 call	 _CxxThrowException
  00027	90		 npad	 1
?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA ENDP ; `std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Emplace_reallocate<_VM_INSTRUCTION *>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
<_Val_0>$ = 128
?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA PROC ; `std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Emplace_reallocate<_VM_INSTRUCTION *>'::`1'::catch$0

; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z$0:

; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0000d	4c 8b 45 28	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00011	48 8b 55 20	 mov	 rdx, QWORD PTR $T1[rbp]
  00015	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z ; std::allocator<_VM_INSTRUCTION *>::deallocate

; 762  :         _RERAISE;

  0001e	33 d2		 xor	 edx, edx
  00020	33 c9		 xor	 ecx, ecx
  00022	e8 00 00 00 00	 call	 _CxxThrowException
  00027	90		 npad	 1
?catch$0@?0???$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z@4HA ENDP ; `std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Emplace_reallocate<_VM_INSTRUCTION *>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
_TEXT	SEGMENT
<_Val_0>$GSCopy$1$ = 32
_Constructed_first$ = 32
$T4 = 40
_Newcapacity$ = 48
_Constructed_last$ = 56
this$GSCopy$ = 64
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN328:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00010	4c 89 44 24 20	 mov	 QWORD PTR <_Val_0>$GSCopy$1$[rsp], r8
  00015	4c 8b f2	 mov	 r14, rdx
  00018	4c 8b f9	 mov	 r15, rcx
  0001b	48 89 4c 24 40	 mov	 QWORD PTR this$GSCopy$[rsp], rcx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00020	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00023	4c 8b ea	 mov	 r13, rdx
  00026	4c 2b e8	 sub	 r13, rax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00029	4c 8b 61 08	 mov	 r12, QWORD PTR [rcx+8]
  0002d	4c 2b e0	 sub	 r12, rax
  00030	49 c1 fc 05	 sar	 r12, 5

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00034	49 b9 ff ff ff
	ff ff ff ff 07	 mov	 r9, 576460752303423487	; 07ffffffffffffffH
  0003e	4d 3b e1	 cmp	 r12, r9
  00041	0f 84 2f 02 00
	00		 je	 $LN327@Emplace_re

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00047	49 ff c4	 inc	 r12

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0004a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0004e	48 2b c8	 sub	 rcx, rax
  00051	48 c1 f9 05	 sar	 rcx, 5

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00055	48 8b d1	 mov	 rdx, rcx
  00058	48 d1 ea	 shr	 rdx, 1
  0005b	49 8b c1	 mov	 rax, r9
  0005e	48 2b c2	 sub	 rax, rdx
  00061	48 3b c8	 cmp	 rcx, rax
  00064	76 05		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00066	49 8b f4	 mov	 rsi, r12
  00069	eb 0b		 jmp	 SHORT $LN324@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006b	48 8d 34 0a	 lea	 rsi, QWORD PTR [rdx+rcx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0006f	49 3b f4	 cmp	 rsi, r12
  00072	49 0f 42 f4	 cmovb	 rsi, r12
$LN324@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00076	48 89 74 24 30	 mov	 QWORD PTR _Newcapacity$[rsp], rsi
  0007b	49 3b f1	 cmp	 rsi, r9
  0007e	0f 87 ec 01 00
	00		 ja	 $LN321@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00084	48 c1 e6 05	 shl	 rsi, 5

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00088	48 81 fe 00 10
	00 00		 cmp	 rsi, 4096		; 00001000H
  0008f	72 30		 jb	 SHORT $LN24@Emplace_re

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00091	48 8d 4e 27	 lea	 rcx, QWORD PTR [rsi+39]

; 116  :     if (_Block_size <= _Bytes) {

  00095	48 3b ce	 cmp	 rcx, rsi
  00098	0f 86 d2 01 00
	00		 jbe	 $LN321@Emplace_re

; 77   :         return ::operator new(_Bytes);

  0009e	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 84 bd 01 00
	00		 je	 $LN290@Emplace_re

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000ac	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000b0	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000b4	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000b8	33 db		 xor	 ebx, ebx
  000ba	4c 8b 44 24 20	 mov	 r8, QWORD PTR <_Val_0>$GSCopy$1$[rsp]
  000bf	eb 1d		 jmp	 SHORT $LN325@Emplace_re
$LN24@Emplace_re:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  000c1	48 85 f6	 test	 rsi, rsi
  000c4	74 14		 je	 SHORT $LN25@Emplace_re

; 77   :         return ::operator new(_Bytes);

  000c6	48 8b ce	 mov	 rcx, rsi
  000c9	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000ce	48 8b f8	 mov	 rdi, rax

; 206  :         return _Traits::_Allocate(_Bytes);

  000d1	33 db		 xor	 ebx, ebx
  000d3	4c 8b 44 24 20	 mov	 r8, QWORD PTR <_Val_0>$GSCopy$1$[rsp]
  000d8	eb 04		 jmp	 SHORT $LN325@Emplace_re
$LN25@Emplace_re:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  000da	33 db		 xor	 ebx, ebx
  000dc	8b fb		 mov	 edi, ebx
$LN325@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000de	48 89 7c 24 28	 mov	 QWORD PTR $T4[rsp], rdi
  000e3	49 83 e5 e0	 and	 r13, -32		; ffffffffffffffe0H
  000e7	4c 03 ef	 add	 r13, rdi
  000ea	49 8d 45 20	 lea	 rax, QWORD PTR [r13+32]
  000ee	48 89 44 24 38	 mov	 QWORD PTR _Constructed_last$[rsp], rax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000f3	48 89 44 24 20	 mov	 QWORD PTR _Constructed_first$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  000f8	49 8b d0	 mov	 rdx, r8
  000fb	49 8b cd	 mov	 rcx, r13
  000fe	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00103	4c 89 6c 24 20	 mov	 QWORD PTR _Constructed_first$[rsp], r13

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00108	49 8b 57 08	 mov	 rdx, QWORD PTR [r15+8]
  0010c	49 8b 07	 mov	 rax, QWORD PTR [r15]
  0010f	4c 3b f2	 cmp	 r14, rdx
  00112	75 44		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00114	48 3b c2	 cmp	 rax, rdx
  00117	0f 84 db 00 00
	00		 je	 $LL203@Emplace_re

; 1510 :     }
; 1511 : 
; 1512 :     pointer _Release() { // suppress any exception handling backout and return _Last
; 1513 :         _First = _Last;
; 1514 :         return _Last;
; 1515 :     }
; 1516 : 
; 1517 : private:
; 1518 :     pointer _First;
; 1519 :     pointer _Last;
; 1520 :     _Alloc& _Al;
; 1521 : };
; 1522 : 
; 1523 : // FUNCTION TEMPLATE _Uninitialized_copy WITH ALLOCATOR
; 1524 : #if _HAS_IF_CONSTEXPR
; 1525 : template <class _InIt, class _Alloc>
; 1526 : _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
; 1527 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1528 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1529 :     // note: only called internally from elsewhere in the STL
; 1530 :     using _Ptrval = typename _Alloc::value_type*;
; 1531 : 
; 1532 :     auto _UFirst      = _Get_unwrapped(_First);
; 1533 :     const auto _ULast = _Get_unwrapped(_Last);
; 1534 : 
; 1535 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1536 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1537 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1538 :         _Dest += _ULast - _UFirst;
; 1539 :     } else {
; 1540 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1541 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1542 :             _Backout._Emplace_back(*_UFirst);
; 1543 :         }
; 1544 : 
; 1545 :         _Dest = _Backout._Release();
; 1546 :     }
; 1547 : 
; 1548 :     return _Dest;
; 1549 : }
; 1550 : #else // ^^^ _HAS_IF_CONSTEXPR ^^^ // vvv !_HAS_IF_CONSTEXPR vvv
; 1551 : template <class _InIt, class _Alloc>
; 1552 : _Alloc_ptr_t<_Alloc> _Uninitialized_copy_al_unchecked(
; 1553 :     _InIt _First, const _InIt _Last, const _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al, false_type) {
; 1554 :     // copy [_First, _Last) to raw _Dest, using _Al, no special optimization
; 1555 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1556 :     for (; _First != _Last; ++_First) {
; 1557 :         _Backout._Emplace_back(*_First);
; 1558 :     }
; 1559 : 
; 1560 :     return _Backout._Release();
; 1561 : }
; 1562 : 
; 1563 : template <class _InIt, class _Alloc>
; 1564 : _Alloc_ptr_t<_Alloc> _Uninitialized_copy_al_unchecked(
; 1565 :     const _InIt _First, const _InIt _Last, const _Alloc_ptr_t<_Alloc> _Dest, _Alloc&, true_type) {
; 1566 :     // copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization
; 1567 :     return _Copy_memmove(_First, _Last, _Unfancy(_Dest));
; 1568 : }
; 1569 : 
; 1570 : template <class _InIt, class _Alloc>
; 1571 : _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
; 1572 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1573 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1574 :     // note: only called internally from elsewhere in the STL
; 1575 : 
; 1576 :     // clang-format off
; 1577 :     auto _UFirst      = _Get_unwrapped(_First);
; 1578 :     const auto _ULast = _Get_unwrapped(_Last);
; 1579 :     // clang-format on
; 1580 : 
; 1581 :     using _Ptrval = typename _Alloc::value_type*;
; 1582 :     return _Uninitialized_copy_al_unchecked(_UFirst, _ULast, _Dest, _Al,
; 1583 :         bool_constant<conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1584 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>>{});
; 1585 : }
; 1586 : #endif // _HAS_IF_CONSTEXPR
; 1587 : 
; 1588 : // FUNCTION TEMPLATE uninitialized_copy
; 1589 : #if _HAS_IF_CONSTEXPR
; 1590 : template <class _InIt, class _NoThrowFwdIt>
; 1591 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1592 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1593 :     _Adl_verify_range(_First, _Last);
; 1594 :     auto _UFirst      = _Get_unwrapped(_First);
; 1595 :     const auto _ULast = _Get_unwrapped(_Last);
; 1596 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 1597 :     if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
; 1598 :         _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);
; 1599 :     } else {
; 1600 :         _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};
; 1601 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1602 :             _Backout._Emplace_back(*_UFirst);
; 1603 :         }
; 1604 : 
; 1605 :         _UDest = _Backout._Release();
; 1606 :     }
; 1607 : 
; 1608 :     _Seek_wrapped(_Dest, _UDest);
; 1609 :     return _Dest;
; 1610 : }
; 1611 : #else // ^^^ _HAS_IF_CONSTEXPR / !_HAS_IF_CONSTEXPR vvv
; 1612 : template <class _InIt, class _NoThrowFwdIt>
; 1613 : _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, const _NoThrowFwdIt _Dest, false_type) {
; 1614 :     // copy [_First, _Last) to raw [_Dest, ...), no special optimization
; 1615 :     _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
; 1616 :     for (; _First != _Last; ++_First) {
; 1617 :         _Backout._Emplace_back(*_First);
; 1618 :     }
; 1619 : 
; 1620 :     return _Backout._Release();
; 1621 : }
; 1622 : 
; 1623 : template <class _InIt, class _NoThrowFwdIt>
; 1624 : _NoThrowFwdIt _Uninitialized_copy_unchecked(
; 1625 :     const _InIt _First, const _InIt _Last, const _NoThrowFwdIt _Dest, true_type) {
; 1626 :     // copy [_First, _Last) to raw [_Dest, ...), memmove optimization
; 1627 :     return _Copy_memmove(_First, _Last, _Dest);
; 1628 : }
; 1629 : 
; 1630 : template <class _InIt, class _NoThrowFwdIt>
; 1631 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1632 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1633 :     _Adl_verify_range(_First, _Last);
; 1634 :     auto _UFirst = _Get_unwrapped(_First);
; 1635 :     const auto _ULast = _Get_unwrapped(_Last);
; 1636 :     auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 1637 :     _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest,
; 1638 :                              bool_constant<_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial>{}));
; 1639 :     return _Dest;
; 1640 : }
; 1641 : #endif // _HAS_IF_CONSTEXPR
; 1642 : 
; 1643 : // FUNCTION TEMPLATE _Uninitialized_move WITH ALLOCATOR
; 1644 : #if _HAS_IF_CONSTEXPR
; 1645 : template <class _InIt, class _Alloc>
; 1646 : _Alloc_ptr_t<_Alloc> _Uninitialized_move(
; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  0011d	48 8d 4f 18	 lea	 rcx, QWORD PTR [rdi+24]
$LL53@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00121	48 89 59 f8	 mov	 QWORD PTR [rcx-8], rbx
  00125	48 89 19	 mov	 QWORD PTR [rcx], rbx

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00128	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0012b	0f 11 41 e8	 movups	 XMMWORD PTR [rcx-24], xmm0
  0012f	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00133	0f 11 49 f8	 movups	 XMMWORD PTR [rcx-8], xmm1

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00137	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0013b	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00143	c6 00 00	 mov	 BYTE PTR [rax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00146	48 8d 49 20	 lea	 rcx, QWORD PTR [rcx+32]

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0014a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0014e	48 3b c2	 cmp	 rax, rdx
  00151	75 ce		 jne	 SHORT $LL53@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 754  :         } else { // provide basic guarantee

  00153	e9 a0 00 00 00	 jmp	 $LL203@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00158	49 3b c6	 cmp	 rax, r14
  0015b	74 3a		 je	 SHORT $LN128@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0015d	48 8d 4f 18	 lea	 rcx, QWORD PTR [rdi+24]
$LL129@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00161	48 89 59 f8	 mov	 QWORD PTR [rcx-8], rbx
  00165	48 89 19	 mov	 QWORD PTR [rcx], rbx

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00168	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0016b	0f 11 41 e8	 movups	 XMMWORD PTR [rcx-24], xmm0
  0016f	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00173	0f 11 49 f8	 movups	 XMMWORD PTR [rcx-8], xmm1

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00177	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0017b	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00183	c6 00 00	 mov	 BYTE PTR [rax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1509 :         ++_Last;

  00186	48 8d 49 20	 lea	 rcx, QWORD PTR [rcx+32]

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0018a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0018e	49 3b c6	 cmp	 rax, r14
  00191	75 ce		 jne	 SHORT $LL129@Emplace_re
  00193	49 8b 57 08	 mov	 rdx, QWORD PTR [r15+8]
$LN128@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 756  :             _Constructed_first = _Newvec;

  00197	48 89 7c 24 20	 mov	 QWORD PTR _Constructed_first$[rsp], rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0019c	4c 3b f2	 cmp	 r14, rdx
  0019f	74 57		 je	 SHORT $LL203@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 756  :             _Constructed_first = _Newvec;

  001a1	49 8d 4d 38	 lea	 rcx, QWORD PTR [r13+56]
  001a5	4d 2b f5	 sub	 r14, r13
  001a8	4d 8d 46 d8	 lea	 r8, QWORD PTR [r14-40]
  001ac	4d 8d 4e e0	 lea	 r9, QWORD PTR [r14-32]
  001b0	49 83 c6 c8	 add	 r14, -56		; ffffffffffffffc8H
  001b4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL204@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  001c0	48 89 59 f8	 mov	 QWORD PTR [rcx-8], rbx
  001c4	48 89 19	 mov	 QWORD PTR [rcx], rbx

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001c7	41 0f 10 04 0e	 movups	 xmm0, XMMWORD PTR [r14+rcx]
  001cc	0f 11 41 e8	 movups	 XMMWORD PTR [rcx-24], xmm0
  001d0	41 0f 10 4c 0e
	10		 movups	 xmm1, XMMWORD PTR [r14+rcx+16]
  001d6	0f 11 49 f8	 movups	 XMMWORD PTR [rcx-8], xmm1

; 4293 :         _Mypair._Myval2._Mysize = 0;

  001da	49 89 1c 08	 mov	 QWORD PTR [r8+rcx], rbx

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  001de	49 c7 04 09 0f
	00 00 00	 mov	 QWORD PTR [r9+rcx], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  001e6	41 c6 04 0e 00	 mov	 BYTE PTR [r14+rcx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  001eb	48 8d 49 20	 lea	 rcx, QWORD PTR [rcx+32]
  001ef	49 8d 04 0e	 lea	 rax, QWORD PTR [r14+rcx]
  001f3	48 3b c2	 cmp	 rax, rdx
  001f6	75 c8		 jne	 SHORT $LL204@Emplace_re
$LL203@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  001f8	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  001fb	48 85 c9	 test	 rcx, rcx
  001fe	74 40		 je	 SHORT $LN283@Emplace_re

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00200	4d 8b c7	 mov	 r8, r15
  00203	49 8b 57 08	 mov	 rdx, QWORD PTR [r15+8]
  00207	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0020c	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  0020f	49 8b 57 10	 mov	 rdx, QWORD PTR [r15+16]
  00213	48 2b d1	 sub	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00216	48 83 e2 e0	 and	 rdx, -32		; ffffffffffffffe0H

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0021a	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00221	72 18		 jb	 SHORT $LN293@Emplace_re

; 134  :     _Bytes += _Non_user_size;

  00223	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00227	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0022b	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0022e	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00232	48 83 f8 1f	 cmp	 rax, 31
  00236	77 31		 ja	 SHORT $LN290@Emplace_re

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00238	49 8b c8	 mov	 rcx, r8
$LN293@Emplace_re:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0023b	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN283@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1680 :         _Myfirst = _Newvec;

  00240	49 89 3f	 mov	 QWORD PTR [r15], rdi

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00243	49 c1 e4 05	 shl	 r12, 5
  00247	4c 03 e7	 add	 r12, rdi
  0024a	4d 89 67 08	 mov	 QWORD PTR [r15+8], r12

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0024e	48 8d 0c 3e	 lea	 rcx, QWORD PTR [rsi+rdi]
  00252	49 89 4f 10	 mov	 QWORD PTR [r15+16], rcx

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  00256	49 8b c5	 mov	 rax, r13

; 767  :     }

  00259	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0025d	41 5f		 pop	 r15
  0025f	41 5e		 pop	 r14
  00261	41 5d		 pop	 r13
  00263	41 5c		 pop	 r12
  00265	5f		 pop	 rdi
  00266	5e		 pop	 rsi
  00267	5b		 pop	 rbx
  00268	c3		 ret	 0
$LN290@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0026f	cc		 int	 3
$LN321@Emplace_re:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00270	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00275	cc		 int	 3
$LN327@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 738  :             _Xlength();

  00276	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
  0027b	cc		 int	 3
$LN323@Emplace_re:
??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
<_Val_0>$GSCopy$1$ = 32
_Constructed_first$ = 32
$T4 = 40
_Newcapacity$ = 48
_Constructed_last$ = 56
this$GSCopy$ = 64
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA PROC ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::catch$6

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
; 758  :         }
; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000b	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z$0:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0000e	4c 8b 45 38	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00012	48 8b 55 20	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00016	48 8b 4d 40	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0001f	4c 8b 45 30	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00023	48 8b 55 28	 mov	 rdx, QWORD PTR $T4[rbp]
  00027	48 8b 4d 40	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0002b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;

  00030	33 d2		 xor	 edx, edx
  00032	33 c9		 xor	 ecx, ecx
  00034	e8 00 00 00 00	 call	 _CxxThrowException
  00039	90		 npad	 1
?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA ENDP ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::catch$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<_Val_0>$GSCopy$1$ = 32
_Constructed_first$ = 32
$T4 = 40
_Newcapacity$ = 48
_Constructed_last$ = 56
this$GSCopy$ = 64
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA PROC ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::catch$6

; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000b	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z$0:

; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0000e	4c 8b 45 38	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00012	48 8b 55 20	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00016	48 8b 4d 40	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0001f	4c 8b 45 30	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00023	48 8b 55 28	 mov	 rdx, QWORD PTR $T4[rbp]
  00027	48 8b 4d 40	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0002b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 762  :         _RERAISE;

  00030	33 d2		 xor	 edx, edx
  00032	33 c9		 xor	 ecx, ecx
  00034	e8 00 00 00 00	 call	 _CxxThrowException
  00039	90		 npad	 1
?catch$6@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA ENDP ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::catch$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Psave$1 = 32
_Lock$2 = 40
_Psave_guard$3 = 48
__$ArrayPad$ = 56
_Loc$ = 80
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 426  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN41:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001e	48 8b f1	 mov	 rsi, rcx

; 427  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00021	33 d2		 xor	 edx, edx
  00023	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  0002e	90		 npad	 1

; 428  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  00036	48 89 44 24 20	 mov	 QWORD PTR _Psave$1[rsp], rax

; 429  : 
; 430  :     const size_t _Id         = _Facet::id;

  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
  00048	48 8b f8	 mov	 rdi, rax

; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0004b	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0004f	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  00053	73 0f		 jae	 SHORT $LN15@use_facet
  00055	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00059	48 8b 1c f9	 mov	 rbx, QWORD PTR [rcx+rdi*8]

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  0005d	48 85 db	 test	 rbx, rbx
  00060	75 67		 jne	 SHORT $LN32@use_facet
  00062	eb 02		 jmp	 SHORT $LN34@use_facet
$LN15@use_facet:

; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00064	33 db		 xor	 ebx, ebx
$LN34@use_facet:

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  00066	80 78 24 00	 cmp	 BYTE PTR [rax+36], 0
  0006a	74 13		 je	 SHORT $LN10@use_facet

; 376  :             return _Facptr; // found facet or not transparent
; 377  :         }
; 378  : 
; 379  :         // look in current locale
; 380  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  0006c	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 381  :         if (_Id < _Ptr0->_Facetcount) {

  00071	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  00075	73 0d		 jae	 SHORT $LN35@use_facet

; 382  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  00077	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007b	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
$LN10@use_facet:

; 431  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 432  : 
; 433  :     if (!_Pf) {

  0007f	48 85 db	 test	 rbx, rbx
  00082	75 45		 jne	 SHORT $LN32@use_facet
$LN35@use_facet:

; 434  :         if (_Psave) {

  00084	48 8b 5c 24 20	 mov	 rbx, QWORD PTR _Psave$1[rsp]
  00089	48 85 db	 test	 rbx, rbx
  0008c	75 3b		 jne	 SHORT $LN32@use_facet

; 435  :             _Pf = _Psave; // lazy facet already allocated
; 436  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  0008e	48 8b d6	 mov	 rdx, rsi
  00091	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Psave$1[rsp]
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
  0009c	48 83 f8 ff	 cmp	 rax, -1
  000a0	74 52		 je	 SHORT $LN39@use_facet

; 439  : #else // _HAS_EXCEPTIONS
; 440  :             _CSTD abort(); // lazy disallowed
; 441  : #endif // _HAS_EXCEPTIONS
; 442  :         } else { // queue up lazy facet for destruction
; 443  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  000a2	48 8b 5c 24 20	 mov	 rbx, QWORD PTR _Psave$1[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a7	48 89 5c 24 30	 mov	 QWORD PTR _Psave_guard$3[rsp], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale

; 449  :             _Facet_Register(_Pfmod);

  000ac	48 8b cb	 mov	 rcx, rbx
  000af	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 450  : #endif // defined(_M_CEE)
; 451  : 
; 452  :             _Pfmod->_Incref();

  000b4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	ff 50 08	 call	 QWORD PTR [rax+8]

; 453  :             _Facetptr<_Facet>::_Psave = _Psave;

  000bd	48 8b 5c 24 20	 mov	 rbx, QWORD PTR _Psave$1[rsp]
  000c2	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB, rbx ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
$LN32@use_facet:

; 454  :             _Pf                       = _Psave;
; 455  : 
; 456  :             (void) _Psave_guard.release();
; 457  :         }
; 458  :     }
; 459  : 
; 460  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  000c9	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000d4	48 8b c3	 mov	 rax, rbx

; 461  :     _END_LOCK()
; 462  : } // end of use_facet body

  000d7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000dc	48 33 cc	 xor	 rcx, rsp
  000df	e8 00 00 00 00	 call	 __security_check_cookie
  000e4	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000e9	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000ee	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f2	5f		 pop	 rdi
  000f3	c3		 ret	 0
$LN39@use_facet:

; 437  : #if _HAS_EXCEPTIONS
; 438  :             _Throw_bad_cast(); // lazy disallowed

  000f4	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
  000f9	90		 npad	 1
$LN36@use_facet:
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Psave$1 = 32
_Lock$2 = 40
_Psave_guard$3 = 48
__$ArrayPad$ = 56
_Loc$ = 80
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Lock$2[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Psave$1 = 32
_Lock$2 = 40
_Psave_guard$3 = 48
__$ArrayPad$ = 56
_Loc$ = 80
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Psave_guard$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Psave$1 = 32
_Lock$2 = 40
_Psave_guard$3 = 48
__$ArrayPad$ = 56
_Loc$ = 80
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Lock$2[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Psave$1 = 32
_Lock$2 = 40
_Psave_guard$3 = 48
__$ArrayPad$ = 56
_Loc$ = 80
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Psave_guard$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Unfancy_maybe_null@U_VM_SYMBOL@@@std@@YAPEAU_VM_SYMBOL@@PEAU1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@U_VM_SYMBOL@@@std@@YAPEAU_VM_SYMBOL@@PEAU1@@Z PROC ; std::_Unfancy_maybe_null<_VM_SYMBOL>, COMDAT

; 408  :     return _Ptr;

  00000	48 8b c1	 mov	 rax, rcx

; 409  : }

  00003	c3		 ret	 0
??$_Unfancy_maybe_null@U_VM_SYMBOL@@@std@@YAPEAU_VM_SYMBOL@@PEAU1@@Z ENDP ; std::_Unfancy_maybe_null<_VM_SYMBOL>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z
_TEXT	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z PROC ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Emplace_reallocate<>, COMDAT

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN94:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00017	4c 8b e2	 mov	 r12, rdx
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00022	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00025	49 2b d0	 sub	 rdx, r8
  00028	49 bd 39 8e e3
	38 8e e3 38 0e	 mov	 r13, 1024819115206086201 ; 0e38e38e38e38e39H
  00032	49 8b c5	 mov	 rax, r13
  00035	48 f7 ea	 imul	 rdx
  00038	4c 8b fa	 mov	 r15, rdx
  0003b	49 d1 ff	 sar	 r15, 1
  0003e	49 8b c7	 mov	 rax, r15
  00041	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00045	4c 03 f8	 add	 r15, rax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00048	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0004c	49 2b c8	 sub	 rcx, r8
  0004f	49 8b c5	 mov	 rax, r13
  00052	48 f7 e9	 imul	 rcx
  00055	48 d1 fa	 sar	 rdx, 1
  00058	48 8b c2	 mov	 rax, rdx
  0005b	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0005f	48 03 d0	 add	 rdx, rax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00062	49 b9 1c c7 71
	1c c7 71 1c 07	 mov	 r9, 512409557603043100	; 071c71c71c71c71cH
  0006c	49 3b d1	 cmp	 rdx, r9
  0006f	0f 84 85 01 00
	00		 je	 $LN93@Emplace_re

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00075	4c 8d 72 01	 lea	 r14, QWORD PTR [rdx+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00079	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0007d	49 2b c8	 sub	 rcx, r8
  00080	49 8b c5	 mov	 rax, r13
  00083	48 f7 e9	 imul	 rcx
  00086	48 d1 fa	 sar	 rdx, 1
  00089	48 8b c2	 mov	 rax, rdx
  0008c	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00090	48 03 d0	 add	 rdx, rax

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00093	48 8b ca	 mov	 rcx, rdx
  00096	48 d1 e9	 shr	 rcx, 1
  00099	49 8b c1	 mov	 rax, r9
  0009c	48 2b c1	 sub	 rax, rcx
  0009f	48 3b d0	 cmp	 rdx, rax
  000a2	76 05		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  000a4	49 8b c6	 mov	 rax, r14
  000a7	eb 0b		 jmp	 SHORT $LN89@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000a9	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  000ad	49 3b c6	 cmp	 rax, r14
  000b0	49 0f 42 c6	 cmovb	 rax, r14
$LN89@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  000b4	48 89 44 24 28	 mov	 QWORD PTR _Newcapacity$[rsp], rax
  000b9	49 3b c1	 cmp	 rax, r9
  000bc	0f 87 32 01 00
	00		 ja	 $LN87@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000c2	48 8d 04 c0	 lea	 rax, QWORD PTR [rax+rax*8]
  000c6	48 8d 34 85 00
	00 00 00	 lea	 rsi, QWORD PTR [rax*4]

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ce	48 81 fe 00 10
	00 00		 cmp	 rsi, 4096		; 00001000H
  000d5	72 29		 jb	 SHORT $LN24@Emplace_re

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000d7	48 8d 4e 27	 lea	 rcx, QWORD PTR [rsi+39]

; 116  :     if (_Block_size <= _Bytes) {

  000db	48 3b ce	 cmp	 rcx, rsi
  000de	0f 86 10 01 00
	00		 jbe	 $LN87@Emplace_re

; 77   :         return ::operator new(_Bytes);

  000e4	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000e9	48 85 c0	 test	 rax, rax
  000ec	0f 84 fb 00 00
	00		 je	 $LN80@Emplace_re

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000f2	48 8d 58 27	 lea	 rbx, QWORD PTR [rax+39]
  000f6	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000fa	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000fe	eb 14		 jmp	 SHORT $LN90@Emplace_re
$LN24@Emplace_re:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00100	48 85 f6	 test	 rsi, rsi
  00103	74 0d		 je	 SHORT $LN25@Emplace_re

; 77   :         return ::operator new(_Bytes);

  00105	48 8b ce	 mov	 rcx, rsi
  00108	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0010d	48 8b d8	 mov	 rbx, rax

; 206  :         return _Traits::_Allocate(_Bytes);

  00110	eb 02		 jmp	 SHORT $LN90@Emplace_re
$LN25@Emplace_re:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00112	33 db		 xor	 ebx, ebx
$LN90@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 748  :         _TRY_BEGIN

  00114	48 89 5c 24 20	 mov	 QWORD PTR $T1[rsp], rbx

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00119	4b 8d 04 ff	 lea	 rax, QWORD PTR [r15+r15*8]
  0011d	4c 8d 3c 83	 lea	 r15, QWORD PTR [rbx+rax*4]
  00121	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00124	33 c0		 xor	 eax, eax
  00126	41 0f 11 07	 movups	 XMMWORD PTR [r15], xmm0
  0012a	41 0f 11 47 10	 movups	 XMMWORD PTR [r15+16], xmm0
  0012f	41 89 47 20	 mov	 DWORD PTR [r15+32], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00133	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  00137	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0013a	48 8b cb	 mov	 rcx, rbx
  0013d	4d 3b e0	 cmp	 r12, r8
  00140	75 05		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00142	4c 2b c2	 sub	 r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 754  :         } else { // provide basic guarantee

  00145	eb 19		 jmp	 SHORT $LN91@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00147	4d 8b c4	 mov	 r8, r12
  0014a	4c 2b c2	 sub	 r8, rdx

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0014d	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00152	49 8d 4f 24	 lea	 rcx, QWORD PTR [r15+36]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00156	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0015a	4d 2b c4	 sub	 r8, r12

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0015d	49 8b d4	 mov	 rdx, r12
$LN91@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00160	e8 00 00 00 00	 call	 memmove
  00165	90		 npad	 1

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00166	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
  00169	4d 85 c0	 test	 r8, r8
  0016c	74 4b		 je	 SHORT $LN73@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0016e	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00172	49 2b c8	 sub	 rcx, r8
  00175	49 8b c5	 mov	 rax, r13
  00178	48 f7 e9	 imul	 rcx
  0017b	48 d1 fa	 sar	 rdx, 1
  0017e	48 8b c2	 mov	 rax, rdx
  00181	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00185	48 03 d0	 add	 rdx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00188	48 8d 14 d2	 lea	 rdx, QWORD PTR [rdx+rdx*8]
  0018c	48 c1 e2 02	 shl	 rdx, 2

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00190	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00197	72 18		 jb	 SHORT $LN83@Emplace_re

; 134  :     _Bytes += _Non_user_size;

  00199	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0019d	49 8b 48 f8	 mov	 rcx, QWORD PTR [r8-8]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001a1	4c 2b c1	 sub	 r8, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001a4	49 8d 40 f8	 lea	 rax, QWORD PTR [r8-8]
  001a8	48 83 f8 1f	 cmp	 rax, 31
  001ac	77 3f		 ja	 SHORT $LN80@Emplace_re

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001ae	4c 8b c1	 mov	 r8, rcx
$LN83@Emplace_re:

; 221  :     ::operator delete(_Ptr, _Bytes);

  001b1	49 8b c8	 mov	 rcx, r8
  001b4	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN73@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1680 :         _Myfirst = _Newvec;

  001b9	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  001bc	4b 8d 0c f6	 lea	 rcx, QWORD PTR [r14+r14*8]
  001c0	48 8d 14 8b	 lea	 rdx, QWORD PTR [rbx+rcx*4]
  001c4	48 89 57 08	 mov	 QWORD PTR [rdi+8], rdx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  001c8	48 8d 0c 1e	 lea	 rcx, QWORD PTR [rsi+rbx]
  001cc	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  001d0	49 8b c7	 mov	 rax, r15

; 767  :     }

  001d3	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  001d8	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  001dc	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  001e0	49 8b e3	 mov	 rsp, r11
  001e3	41 5f		 pop	 r15
  001e5	41 5e		 pop	 r14
  001e7	41 5d		 pop	 r13
  001e9	41 5c		 pop	 r12
  001eb	5f		 pop	 rdi
  001ec	c3		 ret	 0
$LN80@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001f3	cc		 int	 3
$LN87@Emplace_re:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  001f4	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  001f9	cc		 int	 3
$LN93@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 738  :             _Xlength();

  001fa	e8 00 00 00 00	 call	 ?_Xlength@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@CAXXZ ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Xlength
  001ff	cc		 int	 3
$LN88@Emplace_re:
??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z ENDP ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Emplace_reallocate<>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA PROC ; `std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Emplace_reallocate<>'::`1'::catch$0

; 758  :         }
; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0000d	4c 8b 45 28	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00011	48 8b 55 20	 mov	 rdx, QWORD PTR $T1[rbp]
  00015	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z ; std::allocator<_VM_SYMBOL>::deallocate

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;

  0001e	33 d2		 xor	 edx, edx
  00020	33 c9		 xor	 ecx, ecx
  00022	e8 00 00 00 00	 call	 _CxxThrowException
  00027	90		 npad	 1
?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA ENDP ; `std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Emplace_reallocate<>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newcapacity$ = 40
this$GSCopy$ = 48
this$ = 112
_Whereptr$ = 120
?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA PROC ; `std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Emplace_reallocate<>'::`1'::catch$0

; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z$0:

; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0000d	4c 8b 45 28	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00011	48 8b 55 20	 mov	 rdx, QWORD PTR $T1[rbp]
  00015	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z ; std::allocator<_VM_SYMBOL>::deallocate

; 762  :         _RERAISE;

  0001e	33 d2		 xor	 edx, edx
  00020	33 c9		 xor	 ecx, ecx
  00022	e8 00 00 00 00	 call	 _CxxThrowException
  00027	90		 npad	 1
?catch$0@?0???$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z@4HA ENDP ; `std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Emplace_reallocate<>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@CAXXZ PROC ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1704 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlength:
?_Xlength@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@CAXXZ ENDP ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ PROC ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::~vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >, COMDAT

; 672  :     ~vector() noexcept {

$LN28:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 5c		 je	 SHORT $LN4@vector

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00011	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00015	48 b8 39 8e e3
	38 8e e3 38 0e	 mov	 rax, 1024819115206086201 ; 0e38e38e38e38e39H
  0001f	48 2b d1	 sub	 rdx, rcx
  00022	48 f7 ea	 imul	 rdx
  00025	48 d1 fa	 sar	 rdx, 1
  00028	48 8b c2	 mov	 rax, rdx
  0002b	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0002f	48 03 d0	 add	 rdx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00032	48 8d 14 d2	 lea	 rdx, QWORD PTR [rdx+rdx*8]
  00036	48 c1 e2 02	 shl	 rdx, 2

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0003a	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00041	72 18		 jb	 SHORT $LN20@vector

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00043	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00047	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004b	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00052	48 83 f8 1f	 cmp	 rax, 31
  00056	77 1b		 ja	 SHORT $LN17@vector

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00058	49 8b c8	 mov	 rcx, r8
$LN20@vector:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0005b	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00060	33 c0		 xor	 eax, eax
  00062	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1698 :             _Mylast  = pointer();

  00065	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1699 :             _Myend   = pointer();

  00069	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN4@vector:

; 678  :     }

  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5b		 pop	 rbx
  00072	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00079	cc		 int	 3
$LN25@vector:
??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ ENDP ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::~vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z PROC ; std::allocator<_VM_SYMBOL>::deallocate, COMDAT

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c2	 mov	 rax, rdx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	4b 8d 14 c0	 lea	 rdx, QWORD PTR [r8+r8*8]
  0000b	48 c1 e2 02	 shl	 rdx, 2

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00016	72 18		 jb	 SHORT $LN15@deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00018	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  0001c	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00020	48 2b c1	 sub	 rax, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00023	48 83 c0 f8	 add	 rax, -8
  00027	48 83 f8 1f	 cmp	 rax, 31
  0002b	77 0f		 ja	 SHORT $LN12@deallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	48 8b c1	 mov	 rax, rcx
$LN15@deallocate:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	48 8b c8	 mov	 rcx, rax

; 804  :     }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 221  :     ::operator delete(_Ptr, _Bytes);

  00037	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@deallocate:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00042	cc		 int	 3
$LN18@deallocate:
?deallocate@?$allocator@U_VM_SYMBOL@@@std@@QEAAXQEAU_VM_SYMBOL@@_K@Z ENDP ; std::allocator<_VM_SYMBOL>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4470 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

$LN23:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2153 :         return _BUF_SIZE <= _Myres;

  00004	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00009	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]

; 2145 :         if (_Large_string_engaged()) {

  0000d	72 03		 jb	 SHORT $LN6@operator

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  0000f	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN6@operator:

; 2153 :         return _BUF_SIZE <= _Myres;

  00012	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00017	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2145 :         if (_Large_string_engaged()) {

  0001b	72 03		 jb	 SHORT $LN11@operator

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN11@operator:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00020	4c 3b c0	 cmp	 r8, rax
  00023	75 10		 jne	 SHORT $LN17@operator

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  00025	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN17@operator

; 4471 :     return _Left._Equal(_Right);

  0002e	b0 01		 mov	 al, 1

; 4472 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
$LN17@operator:

; 4471 :     return _Left._Equal(_Right);

  00035	32 c0		 xor	 al, al

; 4472 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z
_TEXT	SEGMENT
_RngFunc$ = 32
_First$ = 80
_Last$ = 88
_Func$ = 96
??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z PROC ; std::shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> &>, COMDAT

; 2854 : void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func) { // shuffle [_First, _Last) using URNG _Func

$LN13:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5744 :     explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {

  00004	4c 89 44 24 20	 mov	 QWORD PTR _RngFunc$[rsp], r8
  00009	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00010	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00016	41 b9 ff ff ff
	ff		 mov	 r9d, -1			; ffffffffH
  0001c	0f 1f 40 00	 npad	 4
$LL6@shuffle:

; 5746 :             --_Bits;

  00020	49 ff c8	 dec	 r8
  00023	48 d1 e8	 shr	 rax, 1
  00026	49 3b c1	 cmp	 rax, r9
  00029	77 f5		 ja	 SHORT $LL6@shuffle
  0002b	4c 89 44 24 28	 mov	 QWORD PTR _RngFunc$[rsp+8], r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  00030	4c 8d 44 24 20	 lea	 r8, QWORD PTR _RngFunc$[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5745 :         for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {

  00035	48 89 44 24 30	 mov	 QWORD PTR _RngFunc$[rsp+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  0003a	e8 00 00 00 00	 call	 ??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::_Rng_from_urng<__int64,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> > >

; 2858 : }

  0003f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00043	c3		 ret	 0
??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@0@@Z ENDP ; std::shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Istr$ = 48
_Str$ = 56
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 83   :     basic_string<_Elem, _Traits, _Alloc>& _Str) { // get characters into string, discard newline

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 84   :     return getline(_STD move(_Istr), _Str, _Istr.widen('\n'));

  0000a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 8b da	 mov	 rbx, rdx
  00013	b2 0a		 mov	 dl, 10
  00015	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00019	48 03 cf	 add	 rcx, rdi
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  00022	48 8b d3	 mov	 rdx, rbx
  00025	48 8b cf	 mov	 rcx, rdi
  00028	44 0f b6 c0	 movzx	 r8d, al

; 85   : }

  0002c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi

; 84   :     return getline(_STD move(_Istr), _Str, _Istr.widen('\n'));

  00036	e9 00 00 00 00	 jmp	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 944  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8d 99 b0 00
	00 00		 lea	 rbx, QWORD PTR [rcx+176]
  00010	48 8d 8b 60 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-160]
  00017	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00022	48 89 84 1a 50
	ff ff ff	 mov	 QWORD PTR [rdx+rbx-176], rax
  0002a	48 8b 83 50 ff
	ff ff		 mov	 rax, QWORD PTR [rbx-176]
  00031	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00035	44 8d 82 50 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-176]
  0003c	44 89 84 1a 4c
	ff ff ff	 mov	 DWORD PTR [rdx+rbx-180], r8d
  00044	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00049	48 8d 8b 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-152]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00056	48 8b cb	 mov	 rcx, rbx
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5b		 pop	 rbx
  0005e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d b9 50 ff
	ff ff		 lea	 rdi, QWORD PTR [rcx-176]
  00011	8b da		 mov	 ebx, edx
  00013	48 8b cf	 mov	 rcx, rdi
  00016	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	f6 c3 01	 test	 bl, 1
  0001e	74 0d		 je	 SHORT $LN4@scalar
  00020	ba 10 01 00 00	 mov	 edx, 272		; 00000110H
  00025	48 8b cf	 mov	 rcx, rdi
  00028	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 8b c7	 mov	 rax, rdi
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b da		 mov	 ebx, edx
  0000c	48 8b f9	 mov	 rdi, rcx
  0000f	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00014	f6 c3 01	 test	 bl, 1
  00017	74 0d		 je	 SHORT $LN4@scalar
  00019	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  0001e	48 8b cf	 mov	 rcx, rdi
  00021	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  00026	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002b	48 8b c7	 mov	 rax, rdi
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 181  :         return *_IGfirst;

  00000	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 774  :         if (_Mysb::eback() == &_Mychar) {

  00004	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
  00008	49 39 01	 cmp	 QWORD PTR [r9], rax
  0000b	75 22		 jne	 SHORT $LN2@Reset_back

; 775  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0000d	48 8b 91 88 00
	00 00		 mov	 rdx, QWORD PTR [rcx+136]
  00014	4c 8b 81 90 00
	00 00		 mov	 r8, QWORD PTR [rcx+144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 206  :         *_IGfirst = _First;

  0001b	49 89 11	 mov	 QWORD PTR [r9], rdx

; 207  :         *_IGnext  = _Next;
; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  0001e	44 2b c2	 sub	 r8d, edx
  00021	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00025	48 89 10	 mov	 QWORD PTR [rax], rdx
  00028	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  0002c	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN2@Reset_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 777  :     }

  0002f	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
_TEXT	SEGMENT
_Dest$ = 48
_Str$ = 56
__$ArrayPad$ = 88
this$ = 112
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 720  :     bool _Endwrite() { // put shift to initial conversion state, as needed

$LN19:
  00000	40 53		 push	 rbx
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 721  :         if (!_Pcvt || !_Wrotesome) {

  00015	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	0f 84 b0 00 00
	00		 je	 $LN5@Endwrite
  00023	80 79 71 00	 cmp	 BYTE PTR [rcx+113], 0
  00027	0f 84 a6 00 00
	00		 je	 $LN5@Endwrite

; 726  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  0002d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00030	ba ff ff ff ff	 mov	 edx, -1
  00035	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi
  0003a	ff 50 18	 call	 QWORD PTR [rax+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 393  :         return _Left == _Right;

  0003d	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 726  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00040	0f 84 89 00 00
	00		 je	 $LN15@Endwrite

; 727  :             return false;
; 728  :         }
; 729  : 
; 730  :         constexpr size_t _Codecvt_temp_buf = 32;
; 731  :         char _Str[_Codecvt_temp_buf];
; 732  :         char* _Dest;
; 733  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  00046	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0004a	48 8d 44 24 30	 lea	 rax, QWORD PTR _Dest$[rsp]
  0004f	48 8d 53 74	 lea	 rdx, QWORD PTR [rbx+116]
  00053	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00058	4c 8d 4c 24 58	 lea	 r9, QWORD PTR _Str$[rsp+32]
  0005d	4c 8d 44 24 38	 lea	 r8, QWORD PTR _Str$[rsp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z
  00068	85 c0		 test	 eax, eax
  0006a	74 28		 je	 SHORT $LN7@Endwrite
  0006c	83 e8 01	 sub	 eax, 1
  0006f	74 27		 je	 SHORT $LN8@Endwrite
  00071	83 f8 02	 cmp	 eax, 2
  00074	75 59		 jne	 SHORT $LN15@Endwrite

; 745  :         }
; 746  : 
; 747  :         case codecvt_base::noconv:
; 748  :             _Wrotesome = false; // homed successfully

  00076	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 749  :             return true; // nothing else to do

  0007a	b0 01		 mov	 al, 1
$LN16@Endwrite:
  0007c	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]

; 750  : 
; 751  :         default:
; 752  :             return false; // conversion failed
; 753  :         }
; 754  :     }

  00081	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00086	48 33 cc	 xor	 rcx, rsp
  00089	e8 00 00 00 00	 call	 __security_check_cookie
  0008e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00092	5b		 pop	 rbx
  00093	c3		 ret	 0
$LN7@Endwrite:

; 734  :         case codecvt_base::ok:
; 735  :             _Wrotesome = false; // homed successfully

  00094	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0
$LN8@Endwrite:

; 736  : 
; 737  :         case codecvt_base::partial: // fall through
; 738  :         { // put any generated bytes
; 739  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

  00098	48 8b 7c 24 30	 mov	 rdi, QWORD PTR _Dest$[rsp]
  0009d	48 8d 44 24 38	 lea	 rax, QWORD PTR _Str$[rsp]
  000a2	48 2b f8	 sub	 rdi, rax

; 740  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  000a5	74 1f		 je	 SHORT $LN9@Endwrite
  000a7	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  000ae	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Str$[rsp]
  000b3	4c 8b c7	 mov	 r8, rdi
  000b6	ba 01 00 00 00	 mov	 edx, 1
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  000c1	48 3b f8	 cmp	 rdi, rax
  000c4	75 09		 jne	 SHORT $LN15@Endwrite
$LN9@Endwrite:

; 742  :             }
; 743  : 
; 744  :             return !_Wrotesome;

  000c6	80 7b 71 00	 cmp	 BYTE PTR [rbx+113], 0
  000ca	0f 94 c0	 sete	 al
  000cd	eb ad		 jmp	 SHORT $LN16@Endwrite
$LN15@Endwrite:

; 741  :                 return false; // write failed

  000cf	32 c0		 xor	 al, al
  000d1	eb a9		 jmp	 SHORT $LN16@Endwrite
$LN5@Endwrite:

; 722  :             return true;

  000d3	b0 01		 mov	 al, 1

; 750  : 
; 751  :         default:
; 752  :             return false; // conversion failed
; 753  :         }
; 754  :     }

  000d5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000da	48 33 cc	 xor	 rcx, rsp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000e6	5b		 pop	 rbx
  000e7	c3		 ret	 0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 48
_Loc$ = 56
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT

; 688  :     virtual void __CLR_OR_THIS_CALL imbue(const locale& _Loc) override {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 689  :         // set locale to argument (capture nontrivial codecvt facet)
; 690  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >

; 757  :         if (_Newcvt.always_noconv()) {

  00015	48 8b c8	 mov	 rcx, rax

; 689  :         // set locale to argument (capture nontrivial codecvt facet)
; 690  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

  00018	48 8b f8	 mov	 rdi, rax

; 757  :         if (_Newcvt.always_noconv()) {

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00021	84 c0		 test	 al, al
  00023	74 13		 je	 SHORT $LN4@imbue

; 758  :             _Pcvt = nullptr; // nothing to do

  00025	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 691  :     }

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN4@imbue:

; 761  :             _Mysb::_Init(); // reset any buffering

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 691  :     }

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi

; 761  :             _Mysb::_Init(); // reset any buffering

  00049	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT

; 680  :     virtual int __CLR_OR_THIS_CALL sync() override { // synchronize C stream with external file

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 681  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00006	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 2c		 je	 SHORT $LN3@sync
  00013	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00016	ba ff ff ff ff	 mov	 edx, -1
  0001b	ff 50 18	 call	 QWORD PTR [rax+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 393  :         return _Left == _Right;

  0001e	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 681  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00021	74 1c		 je	 SHORT $LN3@sync
  00023	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
  00030	85 c0		 test	 eax, eax
  00032	79 0b		 jns	 SHORT $LN3@sync

; 683  :         }
; 684  : 
; 685  :         return -1;

  00034	b8 ff ff ff ff	 mov	 eax, -1

; 686  :     }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
$LN3@sync:

; 682  :             return 0;

  0003f	33 c0		 xor	 eax, eax

; 686  :     }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
_TEXT	SEGMENT
_Pb$1 = 32
_Pn$2 = 40
_Nr$3 = 48
__$ArrayPad$ = 56
this$ = 96
_Buffer$ = 104
_Count$ = 112
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT

; 661  :     virtual _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) override { // offer _Buffer to C stream

$LN19:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 662  :         int _Mode;
; 663  :         if (!_Buffer && _Count == 0) {

  00016	33 f6		 xor	 esi, esi
  00018	4d 8b c8	 mov	 r9, r8
  0001b	48 8b d9	 mov	 rbx, rcx
  0001e	48 85 d2	 test	 rdx, rdx
  00021	75 09		 jne	 SHORT $LN2@setbuf
  00023	4d 85 c0	 test	 r8, r8

; 664  :             _Mode = _IONBF;

  00026	44 8d 46 04	 lea	 r8d, QWORD PTR [rsi+4]
  0002a	74 03		 je	 SHORT $LN3@setbuf
$LN2@setbuf:

; 665  :         } else {
; 666  :             _Mode = _IOFBF;

  0002c	44 8b c6	 mov	 r8d, esi
$LN3@setbuf:

; 667  :         }
; 668  : 
; 669  :         const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);
; 670  : 
; 671  :         if (!_Myfile || _CSTD setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {

  0002f	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00036	48 85 c9	 test	 rcx, rcx
  00039	0f 84 9e 00 00
	00		 je	 $LN5@setbuf
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
  00045	85 c0		 test	 eax, eax
  00047	0f 85 90 00 00
	00		 jne	 $LN5@setbuf

; 673  :         }
; 674  : 
; 675  :         // new buffer, reinitialize pointers
; 676  :         _Init(_Myfile, _Openfl);

  0004d	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 701  :         _Mysb::_Init(); // initialize stream buffer base object

  00052	48 8b cb	 mov	 rcx, rbx

; 673  :         }
; 674  : 
; 675  :         // new buffer, reinitialize pointers
; 676  :         _Init(_Myfile, _Openfl);

  00055	48 8b bb 80 00
	00 00		 mov	 rdi, QWORD PTR [rbx+128]

; 698  :         _Closef    = _Which == _Openfl;

  0005c	c6 43 7c 01	 mov	 BYTE PTR [rbx+124], 1

; 699  :         _Wrotesome = false;

  00060	40 88 73 71	 mov	 BYTE PTR [rbx+113], sil

; 700  : 
; 701  :         _Mysb::_Init(); // initialize stream buffer base object

  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 702  : 
; 703  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  0006a	48 85 ff	 test	 rdi, rdi
  0006d	74 4e		 je	 SHORT $LN8@setbuf

; 704  :             _Elem** _Pb = nullptr;
; 705  :             _Elem** _Pn = nullptr;
; 706  :             int* _Nr    = nullptr;
; 707  : 
; 708  :             ::_get_stream_buffer_pointers(

  0006f	4c 8d 4c 24 30	 lea	 r9, QWORD PTR _Nr$3[rsp]
  00074	48 89 74 24 20	 mov	 QWORD PTR _Pb$1[rsp], rsi
  00079	4c 8d 44 24 28	 lea	 r8, QWORD PTR _Pn$2[rsp]
  0007e	48 89 74 24 28	 mov	 QWORD PTR _Pn$2[rsp], rsi
  00083	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Pb$1[rsp]
  00088	48 89 74 24 30	 mov	 QWORD PTR _Nr$3[rsp], rsi
  0008d	48 8b cf	 mov	 rcx, rdi
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 274  :         _IGfirst = _Gf;

  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Pb$1[rsp]
  0009b	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 275  :         _IPfirst = _Pf;

  0009f	48 89 4b 20	 mov	 QWORD PTR [rbx+32], rcx

; 276  :         _IGnext  = _Gn;

  000a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Pn$2[rsp]
  000a8	48 89 4b 38	 mov	 QWORD PTR [rbx+56], rcx

; 277  :         _IPnext  = _Pn;

  000ac	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx

; 278  :         _IGcount = _Gc;

  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Nr$3[rsp]
  000b5	48 89 4b 50	 mov	 QWORD PTR [rbx+80], rcx

; 279  :         _IPcount = _Pc;

  000b9	48 89 4b 58	 mov	 QWORD PTR [rbx+88], rcx
$LN8@setbuf:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 715  :         _Myfile = _File;

  000bd	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 677  :         return this;

  000c4	48 8b c3	 mov	 rax, rbx

; 716  :         _State  = _Stinit;

  000c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 677  :         return this;

  000ce	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 716  :         _State  = _Stinit;

  000d3	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 717  :         _Pcvt   = nullptr; // pointer to codecvt facet

  000d7	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi

; 677  :         return this;

  000db	eb 02		 jmp	 SHORT $LN1@setbuf
$LN5@setbuf:

; 672  :             return nullptr; // failed

  000dd	33 c0		 xor	 eax, eax
$LN1@setbuf:

; 678  :     }

  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e4	48 33 cc	 xor	 rcx, rsp
  000e7	e8 00 00 00 00	 call	 __security_check_cookie
  000ec	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f0	5e		 pop	 rsi
  000f1	5b		 pop	 rbx
  000f2	c3		 ret	 0
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Off$ = 32
__$ArrayPad$ = 40
this$ = 80
__$ReturnUdt$ = 88
_Pos$ = 96
__formal$ = 104
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT

; 648  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

$LN22:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000f	48 33 c4	 xor	 rax, rsp
  00012	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd

; 70   :         return _Myoff + _Fpos;

  00017	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 648  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

  0001b	49 8b f0	 mov	 rsi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd

; 70   :         return _Myoff + _Fpos;

  0001e	49 03 00	 add	 rax, QWORD PTR [r8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 648  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

  00021	48 8b da	 mov	 rbx, rdx

; 649  :         // change position to _Pos
; 650  :         off_type _Off = static_cast<off_type>(_Pos);
; 651  : 
; 652  :         if (!_Myfile || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

  00024	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0002c	48 8b f9	 mov	 rdi, rcx
  0002f	48 89 44 24 20	 mov	 QWORD PTR _Off$[rsp], rax
  00034	74 70		 je	 SHORT $LN3@seekpos
  00036	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0003b	84 c0		 test	 al, al
  0003d	74 67		 je	 SHORT $LN3@seekpos
  0003f	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  00046	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Off$[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fsetpos
  00051	85 c0		 test	 eax, eax
  00053	75 51		 jne	 SHORT $LN3@seekpos
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 181  :         return *_IGfirst;

  00055	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 774  :         if (_Mysb::eback() == &_Mychar) {

  00059	48 8d 47 70	 lea	 rax, QWORD PTR [rdi+112]

; 653  :             return pos_type(-1); // report failure
; 654  :         }
; 655  : 
; 656  :         _State = _Pos.state();

  0005d	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  00061	48 89 57 74	 mov	 QWORD PTR [rdi+116], rdx

; 774  :         if (_Mysb::eback() == &_Mychar) {

  00065	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00068	75 26		 jne	 SHORT $LN12@seekpos

; 775  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0006a	48 8b 97 88 00
	00 00		 mov	 rdx, QWORD PTR [rdi+136]
  00071	4c 8b 87 90 00
	00 00		 mov	 r8, QWORD PTR [rdi+144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 206  :         *_IGfirst = _First;

  00078	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 207  :         *_IGnext  = _Next;
; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  0007b	44 2b c2	 sub	 r8d, edx
  0007e	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00082	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00085	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  00089	44 89 01	 mov	 DWORD PTR [rcx], r8d
  0008c	48 8b 57 74	 mov	 rdx, QWORD PTR [rdi+116]
$LN12@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  00090	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Off$[rsp]
  00095	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00098	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
  000a0	48 89 53 10	 mov	 QWORD PTR [rbx+16], rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 658  :         return pos_type(_State, _Off); // return new position

  000a4	eb 15		 jmp	 SHORT $LN20@seekpos
$LN3@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  000a6	33 c0		 xor	 eax, eax
  000a8	48 c7 03 ff ff
	ff ff		 mov	 QWORD PTR [rbx], -1
  000af	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
  000b7	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN20@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 659  :     }

  000bb	48 8b c3	 mov	 rax, rbx
  000be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c3	48 33 cc	 xor	 rcx, rsp
  000c6	e8 00 00 00 00	 call	 __security_check_cookie
  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5f		 pop	 rdi
  000d0	5e		 pop	 rsi
  000d1	5b		 pop	 rbx
  000d2	c3		 ret	 0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Fileposition$ = 32
__$ArrayPad$ = 40
this$ = 96
__$ReturnUdt$ = 104
_Off$ = 112
_Way$ = 120
__formal$ = 128
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT

; 628  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

$LN16:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00018	48 8b da	 mov	 rbx, rdx

; 629  :         fpos_t _Fileposition;
; 630  : 
; 631  :         if (_Mysb::gptr() == &_Mychar // something putback
; 632  :             && _Way == ios_base::cur // a relative seek
; 633  :             && !_Pcvt) { // not converting

  0001b	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 185  :         return *_IGnext;

  0001f	48 8b 51 38	 mov	 rdx, QWORD PTR [rcx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 628  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

  00023	41 8b e9	 mov	 ebp, r9d
  00026	49 8b f0	 mov	 rsi, r8
  00029	48 8b f9	 mov	 rdi, rcx

; 629  :         fpos_t _Fileposition;
; 630  : 
; 631  :         if (_Mysb::gptr() == &_Mychar // something putback
; 632  :             && _Way == ios_base::cur // a relative seek
; 633  :             && !_Pcvt) { // not converting

  0002c	48 39 02	 cmp	 QWORD PTR [rdx], rax
  0002f	75 10		 jne	 SHORT $LN2@seekoff
  00031	41 83 f9 01	 cmp	 r9d, 1
  00035	75 0a		 jne	 SHORT $LN2@seekoff
  00037	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  0003c	75 03		 jne	 SHORT $LN2@seekoff

; 634  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

  0003e	48 ff ce	 dec	 rsi
$LN2@seekoff:

; 635  :         }
; 636  : 
; 637  :         if (!_Myfile || !_Endwrite()
; 638  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 639  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

  00041	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00049	74 62		 je	 SHORT $LN4@seekoff
  0004b	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00050	84 c0		 test	 al, al
  00052	74 59		 je	 SHORT $LN4@seekoff
  00054	48 85 f6	 test	 rsi, rsi
  00057	75 05		 jne	 SHORT $LN6@seekoff
  00059	83 fd 01	 cmp	 ebp, 1
  0005c	74 17		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  0005e	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  00065	44 8b c5	 mov	 r8d, ebp
  00068	48 8b d6	 mov	 rdx, rsi
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  00071	85 c0		 test	 eax, eax
  00073	75 38		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  00075	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0007c	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  00087	85 c0		 test	 eax, eax
  00089	75 22		 jne	 SHORT $LN4@seekoff

; 640  :             return pos_type(-1); // report failure
; 641  :         }
; 642  : 
; 643  :         _Reset_back(); // revert from _Mychar buffer, discarding any putback

  0008b	48 8b cf	 mov	 rcx, rdi
  0008e	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 644  :         return pos_type(_State, _Fileposition); // return new position

  00093	48 8b 4f 74	 mov	 rcx, QWORD PTR [rdi+116]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  00097	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Fileposition$[rsp]
  0009c	48 89 13	 mov	 QWORD PTR [rbx], rdx
  0009f	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
  000a3	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 644  :         return pos_type(_State, _Fileposition); // return new position

  000ab	eb 15		 jmp	 SHORT $LN14@seekoff
$LN4@seekoff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  000ad	33 c0		 xor	 eax, eax
  000af	48 c7 03 ff ff
	ff ff		 mov	 QWORD PTR [rbx], -1
  000b6	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
  000be	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN14@seekoff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 645  :     }

  000c2	48 8b c3	 mov	 rax, rbx
  000c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ca	48 33 cc	 xor	 rcx, rsp
  000cd	e8 00 00 00 00	 call	 __security_check_cookie
  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	5f		 pop	 rdi
  000d7	5e		 pop	 rsi
  000d8	5d		 pop	 rbp
  000d9	5b		 pop	 rbx
  000da	c3		 ret	 0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT

; 596  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) override {

$LN20:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 597  :         // put _Count characters to stream
; 598  :         if _CONSTEXPR_IF (sizeof(_Elem) == 1) {
; 599  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  00010	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  00015	49 8b d8	 mov	 rbx, r8
  00018	4c 8b f2	 mov	 r14, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	74 17		 je	 SHORT $LN2@xsputn

; 621  :         } else { // non-chars always get element-by-element processing
; 622  :             return _Mysb::xsputn(_Ptr, _Count);
; 623  :         }
; 624  :     }

  00020	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00025	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	41 5e		 pop	 r14

; 600  :                 return _Mysb::xsputn(_Ptr, _Count);

  00030	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
$LN2@xsputn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 258  :         return *_IPnext ? *_IPcount : 0;

  00037	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
  0003b	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00040	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 603  :             const streamsize _Start_count = _Count;

  00045	48 8b f3	 mov	 rsi, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 258  :         return *_IPnext ? *_IPcount : 0;

  00048	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  0004b	4d 85 c9	 test	 r9, r9
  0004e	74 08		 je	 SHORT $LN9@xsputn
  00050	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00054	8b 08		 mov	 ecx, DWORD PTR [rax]
  00056	eb 02		 jmp	 SHORT $LN10@xsputn
$LN9@xsputn:
  00058	33 c9		 xor	 ecx, ecx
$LN10@xsputn:
  0005a	48 63 e9	 movsxd	 rbp, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 605  :             if (0 < _Count && 0 < _Size) { // copy to write buffer

  0005d	48 85 db	 test	 rbx, rbx
  00060	7e 51		 jle	 SHORT $LN5@xsputn
  00062	85 c9		 test	 ecx, ecx
  00064	7e 2d		 jle	 SHORT $LN17@xsputn

; 606  :                 if (_Count < _Size) {

  00066	48 3b dd	 cmp	 rbx, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00069	49 8b c9	 mov	 rcx, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 606  :                 if (_Count < _Size) {

  0006c	48 0f 4c eb	 cmovl	 rbp, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00070	4c 8b c5	 mov	 r8, rbp
  00073	e8 00 00 00 00	 call	 memcpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 235  :         *_IPcount -= _Off;

  00078	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 612  :                 _Count -= _Size;

  0007c	48 2b dd	 sub	 rbx, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 236  :         *_IPnext += _Off;

  0007f	4c 03 f5	 add	 r14, rbp
  00082	29 28		 sub	 DWORD PTR [rax], ebp
  00084	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00088	48 63 c5	 movsxd	 rax, ebp
  0008b	48 01 01	 add	 QWORD PTR [rcx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 616  :             if (0 < _Count && _Myfile) { // open C stream, attempt write

  0008e	48 85 db	 test	 rbx, rbx
  00091	7e 20		 jle	 SHORT $LN5@xsputn
$LN17@xsputn:
  00093	4c 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [rdi+128]
  0009a	4d 85 c9	 test	 r9, r9
  0009d	74 14		 je	 SHORT $LN5@xsputn

; 617  :                 _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

  0009f	4c 8b c3	 mov	 r8, rbx
  000a2	ba 01 00 00 00	 mov	 edx, 1
  000a7	49 8b ce	 mov	 rcx, r14
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  000b0	48 2b d8	 sub	 rbx, rax
$LN5@xsputn:

; 618  :             }
; 619  : 
; 620  :             return _Start_count - _Count;

  000b3	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000b8	48 2b f3	 sub	 rsi, rbx

; 621  :         } else { // non-chars always get element-by-element processing
; 622  :             return _Mysb::xsputn(_Ptr, _Count);
; 623  :         }
; 624  :     }

  000bb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c0	48 8b c6	 mov	 rax, rsi
  000c3	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c8	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000cd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d1	41 5e		 pop	 r14
  000d3	c3		 ret	 0
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT

; 548  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) override {

$LN39:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 56		 push	 r14
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	49 8b e8	 mov	 rbp, r8
  0000c	4c 8b f2	 mov	 r14, rdx
  0000f	48 8b f1	 mov	 rsi, rcx

; 549  :         // get _Count characters from stream
; 550  :         if _CONSTEXPR_IF (sizeof(_Elem) == 1) {
; 551  :             if (_Count <= 0) {

  00012	4d 85 c0	 test	 r8, r8
  00015	7f 0b		 jg	 SHORT $LN4@xsgetn

; 552  :                 return 0;

  00017	33 c0		 xor	 eax, eax

; 591  :         } else { // non-chars always get element-by-element processing
; 592  :             return _Mysb::xsgetn(_Ptr, _Count);
; 593  :         }
; 594  :     }

  00019	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001d	41 5e		 pop	 r14
  0001f	5e		 pop	 rsi
  00020	5d		 pop	 rbp
  00021	c3		 ret	 0
$LN4@xsgetn:

; 553  :             }
; 554  : 
; 555  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  00022	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  00027	74 0f		 je	 SHORT $LN5@xsgetn

; 591  :         } else { // non-chars always get element-by-element processing
; 592  :             return _Mysb::xsgetn(_Ptr, _Count);
; 593  :         }
; 594  :     }

  00029	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002d	41 5e		 pop	 r14
  0002f	5e		 pop	 rsi
  00030	5d		 pop	 rbp

; 556  :                 return _Mysb::xsgetn(_Ptr, _Count);

  00031	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
$LN5@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 231  :         return *_IGnext ? *_IGcount : 0;

  00038	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0003c	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 560  :             auto _Count_s           = static_cast<size_t>(_Count);

  00041	48 8b fd	 mov	 rdi, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 231  :         return *_IGnext ? *_IGcount : 0;

  00044	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00047	48 85 d2	 test	 rdx, rdx
  0004a	74 08		 je	 SHORT $LN13@xsgetn
  0004c	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  00050	8b 08		 mov	 ecx, DWORD PTR [rax]
  00052	eb 02		 jmp	 SHORT $LN14@xsgetn
$LN13@xsgetn:
  00054	33 c9		 xor	 ecx, ecx
$LN14@xsgetn:
  00056	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 562  :             const auto _Available   = static_cast<size_t>(_Mysb::_Gnavail());

  0005b	48 63 c1	 movsxd	 rax, ecx
  0005e	85 c9		 test	 ecx, ecx

; 563  :             if (0 < _Available) { // copy from get area

  00060	74 2e		 je	 SHORT $LN6@xsgetn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 69   :     return _Right < _Left ? _Right : _Left;

  00062	48 3b c5	 cmp	 rax, rbp
  00065	48 8b dd	 mov	 rbx, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00068	49 8b ce	 mov	 rcx, r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 69   :     return _Right < _Left ? _Right : _Left;

  0006b	48 0f 42 d8	 cmovb	 rbx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0006f	4c 8b c3	 mov	 r8, rbx
  00072	e8 00 00 00 00	 call	 memcpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 201  :         *_IGcount -= _Off;

  00077	48 8b 46 50	 mov	 rax, QWORD PTR [rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 567  :                 _Count_s -= _Read_size;

  0007b	48 2b fb	 sub	 rdi, rbx
  0007e	4c 03 f3	 add	 r14, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 202  :         *_IGnext += _Off;

  00081	4c 8b c7	 mov	 r8, rdi
  00084	29 18		 sub	 DWORD PTR [rax], ebx
  00086	48 8b 4e 38	 mov	 rcx, QWORD PTR [rsi+56]
  0008a	48 63 c3	 movsxd	 rax, ebx
  0008d	48 01 01	 add	 QWORD PTR [rcx], rax
$LN6@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 571  :             if (_Myfile) { // open C stream, attempt read

  00090	48 83 be 80 00
	00 00 00	 cmp	 QWORD PTR [rsi+128], 0
  00098	0f 84 99 00 00
	00		 je	 $LN9@xsgetn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 181  :         return *_IGfirst;

  0009e	4c 8b 4e 18	 mov	 r9, QWORD PTR [rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 774  :         if (_Mysb::eback() == &_Mychar) {

  000a2	48 8d 46 70	 lea	 rax, QWORD PTR [rsi+112]
  000a6	49 39 01	 cmp	 QWORD PTR [r9], rax
  000a9	75 20		 jne	 SHORT $LN24@xsgetn

; 775  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  000ab	48 8b 8e 88 00
	00 00		 mov	 rcx, QWORD PTR [rsi+136]
  000b2	48 8b 96 90 00
	00 00		 mov	 rdx, QWORD PTR [rsi+144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 206  :         *_IGfirst = _First;

  000b9	49 89 09	 mov	 QWORD PTR [r9], rcx

; 207  :         *_IGnext  = _Next;
; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  000bc	2b d1		 sub	 edx, ecx
  000be	48 8b 46 38	 mov	 rax, QWORD PTR [rsi+56]
  000c2	48 89 08	 mov	 QWORD PTR [rax], rcx
  000c5	48 8b 46 50	 mov	 rax, QWORD PTR [rsi+80]
  000c9	89 10		 mov	 DWORD PTR [rax], edx
$LN24@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 576  :                 while (_Read_size < _Count_s) {

  000cb	49 8b d8	 mov	 rbx, r8
  000ce	49 81 f8 ff 0f
	00 00		 cmp	 r8, 4095		; 00000fffH
  000d5	76 3a		 jbe	 SHORT $LN3@xsgetn
  000d7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@xsgetn:

; 577  :                     const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);

  000e0	4c 8b 8e 80 00
	00 00		 mov	 r9, QWORD PTR [rsi+128]
  000e7	ba 01 00 00 00	 mov	 edx, 1
  000ec	41 b8 ff 0f 00
	00		 mov	 r8d, 4095		; 00000fffH
  000f2	49 8b ce	 mov	 rcx, r14
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 578  :                     _Ptr += _Actual_read;
; 579  :                     _Count_s -= _Actual_read;

  000fb	48 2b f8	 sub	 rdi, rax
  000fe	4c 03 f0	 add	 r14, rax
  00101	48 8b df	 mov	 rbx, rdi

; 580  :                     if (_Actual_read != _Read_size) {

  00104	48 3d ff 0f 00
	00		 cmp	 rax, 4095		; 00000fffH
  0010a	75 44		 jne	 SHORT $LN31@xsgetn

; 576  :                 while (_Read_size < _Count_s) {

  0010c	48 3b f8	 cmp	 rdi, rax
  0010f	77 cf		 ja	 SHORT $LL2@xsgetn
$LN3@xsgetn:

; 582  :                     }
; 583  :                 }
; 584  : 
; 585  :                 if (0 < _Count_s) {

  00111	4c 8b c3	 mov	 r8, rbx
  00114	48 85 db	 test	 rbx, rbx
  00117	74 1e		 je	 SHORT $LN9@xsgetn

; 586  :                     _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);

  00119	4c 8b 8e 80 00
	00 00		 mov	 r9, QWORD PTR [rsi+128]
  00120	4c 8b c7	 mov	 r8, rdi
  00123	ba 01 00 00 00	 mov	 edx, 1
  00128	49 8b ce	 mov	 rcx, r14
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00131	4c 8b c3	 mov	 r8, rbx
  00134	4c 2b c0	 sub	 r8, rax
$LN9@xsgetn:

; 587  :                 }
; 588  :             }
; 589  : 
; 590  :             return static_cast<streamsize>(_Start_count - _Count_s);

  00137	49 2b e8	 sub	 rbp, r8
$LN36@xsgetn:
  0013a	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  0013f	48 8b c5	 mov	 rax, rbp
  00142	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 591  :         } else { // non-chars always get element-by-element processing
; 592  :             return _Mysb::xsgetn(_Ptr, _Count);
; 593  :         }
; 594  :     }

  00147	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014b	41 5e		 pop	 r14
  0014d	5e		 pop	 rsi
  0014e	5d		 pop	 rbp
  0014f	c3		 ret	 0
$LN31@xsgetn:

; 581  :                         return static_cast<streamsize>(_Start_count - _Count_s);

  00150	48 2b ef	 sub	 rbp, rdi
  00153	eb e5		 jmp	 SHORT $LN36@xsgetn
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
_Src$1 = 64
_Dest$2 = 72
_Ch$3 = 80
_Str$ = 88
__$ArrayPad$ = 120
this$ = 144
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT

; 490  :     virtual int_type __CLR_OR_THIS_CALL uflow() override { // get an element from stream, point past it

$LN276:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000a	55		 push	 rbp
  0000b	48 8b ec	 mov	 rbp, rsp
  0000e	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 45 f8	 mov	 QWORD PTR __$ArrayPad$[rbp-128], rax
  00023	48 8b f9	 mov	 rdi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 185  :         return *_IGnext;

  00026	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0002a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0002d	48 85 c9	 test	 rcx, rcx
  00030	74 2c		 je	 SHORT $LN268@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 197  :         return *_IGnext + *_IGcount;

  00032	48 8b 57 50	 mov	 rdx, QWORD PTR [rdi+80]
  00036	4c 63 02	 movsxd	 r8, DWORD PTR [rdx]
  00039	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0003d	48 3b c8	 cmp	 rcx, rax
  00040	73 1c		 jae	 SHORT $LN268@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 221  :         --*_IGcount;

  00042	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00046	89 02		 mov	 DWORD PTR [rdx], eax

; 222  :         return (*_IGnext)++;

  00048	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0004c	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0004f	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00053	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 389  :         return static_cast<unsigned char>(_Ch);

  00056	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 492  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

  00059	e9 50 02 00 00	 jmp	 $LN232@uflow
$LN268@uflow:

; 493  :         }
; 494  : 
; 495  :         if (!_Myfile) {

  0005e	48 83 bf 80 00
	00 00 00	 cmp	 QWORD PTR [rdi+128], 0
  00066	75 0a		 jne	 SHORT $LN10@uflow

; 496  :             return _Traits::eof(); // no open C stream, fail

  00068	b8 ff ff ff ff	 mov	 eax, -1
  0006d	e9 3c 02 00 00	 jmp	 $LN232@uflow
$LN10@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 181  :         return *_IGfirst;

  00072	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 774  :         if (_Mysb::eback() == &_Mychar) {

  00076	48 8d 47 70	 lea	 rax, QWORD PTR [rdi+112]
  0007a	49 39 00	 cmp	 QWORD PTR [r8], rax
  0007d	75 20		 jne	 SHORT $LN35@uflow

; 775  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0007f	48 8b 97 90 00
	00 00		 mov	 rdx, QWORD PTR [rdi+144]
  00086	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 206  :         *_IGfirst = _First;

  0008d	49 89 08	 mov	 QWORD PTR [r8], rcx

; 207  :         *_IGnext  = _Next;

  00090	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00094	48 89 08	 mov	 QWORD PTR [rax], rcx

; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  00097	2b d1		 sub	 edx, ecx
  00099	48 8b 47 50	 mov	 rax, QWORD PTR [rdi+80]
  0009d	89 10		 mov	 DWORD PTR [rax], edx
$LN35@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 500  :         if (!_Pcvt) { // no codecvt facet, just get it

  0009f	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  000a6	48 83 7f 68 00	 cmp	 QWORD PTR [rdi+104], 0
  000ab	75 1c		 jne	 SHORT $LN11@uflow

; 67   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  000b3	83 f8 ff	 cmp	 eax, -1

; 502  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  000b6	bb ff ff ff ff	 mov	 ebx, -1

; 67   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

  000bb	0f 84 eb 01 00
	00		 je	 $LN212@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 389  :         return static_cast<unsigned char>(_Ch);

  000c1	0f b6 d8	 movzx	 ebx, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 502  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  000c4	e9 e3 01 00 00	 jmp	 $LN212@uflow
$LN11@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  000c9	48 c7 45 e8 00
	00 00 00	 mov	 QWORD PTR _Str$[rbp-112], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  000d1	48 c7 45 f0 0f
	00 00 00	 mov	 QWORD PTR _Str$[rbp-104], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  000d9	c6 45 d8 00	 mov	 BYTE PTR _Str$[rbp-128], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 510  :             int _Meta = _CSTD fgetc(_Myfile);

  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  000e3	44 8b c0	 mov	 r8d, eax

; 511  : 
; 512  :             if (_Meta == EOF) {

  000e6	83 f8 ff	 cmp	 eax, -1
  000e9	0f 84 0c 01 00
	00		 je	 $LN256@uflow
  000ef	90		 npad	 1
$LL2@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 3608 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000f0	48 8b 4d e8	 mov	 rcx, QWORD PTR _Str$[rbp-112]
  000f4	48 8b 55 f0	 mov	 rdx, QWORD PTR _Str$[rbp-104]
  000f8	48 3b ca	 cmp	 rcx, rdx

; 3609 :         if (_Old_size < _Mypair._Myval2._Myres) {

  000fb	73 20		 jae	 SHORT $LN85@uflow

; 3610 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000fd	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00101	48 89 45 e8	 mov	 QWORD PTR _Str$[rbp-112], rax

; 2135 :         value_type* _Result = _Bx._Buf;

  00105	48 8d 45 d8	 lea	 rax, QWORD PTR _Str$[rbp-128]

; 2136 :         if (_Large_string_engaged()) {

  00109	48 83 fa 10	 cmp	 rdx, 16
  0010d	48 0f 43 45 d8	 cmovae	 rax, QWORD PTR _Str$[rbp-128]

; 3612 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00112	44 88 04 08	 mov	 BYTE PTR [rax+rcx], r8b

; 3613 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00116	c6 44 08 01 00	 mov	 BYTE PTR [rax+rcx+1], 0

; 3614 :             return;

  0011b	eb 14		 jmp	 SHORT $LN84@uflow
$LN85@uflow:

; 3615 :         }
; 3616 : 
; 3617 :         _Reallocate_grow_by(

  0011d	45 0f b6 c8	 movzx	 r9d, r8b
  00121	45 33 c0	 xor	 r8d, r8d
  00124	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00128	48 8d 4d d8	 lea	 rcx, QWORD PTR _Str$[rbp-128]
  0012c	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN84@uflow:

; 2135 :         value_type* _Result = _Bx._Buf;

  00131	48 8d 4d d8	 lea	 rcx, QWORD PTR _Str$[rbp-128]

; 2136 :         if (_Large_string_engaged()) {

  00135	48 83 7d f0 10	 cmp	 QWORD PTR _Str$[rbp-104], 16
  0013a	48 0f 43 4d d8	 cmovae	 rcx, QWORD PTR _Str$[rbp-128]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  0013f	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$[rbp-112]
  00143	4c 03 c9	 add	 r9, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  00146	4c 8d 45 d8	 lea	 r8, QWORD PTR _Str$[rbp-128]

; 2136 :         if (_Large_string_engaged()) {

  0014a	48 83 7d f0 10	 cmp	 QWORD PTR _Str$[rbp-104], 16
  0014f	4c 0f 43 45 d8	 cmovae	 r8, QWORD PTR _Str$[rbp-128]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  00154	48 8d 45 c8	 lea	 rax, QWORD PTR _Dest$2[rbp-128]
  00158	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0015d	48 8d 45 d1	 lea	 rax, QWORD PTR _Ch$3[rbp-127]
  00161	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00166	48 8d 45 d0	 lea	 rax, QWORD PTR _Ch$3[rbp-128]
  0016a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016f	48 8d 45 c0	 lea	 rax, QWORD PTR _Src$1[rbp-128]
  00173	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00178	48 8d 57 74	 lea	 rdx, QWORD PTR [rdi+116]
  0017c	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  00186	85 c0		 test	 eax, eax
  00188	78 71		 js	 SHORT $LN256@uflow
  0018a	83 f8 01	 cmp	 eax, 1
  0018d	0f 8f f5 00 00
	00		 jg	 $LN257@uflow

; 521  :                 _Dest)) { // test result of converting one element
; 522  :             case codecvt_base::partial:
; 523  :             case codecvt_base::ok:
; 524  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

  00193	48 8d 45 d0	 lea	 rax, QWORD PTR _Ch$3[rbp-128]
  00197	48 39 45 c8	 cmp	 QWORD PTR _Dest$2[rbp-128], rax
  0019b	48 8d 45 d8	 lea	 rax, QWORD PTR _Str$[rbp-128]
  0019f	0f 85 9c 00 00
	00		 jne	 $LN258@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2136 :         if (_Large_string_engaged()) {

  001a5	48 83 7d f0 10	 cmp	 QWORD PTR _Str$[rbp-104], 16
  001aa	48 0f 43 45 d8	 cmovae	 rax, QWORD PTR _Str$[rbp-128]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 533  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

  001af	4c 8b 55 c0	 mov	 r10, QWORD PTR _Src$1[rbp-128]
  001b3	4c 2b d0	 sub	 r10, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2174 :         return (_STD min)(_Size, _Mysize - _Off);

  001b6	4c 8b 45 e8	 mov	 r8, QWORD PTR _Str$[rbp-112]
  001ba	4d 3b c2	 cmp	 r8, r10
  001bd	4d 0f 42 d0	 cmovb	 r10, r8

; 2135 :         value_type* _Result = _Bx._Buf;

  001c1	48 8d 4d d8	 lea	 rcx, QWORD PTR _Str$[rbp-128]

; 2136 :         if (_Large_string_engaged()) {

  001c5	48 83 7d f0 10	 cmp	 QWORD PTR _Str$[rbp-104], 16
  001ca	48 0f 43 4d d8	 cmovae	 rcx, QWORD PTR _Str$[rbp-128]

; 3221 :         const size_type _New_size = _Old_size - _Count;

  001cf	4d 2b c2	 sub	 r8, r10

; 3222 :         _Mypair._Myval2._Mysize   = _New_size;

  001d2	4c 89 45 e8	 mov	 QWORD PTR _Str$[rbp-112], r8

; 3223 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  001d6	49 ff c0	 inc	 r8
  001d9	4a 8d 14 11	 lea	 rdx, QWORD PTR [rcx+r10]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  001dd	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 510  :             int _Meta = _CSTD fgetc(_Myfile);

  001e2	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  001ef	44 8b c0	 mov	 r8d, eax

; 511  : 
; 512  :             if (_Meta == EOF) {

  001f2	83 f8 ff	 cmp	 eax, -1
  001f5	0f 85 f5 fe ff
	ff		 jne	 $LL2@uflow
$LN256@uflow:

; 539  : 
; 540  :             default:
; 541  :                 return _Traits::eof(); // conversion failed

  001fb	bb ff ff ff ff	 mov	 ebx, -1
$LN22@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00200	48 8b 55 f0	 mov	 rdx, QWORD PTR _Str$[rbp-104]
  00204	48 83 fa 10	 cmp	 rdx, 16

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00208	0f 82 9e 00 00
	00		 jb	 $LN212@uflow

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0020e	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00211	48 8b 4d d8	 mov	 rcx, QWORD PTR _Str$[rbp-128]
  00215	48 8b c1	 mov	 rax, rcx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00218	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0021f	0f 82 82 00 00
	00		 jb	 $LN222@uflow

; 134  :     _Bytes += _Non_user_size;

  00225	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00229	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0022d	48 2b c1	 sub	 rax, rcx

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00230	48 83 c0 f8	 add	 rax, -8
  00234	48 83 f8 1f	 cmp	 rax, 31
  00238	76 6d		 jbe	 SHORT $LN222@uflow
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00240	90		 npad	 1
$LN258@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2136 :         if (_Large_string_engaged()) {

  00241	48 83 7d f0 10	 cmp	 QWORD PTR _Str$[rbp-104], 16
  00246	48 0f 43 45 d8	 cmovae	 rax, QWORD PTR _Str$[rbp-128]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 525  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

  0024b	48 8b 5d e8	 mov	 rbx, QWORD PTR _Str$[rbp-112]
  0024f	48 8b 4d c0	 mov	 rcx, QWORD PTR _Src$1[rbp-128]
  00253	48 2b d9	 sub	 rbx, rcx
  00256	48 03 d8	 add	 rbx, rax

; 526  :                     while (0 < _Nleft) {

  00259	48 85 db	 test	 rbx, rbx
  0025c	7e 21		 jle	 SHORT $LN271@uflow
  0025e	66 90		 npad	 2
$LL261@uflow:

; 527  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

  00260	48 ff cb	 dec	 rbx
  00263	0f be 0c 0b	 movsx	 ecx, BYTE PTR [rbx+rcx]
  00267	48 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [rdi+128]
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc

; 526  :                     while (0 < _Nleft) {

  00274	48 85 db	 test	 rbx, rbx
  00277	7e 06		 jle	 SHORT $LN271@uflow
  00279	48 8b 4d c0	 mov	 rcx, QWORD PTR _Src$1[rbp-128]
  0027d	eb e1		 jmp	 SHORT $LL261@uflow
$LN271@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 389  :         return static_cast<unsigned char>(_Ch);

  0027f	0f b6 5d d0	 movzx	 ebx, BYTE PTR _Ch$3[rbp-128]
  00283	e9 78 ff ff ff	 jmp	 $LN22@uflow
$LN257@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  00288	83 f8 03	 cmp	 eax, 3
  0028b	0f 85 6a ff ff
	ff		 jne	 $LN256@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  00291	48 8d 45 d8	 lea	 rax, QWORD PTR _Str$[rbp-128]

; 2136 :         if (_Large_string_engaged()) {

  00295	48 83 7d f0 10	 cmp	 QWORD PTR _Str$[rbp-104], 16
  0029a	48 0f 43 45 d8	 cmovae	 rax, QWORD PTR _Str$[rbp-128]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 538  :                 return static_cast<int_type>(_Str.front());

  0029f	0f be 18	 movsx	 ebx, BYTE PTR [rax]
  002a2	e9 59 ff ff ff	 jmp	 $LN22@uflow
$LN222@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 221  :     ::operator delete(_Ptr, _Bytes);

  002a7	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN212@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 544  :     }

  002ac	8b c3		 mov	 eax, ebx
$LN232@uflow:
  002ae	48 8b 4d f8	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-128]
  002b2	48 33 cc	 xor	 rcx, rsp
  002b5	e8 00 00 00 00	 call	 __security_check_cookie
  002ba	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  002c2	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  002c6	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  002ca	49 8b e3	 mov	 rsp, r11
  002cd	5d		 pop	 rbp
  002ce	c3		 ret	 0
$LN273@uflow:
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Src$1 = 64
_Dest$2 = 72
_Ch$3 = 80
_Str$ = 88
__$ArrayPad$ = 120
this$ = 144
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR _Str$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Src$1 = 64
_Dest$2 = 72
_Ch$3 = 80
_Str$ = 88
__$ArrayPad$ = 120
this$ = 144
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR _Str$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT

; 478  :     virtual int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

$LN22:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 185  :         return *_IGnext;

  00006	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 478  :     virtual int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

  0000a	48 8b d9	 mov	 rbx, rcx

; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0000d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 18		 je	 SHORT $LN2@underflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 197  :         return *_IGnext + *_IGcount;

  00015	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00019	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  0001c	48 03 d1	 add	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0001f	48 3b ca	 cmp	 rcx, rdx
  00022	73 09		 jae	 SHORT $LN2@underflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 389  :         return static_cast<unsigned char>(_Ch);

  00024	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 488  :     }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
$LN2@underflow:

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  0002d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00038	ff 50 38	 call	 QWORD PTR [rax+56]
  0003b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 393  :         return _Left == _Right;

  0003d	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  00040	75 0b		 jne	 SHORT $LN4@underflow
  00042	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 488  :     }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5b		 pop	 rbx
  0004c	c3		 ret	 0
$LN4@underflow:

; 483  :             return _Meta; // uflow failed, return EOF
; 484  :         } else { // get a char, don't point past it
; 485  :             pbackfail(_Meta);

  0004d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00050	8b d7		 mov	 edx, edi
  00052	48 8b cb	 mov	 rcx, rbx
  00055	ff 50 20	 call	 QWORD PTR [rax+32]

; 486  :             return _Meta;

  00058	8b c7		 mov	 eax, edi
  0005a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 488  :     }

  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5b		 pop	 rbx
  00064	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 48
_Meta$ = 56
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 457  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

$LN57:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 185  :         return *_IGnext;

  0000a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 457  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

  0000e	48 8b d9	 mov	 rbx, rcx
  00011	8b fa		 mov	 edi, edx

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00013	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00016	48 85 c9	 test	 rcx, rcx
  00019	74 36		 je	 SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 181  :         return *_IGfirst;

  0001b	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001f	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00022	73 2d		 jae	 SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 393  :         return _Left == _Right;

  00024	83 fa ff	 cmp	 edx, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00027	74 08		 je	 SHORT $LN4@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 389  :         return static_cast<unsigned char>(_Ch);

  00029	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]

; 393  :         return _Left == _Right;

  0002d	3b c2		 cmp	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0002f	75 20		 jne	 SHORT $LN2@pbackfail
$LN4@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 216  :         ++*_IGcount;

  00031	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00035	ff 00		 inc	 DWORD PTR [rax]

; 217  :         return --*_IGnext;

  00037	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0003b	48 ff 08	 dec	 QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 397  :         return _Meta != eof() ? _Meta : !eof();

  0003e	33 c0		 xor	 eax, eax
  00040	83 ff ff	 cmp	 edi, -1
  00043	0f 45 c7	 cmovne	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 476  :     }

  00046	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN2@pbackfail:

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00051	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  00058	48 85 d2	 test	 rdx, rdx
  0005b	74 73		 je	 SHORT $LN7@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 393  :         return _Left == _Right;

  0005d	83 ff ff	 cmp	 edi, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00060	74 6e		 je	 SHORT $LN7@pbackfail

; 466  :             return _Traits::eof(); // no open C stream or EOF, fail
; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  00062	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  00067	75 0f		 jne	 SHORT $LN52@pbackfail

; 130  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

  00069	40 0f b6 cf	 movzx	 ecx, dil
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  00073	83 f8 ff	 cmp	 eax, -1

; 466  :             return _Traits::eof(); // no open C stream or EOF, fail
; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  00076	75 4b		 jne	 SHORT $LN54@pbackfail
$LN52@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 185  :         return *_IGnext;

  00078	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 469  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

  0007c	48 8d 53 70	 lea	 rdx, QWORD PTR [rbx+112]
  00080	49 39 10	 cmp	 QWORD PTR [r8], rdx
  00083	74 4b		 je	 SHORT $LN7@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 181  :         return *_IGfirst;

  00085	4c 8b 4b 18	 mov	 r9, QWORD PTR [rbx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 470  :             _Mychar = _Traits::to_char_type(_Meta);

  00089	40 88 3a	 mov	 BYTE PTR [rdx], dil

; 780  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

  0008c	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0008f	48 3b c2	 cmp	 rax, rdx
  00092	74 18		 je	 SHORT $LN53@pbackfail

; 781  :             _Set_eback = _Mysb::eback();

  00094	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 197  :         return *_IGnext + *_IGcount;

  0009b	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0009f	48 63 08	 movsxd	 rcx, DWORD PTR [rax]
  000a2	49 03 08	 add	 rcx, QWORD PTR [r8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 782  :             _Set_egptr = _Mysb::egptr();

  000a5	48 89 8b 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rcx
$LN53@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 206  :         *_IGfirst = _First;

  000ac	49 89 11	 mov	 QWORD PTR [r9], rdx

; 207  :         *_IGnext  = _Next;
; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  000af	8b cb		 mov	 ecx, ebx
  000b1	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000b5	2b ca		 sub	 ecx, edx
  000b7	83 c1 71	 add	 ecx, 113		; 00000071H
  000ba	48 89 10	 mov	 QWORD PTR [rax], rdx
  000bd	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000c1	89 08		 mov	 DWORD PTR [rax], ecx
$LN54@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 476  :     }

  000c3	8b c7		 mov	 eax, edi
  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ce	5f		 pop	 rdi
  000cf	c3		 ret	 0
$LN7@pbackfail:
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d5	b8 ff ff ff ff	 mov	 eax, -1
  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
_Dest$ = 64
_Src$ = 72
_Ch$ = 80
_Str$ = 88
__$ArrayPad$ = 120
this$ = 144
_Meta$ = 152
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT

; 406  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

$LN46:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001c	8b fa		 mov	 edi, edx
  0001e	48 8b d9	 mov	 rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 393  :         return _Left == _Right;

  00021	83 fa ff	 cmp	 edx, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 407  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00024	75 07		 jne	 SHORT $LN4@overflow

; 408  :             return _Traits::not_eof(_Meta); // EOF, return success code

  00026	33 c0		 xor	 eax, eax
  00028	e9 55 01 00 00	 jmp	 $LN1@overflow
$LN4@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 193  :         return *_IPnext;

  0002d	48 8b 51 40	 mov	 rdx, QWORD PTR [rcx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  00031	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00034	48 85 c0	 test	 rax, rax
  00037	74 1f		 je	 SHORT $LN5@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 212  :         return *_IPnext + *_IPcount;

  00039	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0003d	4c 63 02	 movsxd	 r8, DWORD PTR [rdx]
  00040	4c 03 c0	 add	 r8, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  00043	49 3b c0	 cmp	 rax, r8
  00046	73 10		 jae	 SHORT $LN5@overflow

; 412  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  0004e	40 88 38	 mov	 BYTE PTR [rax], dil

; 413  :             return _Meta;

  00051	8b c7		 mov	 eax, edi
  00053	e9 2a 01 00 00	 jmp	 $LN1@overflow
$LN5@overflow:

; 414  :         }
; 415  : 
; 416  :         if (!_Myfile) {

  00058	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00060	48 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rsi
  00068	0f 84 07 01 00
	00		 je	 $LN12@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 181  :         return *_IGfirst;

  0006e	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 774  :         if (_Mysb::eback() == &_Mychar) {

  00072	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
  00076	49 39 00	 cmp	 QWORD PTR [r8], rax
  00079	75 20		 jne	 SHORT $LN33@overflow

; 775  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0007b	48 8b 91 90 00
	00 00		 mov	 rdx, QWORD PTR [rcx+144]
  00082	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 206  :         *_IGfirst = _First;

  00089	49 89 08	 mov	 QWORD PTR [r8], rcx

; 207  :         *_IGnext  = _Next;
; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  0008c	2b d1		 sub	 edx, ecx
  0008e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00092	48 89 08	 mov	 QWORD PTR [rax], rcx
  00095	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00099	89 10		 mov	 DWORD PTR [rax], edx
$LN33@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 421  :         if (!_Pcvt) { // no codecvt facet, put as is

  0009b	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0009f	48 85 c9	 test	 rcx, rcx
  000a2	75 22		 jne	 SHORT $LN7@overflow

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  000a4	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  000ab	40 0f be cf	 movsx	 ecx, dil
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 422  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  000b5	b9 ff ff ff ff	 mov	 ecx, -1

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  000ba	3b c1		 cmp	 eax, ecx

; 422  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  000bc	0f 45 cf	 cmovne	 ecx, edi
  000bf	8b c1		 mov	 eax, ecx
  000c1	e9 b4 00 00 00	 jmp	 $LN43@overflow
$LN7@overflow:

; 423  :         }
; 424  : 
; 425  :         // put using codecvt facet
; 426  :         constexpr size_t _Codecvt_temp_buf = 32;
; 427  :         char _Str[_Codecvt_temp_buf];
; 428  :         const _Elem _Ch = _Traits::to_char_type(_Meta);
; 429  :         const _Elem* _Src;
; 430  :         char* _Dest;
; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

  000c6	48 8d 44 24 40	 lea	 rax, QWORD PTR _Dest$[rsp]
  000cb	40 88 7c 24 50	 mov	 BYTE PTR _Ch$[rsp], dil
  000d0	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000d5	48 8d 53 74	 lea	 rdx, QWORD PTR [rbx+116]
  000d9	48 8d 44 24 78	 lea	 rax, QWORD PTR _Str$[rsp+32]
  000de	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000e3	4c 8d 4c 24 51	 lea	 r9, QWORD PTR _Ch$[rsp+1]
  000e8	48 8d 44 24 58	 lea	 rax, QWORD PTR _Str$[rsp]
  000ed	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f2	4c 8d 44 24 50	 lea	 r8, QWORD PTR _Ch$[rsp]
  000f7	48 8d 44 24 48	 lea	 rax, QWORD PTR _Src$[rsp]
  000fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  00107	85 c0		 test	 eax, eax
  00109	78 6a		 js	 SHORT $LN12@overflow
  0010b	83 f8 01	 cmp	 eax, 1
  0010e	7e 25		 jle	 SHORT $LN8@overflow
  00110	83 f8 03	 cmp	 eax, 3
  00113	75 60		 jne	 SHORT $LN12@overflow

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  00115	0f be 4c 24 50	 movsx	 ecx, BYTE PTR _Ch$[rsp]
  0011a	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 443  :             }
; 444  : 
; 445  :             return _Traits::eof(); // conversion failed
; 446  :         }
; 447  : 
; 448  :         case codecvt_base::noconv:
; 449  :             // no conversion, put as is
; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  00127	b9 ff ff ff ff	 mov	 ecx, -1

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  0012c	3b c1		 cmp	 eax, ecx

; 443  :             }
; 444  : 
; 445  :             return _Traits::eof(); // conversion failed
; 446  :         }
; 447  : 
; 448  :         case codecvt_base::noconv:
; 449  :             // no conversion, put as is
; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  0012e	0f 45 cf	 cmovne	 ecx, edi
  00131	8b c1		 mov	 eax, ecx
  00133	eb 45		 jmp	 SHORT $LN43@overflow
$LN8@overflow:

; 432  :             _Dest)) { // test result of converting one element
; 433  :         case codecvt_base::partial:
; 434  :         case codecvt_base::ok: { // converted something, try to put it out
; 435  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

  00135	48 8b 74 24 40	 mov	 rsi, QWORD PTR _Dest$[rsp]
  0013a	48 8d 44 24 58	 lea	 rax, QWORD PTR _Str$[rsp]
  0013f	48 2b f0	 sub	 rsi, rax

; 436  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  00142	74 1f		 je	 SHORT $LN9@overflow
  00144	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  0014b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Str$[rsp]
  00150	4c 8b c6	 mov	 r8, rsi
  00153	ba 01 00 00 00	 mov	 edx, 1
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  0015e	48 3b f0	 cmp	 rsi, rax
  00161	75 12		 jne	 SHORT $LN12@overflow
$LN9@overflow:

; 437  :                 return _Traits::eof(); // write failed
; 438  :             }
; 439  : 
; 440  :             _Wrotesome = true; // write succeeded
; 441  :             if (_Src != &_Ch) {

  00163	48 8d 44 24 50	 lea	 rax, QWORD PTR _Ch$[rsp]
  00168	c6 43 71 01	 mov	 BYTE PTR [rbx+113], 1
  0016c	48 39 44 24 48	 cmp	 QWORD PTR _Src$[rsp], rax

; 442  :                 return _Meta; // converted whole element

  00171	8b c7		 mov	 eax, edi
  00173	75 05		 jne	 SHORT $LN43@overflow
$LN12@overflow:

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed

  00175	b8 ff ff ff ff	 mov	 eax, -1
$LN43@overflow:
  0017a	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]
$LN1@overflow:

; 454  :         }
; 455  :     }

  00182	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00187	48 33 cc	 xor	 rcx, rsp
  0018a	e8 00 00 00 00	 call	 __security_check_cookie
  0018f	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+168]
  00197	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0019e	5f		 pop	 rdi
  0019f	c3		 ret	 0
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 400  :         if (_Myfile) {

  00000	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 07		 je	 SHORT $LN2@Unlock

; 401  :             _CSTD _unlock_file(_Myfile);

  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__unlock_file
$LN2@Unlock:

; 402  :         }
; 403  :     }

  00013	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT

; 394  :         if (_Myfile) {

  00000	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 07		 je	 SHORT $LN2@Lock

; 395  :             _CSTD _lock_file(_Myfile);

  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__lock_file
$LN2@Lock:

; 396  :         }
; 397  :     }

  00013	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT

; 374  :     basic_filebuf* close() {

$LN20:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 375  :         basic_filebuf* _Ans;
; 376  :         if (_Myfile) { // put any homing sequence and close file

  0000f	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	74 23		 je	 SHORT $LN2@close

; 377  :             _Ans = this;
; 378  :             if (!_Endwrite()) {

  0001c	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 379  :                 _Ans = nullptr;
; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

  00021	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00028	33 ff		 xor	 edi, edi
  0002a	84 c0		 test	 al, al
  0002c	48 8b f3	 mov	 rsi, rbx
  0002f	48 0f 44 f7	 cmove	 rsi, rdi
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  00039	85 c0		 test	 eax, eax
  0003b	74 07		 je	 SHORT $LN3@close

; 383  :                 _Ans = nullptr;
; 384  :             }
; 385  :         } else {

  0003d	eb 02		 jmp	 SHORT $LN18@close
$LN2@close:

; 386  :             _Ans = nullptr;

  0003f	33 ff		 xor	 edi, edi
$LN18@close:

; 698  :         _Closef    = _Which == _Openfl;

  00041	48 8b f7	 mov	 rsi, rdi
$LN3@close:

; 699  :         _Wrotesome = false;
; 700  : 
; 701  :         _Mysb::_Init(); // initialize stream buffer base object

  00044	48 8b cb	 mov	 rcx, rbx
  00047	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0
  0004b	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 702  : 
; 703  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 704  :             _Elem** _Pb = nullptr;
; 705  :             _Elem** _Pn = nullptr;
; 706  :             int* _Nr    = nullptr;
; 707  : 
; 708  :             ::_get_stream_buffer_pointers(
; 709  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 710  :             int* _Nw = _Nr;
; 711  : 
; 712  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 713  :         }
; 714  : 
; 715  :         _Myfile = _File;

  00055	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);
; 390  :         return _Ans;

  0005c	48 8b c6	 mov	 rax, rsi

; 716  :         _State  = _Stinit;

  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 391  :     }

  00066	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 716  :         _State  = _Stinit;

  0006b	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 717  :         _Pcvt   = nullptr; // pointer to codecvt facet

  0006f	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 391  :     }

  00073	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT

; 170  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax

; 171  :         if (_Myfile) {

  00013	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0001b	74 2f		 je	 SHORT $LN6@basic_file
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 181  :         return *_IGfirst;

  0001d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 774  :         if (_Mysb::eback() == &_Mychar) {

  00021	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00025	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00028	75 22		 jne	 SHORT $LN6@basic_file

; 775  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0002a	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  00031	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 206  :         *_IGfirst = _First;

  00038	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 207  :         *_IGnext  = _Next;

  0003b	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0003f	48 89 10	 mov	 QWORD PTR [rax], rdx

; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  00042	44 2b c2	 sub	 r8d, edx
  00045	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00049	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN6@basic_file:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 175  :         if (_Closef) {

  0004c	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00050	74 08		 je	 SHORT $LN3@basic_file

; 176  :             close();

  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN3@basic_file:

; 177  :         }
; 178  :     }

  0005a	48 8b cb	 mov	 rcx, rbx
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT

; 944  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b 81 50 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-176]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  0001b	48 89 84 0a 50
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-176], rax
  00023	48 8b 81 50 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-176]
  0002a	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0002e	44 8d 82 50 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-176]
  00035	44 89 84 0a 4c
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-180], r8d
  0003d	48 81 c1 60 ff
	ff ff		 add	 rcx, -160		; ffffffffffffff60H
  00044	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00049	48 8d 8b 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-152]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
_TEXT	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 806  :     explicit basic_ifstream(

$LN60:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001c	45 8b f1	 mov	 r14d, r9d
  0001f	41 8b f0	 mov	 esi, r8d
  00022	48 8b ea	 mov	 rbp, rdx
  00025	48 8b d9	 mov	 rbx, rcx
  00028	48 89 4c 24 28	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  0002d	45 33 ff	 xor	 r15d, r15d
  00030	44 89 7c 24 20	 mov	 DWORD PTR $T1[rsp], r15d

; 807  :         const char* _Filename, ios_base::openmode _Mode = ios_base::in, int _Prot = ios_base::_Default_open_prot)
; 808  :         : _Mybase(_STD addressof(_Filebuffer)) {

  00035	44 39 bc 24 c0
	00 00 00	 cmp	 DWORD PTR $initVBases$[rsp], r15d
  0003d	74 20		 je	 SHORT $LN2@basic_ifst
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  00046	48 89 01	 mov	 QWORD PTR [rcx], rax
  00049	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00056	90		 npad	 1
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
$LN2@basic_ifst:
  0005f	48 8d 7b 10	 lea	 rdi, QWORD PTR [rbx+16]
  00063	45 33 c9	 xor	 r9d, r9d
  00066	45 33 c0	 xor	 r8d, r8d
  00069	48 8b d7	 mov	 rdx, rdi
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00075	90		 npad	 1
  00076	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00079	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00084	48 89 04 19	 mov	 QWORD PTR [rcx+rbx], rax
  00088	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0008b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0008f	8d 91 50 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-176]
  00095	89 54 19 fc	 mov	 DWORD PTR [rcx+rbx-4], edx
  00099	48 89 7c 24 40	 mov	 QWORD PTR this$[rsp], rdi

; 162  :     basic_filebuf() : _Mysb() {

  0009e	48 8b cf	 mov	 rcx, rdi
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  000a7	90		 npad	 1
  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  000af	48 89 07	 mov	 QWORD PTR [rdi], rax

; 698  :         _Closef    = _Which == _Openfl;

  000b2	c6 47 7c 00	 mov	 BYTE PTR [rdi+124], 0

; 699  :         _Wrotesome = false;

  000b6	c6 47 71 00	 mov	 BYTE PTR [rdi+113], 0

; 700  : 
; 701  :         _Mysb::_Init(); // initialize stream buffer base object

  000ba	48 8b cf	 mov	 rcx, rdi
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 715  :         _Myfile = _File;

  000c3	4c 89 bf 80 00
	00 00		 mov	 QWORD PTR [rdi+128], r15

; 716  :         _State  = _Stinit;

  000ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000d1	48 89 47 74	 mov	 QWORD PTR [rdi+116], rax

; 717  :         _Pcvt   = nullptr; // pointer to codecvt facet

  000d5	4c 89 7f 68	 mov	 QWORD PTR [rdi+104], r15

; 810  :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot)) {

  000d9	83 ce 01	 or	 esi, 1

; 281  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

  000dc	45 8b c6	 mov	 r8d, r14d
  000df	8b d6		 mov	 edx, esi
  000e1	48 8b cd	 mov	 rcx, rbp
  000e4	e8 00 00 00 00	 call	 ?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z ; std::_Fiopen
  000e9	48 8b f0	 mov	 rsi, rax

; 282  :         if (!_File) {

  000ec	48 85 c0	 test	 rax, rax
  000ef	0f 84 d9 00 00
	00		 je	 $LN54@basic_ifst

; 698  :         _Closef    = _Which == _Openfl;

  000f5	c6 47 7c 01	 mov	 BYTE PTR [rdi+124], 1

; 699  :         _Wrotesome = false;

  000f9	c6 47 71 00	 mov	 BYTE PTR [rdi+113], 0

; 700  : 
; 701  :         _Mysb::_Init(); // initialize stream buffer base object

  000fd	48 8b cf	 mov	 rcx, rdi
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 702  : 
; 703  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 704  :             _Elem** _Pb = nullptr;

  00106	4c 89 7c 24 48	 mov	 QWORD PTR _Pb$4[rsp], r15

; 705  :             _Elem** _Pn = nullptr;

  0010b	4c 89 7c 24 50	 mov	 QWORD PTR _Pn$5[rsp], r15

; 706  :             int* _Nr    = nullptr;

  00110	4c 89 7c 24 40	 mov	 QWORD PTR _Nr$3[rsp], r15

; 707  : 
; 708  :             ::_get_stream_buffer_pointers(

  00115	4c 8d 4c 24 40	 lea	 r9, QWORD PTR _Nr$3[rsp]
  0011a	4c 8d 44 24 50	 lea	 r8, QWORD PTR _Pn$5[rsp]
  0011f	48 8d 54 24 48	 lea	 rdx, QWORD PTR _Pb$4[rsp]
  00124	48 8b ce	 mov	 rcx, rsi
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\streambuf

; 274  :         _IGfirst = _Gf;

  0012d	48 8b 44 24 48	 mov	 rax, QWORD PTR _Pb$4[rsp]
  00132	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 275  :         _IPfirst = _Pf;

  00136	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 276  :         _IGnext  = _Gn;

  0013a	48 8b 44 24 50	 mov	 rax, QWORD PTR _Pn$5[rsp]
  0013f	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 277  :         _IPnext  = _Pn;

  00143	48 89 47 40	 mov	 QWORD PTR [rdi+64], rax

; 278  :         _IGcount = _Gc;

  00147	48 8b 44 24 40	 mov	 rax, QWORD PTR _Nr$3[rsp]
  0014c	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax

; 279  :         _IPcount = _Pc;

  00150	48 89 47 58	 mov	 QWORD PTR [rdi+88], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 715  :         _Myfile = _File;

  00154	48 89 b7 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rsi

; 716  :         _State  = _Stinit;

  0015b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00162	48 89 47 74	 mov	 QWORD PTR [rdi+116], rax

; 717  :         _Pcvt   = nullptr; // pointer to codecvt facet

  00166	4c 89 7f 68	 mov	 QWORD PTR [rdi+104], r15

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  0016a	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  0016f	48 8b cf	 mov	 rcx, rdi
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
  00178	90		 npad	 1
  00179	48 8b c8	 mov	 rcx, rax
  0017c	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  00181	48 8b f0	 mov	 rsi, rax

; 757  :         if (_Newcvt.always_noconv()) {

  00184	48 8b c8	 mov	 rcx, rax
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  0018d	84 c0		 test	 al, al
  0018f	74 06		 je	 SHORT $LN40@basic_ifst

; 758  :             _Pcvt = nullptr; // nothing to do

  00191	4c 89 7f 68	 mov	 QWORD PTR [rdi+104], r15

; 759  :         } else { // set up for nontrivial codecvt facet

  00195	eb 0e		 jmp	 SHORT $LN41@basic_ifst
$LN40@basic_ifst:

; 760  :             _Pcvt = _STD addressof(_Newcvt);

  00197	48 89 77 68	 mov	 QWORD PTR [rdi+104], rsi

; 761  :             _Mysb::_Init(); // reset any buffering

  0019b	48 8b cf	 mov	 rcx, rdi
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
  001a4	90		 npad	 1
$LN41@basic_ifst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale

; 351  :         if (_Ptr) {

  001a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp+8]
  001aa	48 85 c9	 test	 rcx, rcx
  001ad	74 37		 je	 SHORT $LN57@basic_ifst

; 352  :             delete _Ptr->_Decref();

  001af	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  001b2	41 ff 50 10	 call	 QWORD PTR [r8+16]
  001b6	48 85 c0	 test	 rax, rax
  001b9	74 2b		 je	 SHORT $LN57@basic_ifst
  001bb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001be	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  001c1	ba 01 00 00 00	 mov	 edx, 1
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	41 ff d0	 call	 r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 810  :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot)) {

  001cc	eb 18		 jmp	 SHORT $LN57@basic_ifst
$LN54@basic_ifst:

; 811  :             _Myios::setstate(ios_base::failbit);

  001ce	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001d1	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  001d5	48 03 cb	 add	 rcx, rbx
  001d8	45 33 c0	 xor	 r8d, r8d
  001db	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  001e5	90		 npad	 1
$LN57@basic_ifst:

; 812  :         }
; 813  :     }

  001e6	48 8b c3	 mov	 rax, rbx
  001e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001ee	48 33 cc	 xor	 rcx, rsp
  001f1	e8 00 00 00 00	 call	 __security_check_cookie
  001f6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fa	41 5f		 pop	 r15
  001fc	41 5e		 pop	 r14
  001fe	5f		 pop	 rdi
  001ff	5e		 pop	 rsi
  00200	5d		 pop	 rbp
  00201	5b		 pop	 rbx
  00202	c3		 ret	 0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN6@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 28	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN6@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 83 c1 18	 add	 rcx, 24
  0000b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 83 c1 10	 add	 rcx, 16
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$4
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN6@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 28	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN6@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 83 c1 18	 add	 rcx, 24
  0000b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 83 c1 10	 add	 rcx, 16
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
$T2 = 48
_Nr$3 = 64
this$ = 64
_Pb$4 = 72
_Pn$5 = 80
__$ArrayPad$ = 88
this$ = 160
_Filename$ = 168
_Mode$ = 176
_Prot$ = 184
$initVBases$ = 192
?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$4
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4480 : _NODISCARD bool operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

$LN21:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 318  :             return __builtin_strlen(_First);

  00004	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0000b	0f 1f 44 00 00	 npad	 5
$LL18@operator:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00017	75 f7		 jne	 SHORT $LL18@operator

; 2153 :         return _BUF_SIZE <= _Myres;

  00019	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 4096 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  0001e	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2145 :         if (_Large_string_engaged()) {

  00022	72 03		 jb	 SHORT $LN8@operator

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00024	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN8@operator:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00027	4c 3b c0	 cmp	 r8, rax
  0002a	75 10		 jne	 SHORT $LN14@operator

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  0002c	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00031	85 c0		 test	 eax, eax
  00033	75 07		 jne	 SHORT $LN14@operator

; 4481 :     return _Left._Equal(_Right);

  00035	b0 01		 mov	 al, 1

; 4482 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
$LN14@operator:

; 4481 :     return _Left._Equal(_Right);

  0003c	32 c0		 xor	 al, al

; 4482 : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1704 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlength:
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	49 8b c0	 mov	 rax, r8
  00003	4c 8b ca	 mov	 r9, rdx

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00006	4c 8b c1	 mov	 r8, rcx
  00009	48 8b d0	 mov	 rdx, rax
  0000c	49 8b c9	 mov	 rcx, r9
  0000f	e9 00 00 00 00	 jmp	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 672  :     ~vector() noexcept {

$LN30:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 4d		 je	 SHORT $LN4@vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00011	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00015	4c 8b c3	 mov	 r8, rbx
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0001d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00020	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00024	48 2b d1	 sub	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00027	48 83 e2 e0	 and	 rdx, -32		; ffffffffffffffe0H

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0002b	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00032	72 18		 jb	 SHORT $LN22@vector

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00034	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00038	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0003c	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003f	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00043	48 83 f8 1f	 cmp	 rax, 31
  00047	77 1b		 ja	 SHORT $LN19@vector

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00049	49 8b c8	 mov	 rcx, r8
$LN22@vector:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0004c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00051	33 c0		 xor	 eax, eax
  00053	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1698 :             _Mylast  = pointer();

  00056	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1699 :             _Myend   = pointer();

  0005a	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN4@vector:

; 678  :     }

  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
$LN19@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0006a	cc		 int	 3
$LN27@vector:
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00004	49 c1 e0 05	 shl	 r8, 5
  00008	48 8b c2	 mov	 rax, rdx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000b	49 81 f8 00 10
	00 00		 cmp	 r8, 4096		; 00001000H
  00012	72 18		 jb	 SHORT $LN15@deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00014	48 8b 4a f8	 mov	 rcx, QWORD PTR [rdx-8]
  00018	49 83 c0 27	 add	 r8, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	48 2b c1	 sub	 rax, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	48 83 c0 f8	 add	 rax, -8
  00023	48 83 f8 1f	 cmp	 rax, 31
  00027	77 12		 ja	 SHORT $LN12@deallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	48 8b c1	 mov	 rax, rcx
$LN15@deallocate:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0002c	49 8b d0	 mov	 rdx, r8
  0002f	48 8b c8	 mov	 rcx, rax

; 804  :     }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 221  :     ::operator delete(_Ptr, _Bytes);

  00036	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@deallocate:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00041	cc		 int	 3
$LN18@deallocate:
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z
_TEXT	SEGMENT
Assembler$ = 48
?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z PROC	; VmGetVmEnterOpCode, COMDAT

; 1062 : {

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000a	48 8b 59 18	 mov	 rbx, QWORD PTR [rcx+24]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 1062 : {

  0000e	48 8b f9	 mov	 rdi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00011	48 2b 59 10	 sub	 rbx, QWORD PTR [rcx+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 1063 : 	return Assembler->Instructions[0].OpCodes[rand() % Assembler->Instructions[0].OpCodes.size()];

  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  0001b	48 98		 cdqe
  0001d	33 d2		 xor	 edx, edx
  0001f	48 f7 f3	 div	 rbx
  00022	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1064 : }

  00026	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002b	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z ENDP	; VmGetVmEnterOpCode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
_TEXT	SEGMENT
SymbolTable$ = 32
__$ArrayPad$ = 56
Assembler$ = 112
TotalTableSize$ = 120
?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z PROC ; VmBuildSymbolTable, COMDAT

; 1036 : {

$LN87:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00025	4c 8b fa	 mov	 r15, rdx
  00028	0f 57 c9	 xorps	 xmm1, xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002b	f3 0f 7f 4c 24
	20		 movdqu	 XMMWORD PTR SymbolTable$[rsp], xmm1
  00031	45 33 f6	 xor	 r14d, r14d
  00034	4c 89 74 24 30	 mov	 QWORD PTR SymbolTable$[rsp+16], r14
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 1038 : 	ULONG RunningOffset = 0;

  00039	33 ed		 xor	 ebp, ebp

; 1039 : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  0003b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003e	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  00041	49 bc 39 8e e3
	38 8e e3 38 0e	 mov	 r12, 1024819115206086201 ; 0e38e38e38e38e39H
  0004b	48 8b 5c 24 28	 mov	 rbx, QWORD PTR SymbolTable$[rsp+8]
  00050	48 8b 74 24 20	 mov	 rsi, QWORD PTR SymbolTable$[rsp]
  00055	48 85 ff	 test	 rdi, rdi
  00058	0f 84 e3 00 00
	00		 je	 $LN3@VmBuildSym
  0005e	66 90		 npad	 2
$LL4@VmBuildSym:

; 1040 : 	{
; 1041 : 		if (Link->IsLabel)

  00060	80 7f 10 00	 cmp	 BYTE PTR [rdi+16], 0
  00064	0f 84 c0 00 00
	00		 je	 $LN8@VmBuildSym
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0006a	49 3b de	 cmp	 rbx, r14
  0006d	74 1a		 je	 SHORT $LN23@VmBuildSym
  0006f	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00072	33 c0		 xor	 eax, eax
  00074	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00077	0f 11 43 10	 movups	 XMMWORD PTR [rbx+16], xmm0
  0007b	89 43 20	 mov	 DWORD PTR [rbx+32], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  0007e	48 83 c3 24	 add	 rbx, 36			; 00000024H
  00082	48 89 5c 24 28	 mov	 QWORD PTR SymbolTable$[rsp+8], rbx

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00087	eb 1c		 jmp	 SHORT $LN22@VmBuildSym
$LN23@VmBuildSym:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00089	48 8b d3	 mov	 rdx, rbx
  0008c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR SymbolTable$[rsp]
  00091	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@$$V@?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAAPEAU_VM_SYMBOL@@QEAU2@@Z ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::_Emplace_reallocate<>
  00096	4c 8b 74 24 30	 mov	 r14, QWORD PTR SymbolTable$[rsp+16]
  0009b	48 8b 5c 24 28	 mov	 rbx, QWORD PTR SymbolTable$[rsp+8]
  000a0	48 8b 74 24 20	 mov	 rsi, QWORD PTR SymbolTable$[rsp]
$LN22@VmBuildSym:

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000a5	48 8b cb	 mov	 rcx, rbx
  000a8	48 2b ce	 sub	 rcx, rsi
  000ab	49 8b c4	 mov	 rax, r12
  000ae	48 f7 e9	 imul	 rcx
  000b1	4c 8b c2	 mov	 r8, rdx
  000b4	49 d1 f8	 sar	 r8, 1
  000b7	49 8b c0	 mov	 rax, r8
  000ba	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  000be	4c 03 c0	 add	 r8, rax

; 1504 :         return _My_data._Myfirst[_Pos];

  000c1	4b 8d 04 c0	 lea	 rax, QWORD PTR [r8+r8*8]
  000c5	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 1044 : 			memset(&SymbolTable[SymbolTable.size() - 1], 0, sizeof(VM_SYMBOL));

  000c8	33 c9		 xor	 ecx, ecx
  000ca	0f 11 44 86 dc	 movups	 XMMWORD PTR [rsi+rax*4-36], xmm0
  000cf	0f 11 44 86 ec	 movups	 XMMWORD PTR [rsi+rax*4-20], xmm0
  000d4	89 4c 86 fc	 mov	 DWORD PTR [rsi+rax*4-4], ecx

; 1045 : 			INT CopyLength = min(Link->Name.length(), VM_SYMBOL_NAME_LENGTH);

  000d8	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  000dc	b9 1f 00 00 00	 mov	 ecx, 31
  000e1	48 3b c1	 cmp	 rax, rcx
  000e4	0f 42 c8	 cmovb	 ecx, eax

; 1046 : 			for (INT i = 0; i < CopyLength; i++)

  000e7	33 c0		 xor	 eax, eax
  000e9	4c 63 d1	 movsxd	 r10, ecx
  000ec	85 c9		 test	 ecx, ecx
  000ee	7e 30		 jle	 SHORT $LN6@VmBuildSym
  000f0	4b 8d 0c c0	 lea	 rcx, QWORD PTR [r8+r8*8]
  000f4	4c 8d 0c 8e	 lea	 r9, QWORD PTR [rsi+rcx*4]
  000f8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@VmBuildSym:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  00100	48 8d 4f 20	 lea	 rcx, QWORD PTR [rdi+32]

; 2136 :         if (_Large_string_engaged()) {

  00104	48 83 7f 38 10	 cmp	 QWORD PTR [rdi+56], 16
  00109	72 04		 jb	 SHORT $LN36@VmBuildSym

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  0010b	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
$LN36@VmBuildSym:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 1047 : 				SymbolTable[SymbolTable.size() - 1].Name[i] = Link->Name[i];

  0010f	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00113	41 88 4c 01 dc	 mov	 BYTE PTR [r9+rax-36], cl

; 1046 : 			for (INT i = 0; i < CopyLength; i++)

  00118	48 ff c0	 inc	 rax
  0011b	49 3b c2	 cmp	 rax, r10
  0011e	7c e0		 jl	 SHORT $LL7@VmBuildSym
$LN6@VmBuildSym:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00120	4b 8d 04 c0	 lea	 rax, QWORD PTR [r8+r8*8]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 1049 : 			SymbolTable[SymbolTable.size() - 1].Offset = RunningOffset;

  00124	89 6c 86 fc	 mov	 DWORD PTR [rsi+rax*4-4], ebp

; 1050 : 		}

  00128	eb 0b		 jmp	 SHORT $LN2@VmBuildSym
$LN8@VmBuildSym:

; 1051 : 		else
; 1052 : 		{
; 1053 : 			RunningOffset += VmGetInstructionLength(Link->InstructionId);

  0012a	0f b6 4f 11	 movzx	 ecx, BYTE PTR [rdi+17]
  0012e	e8 00 00 00 00	 call	 ?VmGetInstructionLength@@YAHE@Z ; VmGetInstructionLength
  00133	03 e8		 add	 ebp, eax
$LN2@VmBuildSym:

; 1039 : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  00135	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
  00138	48 85 ff	 test	 rdi, rdi
  0013b	0f 85 1f ff ff
	ff		 jne	 $LL4@VmBuildSym
$LN3@VmBuildSym:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00141	48 2b de	 sub	 rbx, rsi
  00144	49 8b c4	 mov	 rax, r12
  00147	48 f7 eb	 imul	 rbx
  0014a	48 d1 fa	 sar	 rdx, 1
  0014d	48 8b c2	 mov	 rax, rdx
  00150	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00154	48 03 d0	 add	 rdx, rax
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 1056 : 	*TotalTableSize = SymbolTable.size() * sizeof(VM_SYMBOL);

  00157	8d 0c d2	 lea	 ecx, DWORD PTR [rdx+rdx*8]
  0015a	c1 e1 02	 shl	 ecx, 2
  0015d	41 89 0f	 mov	 DWORD PTR [r15], ecx

; 1057 : 	PVM_SYMBOL RetTable = (PVM_SYMBOL)malloc(*TotalTableSize);

  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00166	48 8b d8	 mov	 rbx, rax

; 1058 : 	memcpy(RetTable, SymbolTable.data(), *TotalTableSize);

  00169	45 8b 07	 mov	 r8d, DWORD PTR [r15]
  0016c	48 8b d6	 mov	 rdx, rsi
  0016f	48 8b c8	 mov	 rcx, rax
  00172	e8 00 00 00 00	 call	 memcpy
  00177	90		 npad	 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00178	48 85 f6	 test	 rsi, rsi
  0017b	74 4e		 je	 SHORT $LN53@VmBuildSym

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0017d	4c 2b f6	 sub	 r14, rsi
  00180	49 8b c4	 mov	 rax, r12
  00183	49 f7 ee	 imul	 r14
  00186	48 d1 fa	 sar	 rdx, 1
  00189	48 8b c2	 mov	 rax, rdx
  0018c	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00190	48 03 d0	 add	 rdx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00193	48 8d 14 d2	 lea	 rdx, QWORD PTR [rdx+rdx*8]
  00197	48 c1 e2 02	 shl	 rdx, 2
  0019b	48 8b c6	 mov	 rax, rsi

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0019e	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  001a5	72 1c		 jb	 SHORT $LN69@VmBuildSym

; 134  :     _Bytes += _Non_user_size;

  001a7	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001ab	48 8b 76 f8	 mov	 rsi, QWORD PTR [rsi-8]
  001af	48 2b c6	 sub	 rax, rsi

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b2	48 83 c0 f8	 add	 rax, -8
  001b6	48 83 f8 1f	 cmp	 rax, 31
  001ba	76 07		 jbe	 SHORT $LN69@VmBuildSym
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001c2	cc		 int	 3
$LN69@VmBuildSym:

; 221  :     ::operator delete(_Ptr, _Bytes);

  001c3	48 8b ce	 mov	 rcx, rsi
  001c6	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN53@VmBuildSym:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 1059 : 	return RetTable;

  001cb	48 8b c3	 mov	 rax, rbx

; 1060 : }

  001ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d3	48 33 cc	 xor	 rcx, rsp
  001d6	e8 00 00 00 00	 call	 __security_check_cookie
  001db	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  001e0	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  001e4	49 8b 6b 48	 mov	 rbp, QWORD PTR [r11+72]
  001e8	49 8b e3	 mov	 rsp, r11
  001eb	41 5f		 pop	 r15
  001ed	41 5e		 pop	 r14
  001ef	41 5c		 pop	 r12
  001f1	5f		 pop	 rdi
  001f2	5e		 pop	 rsi
  001f3	c3		 ret	 0
$LN84@VmBuildSym:
?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ENDP ; VmBuildSymbolTable
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
SymbolTable$ = 32
__$ArrayPad$ = 56
Assembler$ = 112
TotalTableSize$ = 120
?dtor$0@?0??VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z@4HA PROC ; `VmBuildSymbolTable'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR SymbolTable$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::~vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >
?dtor$0@?0??VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z@4HA ENDP ; `VmBuildSymbolTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
SymbolTable$ = 32
__$ArrayPad$ = 56
Assembler$ = 112
TotalTableSize$ = 120
?dtor$0@?0??VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z@4HA PROC ; `VmBuildSymbolTable'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR SymbolTable$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@U_VM_SYMBOL@@V?$allocator@U_VM_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >::~vector<_VM_SYMBOL,std::allocator<_VM_SYMBOL> >
?dtor$0@?0??VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z@4HA ENDP ; `VmBuildSymbolTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z
_TEXT	SEGMENT
Assembler$ = 8
Table$ = 16
?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z PROC	; VmBuildHandlerTable, COMDAT

; 1023 : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1024 : 	ULONG RunningOffset = 0;
; 1025 : 
; 1026 : 	for (PVM_INSTRUCTION Instruction : Assembler->UsedInstructions)

  00005	48 8b 99 18 28
	00 00		 mov	 rbx, QWORD PTR [rcx+10264]
  0000c	45 33 c0	 xor	 r8d, r8d
  0000f	4c 8b 91 10 28
	00 00		 mov	 r10, QWORD PTR [rcx+10256]
  00016	4c 3b d3	 cmp	 r10, rbx
  00019	74 31		 je	 SHORT $LN3@VmBuildHan
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@VmBuildHan:
  00020	4d 8b 1a	 mov	 r11, QWORD PTR [r10]

; 1027 : 	{
; 1028 : 		for (UCHAR OpCode : Instruction->OpCodes)

  00023	4d 8b 4b 08	 mov	 r9, QWORD PTR [r11+8]
  00027	49 8b 03	 mov	 rax, QWORD PTR [r11]
  0002a	49 3b c1	 cmp	 rax, r9
  0002d	74 10		 je	 SHORT $LN6@VmBuildHan
  0002f	90		 npad	 1
$LL7@VmBuildHan:

; 1029 : 		{
; 1030 : 			Table[OpCode] = RunningOffset;

  00030	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00033	48 ff c0	 inc	 rax
  00036	44 89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], r8d
  0003a	49 3b c1	 cmp	 rax, r9
  0003d	75 f1		 jne	 SHORT $LL7@VmBuildHan
$LN6@VmBuildHan:

; 1031 : 		}
; 1032 : 		RunningOffset += Instruction->Size;

  0003f	45 03 43 1c	 add	 r8d, DWORD PTR [r11+28]
  00043	49 83 c2 08	 add	 r10, 8
  00047	4c 3b d3	 cmp	 r10, rbx
  0004a	75 d4		 jne	 SHORT $LL4@VmBuildHan
$LN3@VmBuildHan:

; 1033 : 	}
; 1034 : }

  0004c	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00051	c3		 ret	 0
?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z ENDP	; VmBuildHandlerTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
_TEXT	SEGMENT
Assembler$ = 48
Size$ = 56
?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z PROC ; VmAssembleVmToBuffer, COMDAT

; 1007 : {

$LN21:
  00000	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00005	41 56		 push	 r14
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 799  : 	for (PVM_INSTRUCTION Inst : Assembler->UsedInstructions)

  0000b	4c 8b 91 18 28
	00 00		 mov	 r10, QWORD PTR [rcx+10264]
  00012	45 33 c9	 xor	 r9d, r9d
  00015	48 8b 81 10 28
	00 00		 mov	 rax, QWORD PTR [rcx+10256]

; 1007 : {

  0001c	48 8b f9	 mov	 rdi, rcx

; 799  : 	for (PVM_INSTRUCTION Inst : Assembler->UsedInstructions)

  0001f	49 3b c2	 cmp	 rax, r10
  00022	74 1c		 je	 SHORT $LN9@VmAssemble
  00024	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL10@VmAssemble:

; 800  : 	{
; 801  : 		Size += Inst->Size;

  00030	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00033	48 83 c0 08	 add	 rax, 8
  00037	45 03 48 1c	 add	 r9d, DWORD PTR [r8+28]
  0003b	49 3b c2	 cmp	 rax, r10
  0003e	75 f0		 jne	 SHORT $LL10@VmAssemble
$LN9@VmAssemble:

; 1008 : 	*Size = VmGetVmSize(Assembler);
; 1009 : 	PVOID VmBuffBase = malloc(*Size);

  00040	41 8b c9	 mov	 ecx, r9d
  00043	44 89 0a	 mov	 DWORD PTR [rdx], r9d
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004c	4c 8b f0	 mov	 r14, rax

; 1010 : 	if (!VmBuffBase)

  0004f	48 85 c0	 test	 rax, rax
  00052	75 0c		 jne	 SHORT $LN5@VmAssemble

; 1021 : }

  00054	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	41 5e		 pop	 r14
  0005f	c3		 ret	 0
$LN5@VmAssemble:
  00060	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp

; 1011 : 		return NULL;
; 1012 : 
; 1013 : 	PUCHAR VmBuffOff = (PUCHAR)VmBuffBase;
; 1014 : 	for (PVM_INSTRUCTION Instruction : Assembler->UsedInstructions)

  00065	48 8b af 18 28
	00 00		 mov	 rbp, QWORD PTR [rdi+10264]
  0006c	48 8b bf 10 28
	00 00		 mov	 rdi, QWORD PTR [rdi+10256]
  00073	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00078	49 8b f6	 mov	 rsi, r14
  0007b	48 3b fd	 cmp	 rdi, rbp
  0007e	74 37		 je	 SHORT $LN3@VmAssemble
  00080	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00085	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@VmAssemble:
  00090	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 1015 : 	{
; 1016 : 		memcpy(VmBuffOff, Instruction->Code, Instruction->Size);

  00093	48 8b ce	 mov	 rcx, rsi
  00096	44 8b 43 1c	 mov	 r8d, DWORD PTR [rbx+28]
  0009a	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0009e	e8 00 00 00 00	 call	 memcpy

; 1017 : 		VmBuffOff += Instruction->Size;

  000a3	8b 43 1c	 mov	 eax, DWORD PTR [rbx+28]
  000a6	48 83 c7 08	 add	 rdi, 8
  000aa	48 03 f0	 add	 rsi, rax
  000ad	48 3b fd	 cmp	 rdi, rbp
  000b0	75 de		 jne	 SHORT $LL4@VmAssemble

; 1011 : 		return NULL;
; 1012 : 
; 1013 : 	PUCHAR VmBuffOff = (PUCHAR)VmBuffBase;
; 1014 : 	for (PVM_INSTRUCTION Instruction : Assembler->UsedInstructions)

  000b2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN3@VmAssemble:

; 1018 : 	}
; 1019 : 
; 1020 : 	return VmBuffBase;

  000b7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bc	49 8b c6	 mov	 rax, r14
  000bf	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 1021 : }

  000c4	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	41 5e		 pop	 r14
  000cf	c3		 ret	 0
?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ENDP ; VmAssembleVmToBuffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z
_TEXT	SEGMENT
T$1 = 96
Assembler$ = 96
T$2 = 104
Size$ = 104
?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z PROC ; VmAssembleCodeToBuffer, COMDAT

; 835  : {

$LN105:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 789  : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  0000c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000f	33 ff		 xor	 edi, edi

; 835  : {

  00011	48 8b f2	 mov	 rsi, rdx
  00014	4c 8b e9	 mov	 r13, rcx

; 789  : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  00017	48 8b 18	 mov	 rbx, QWORD PTR [rax]
  0001a	48 85 db	 test	 rbx, rbx
  0001d	74 1a		 je	 SHORT $LN20@VmAssemble
  0001f	90		 npad	 1
$LL21@VmAssemble:

; 790  : 	{
; 791  : 		if (!Link->IsLabel)

  00020	80 7b 10 00	 cmp	 BYTE PTR [rbx+16], 0
  00024	75 0b		 jne	 SHORT $LN19@VmAssemble

; 792  : 			Size += VmGetInstructionLength(Link->InstructionId);

  00026	0f b6 4b 11	 movzx	 ecx, BYTE PTR [rbx+17]
  0002a	e8 00 00 00 00	 call	 ?VmGetInstructionLength@@YAHE@Z ; VmGetInstructionLength
  0002f	03 f8		 add	 edi, eax
$LN19@VmAssemble:

; 789  : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  00031	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  00034	48 85 db	 test	 rbx, rbx
  00037	75 e7		 jne	 SHORT $LL21@VmAssemble
$LN20@VmAssemble:

; 836  : 	*Size = VmGetCodeSize(Assembler);
; 837  : 	PVOID BuffBase = malloc(*Size);

  00039	8b cf		 mov	 ecx, edi
  0003b	89 3e		 mov	 DWORD PTR [rsi], edi
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00043	4c 8b e0	 mov	 r12, rax

; 838  : 	if (!BuffBase)

  00046	48 85 c0	 test	 rax, rax
  00049	75 0c		 jne	 SHORT $LN7@VmAssemble

; 1005 : }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	41 5d		 pop	 r13
  00051	41 5c		 pop	 r12
  00053	5f		 pop	 rdi
  00054	5e		 pop	 rsi
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN7@VmAssemble:

; 839  : 		return NULL;
; 840  : 
; 841  : 	PUCHAR BuffOff = (PUCHAR)BuffBase;
; 842  : 
; 843  : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  00057	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  0005b	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00060	4d 8b f4	 mov	 r14, r12
  00063	48 8b 30	 mov	 rsi, QWORD PTR [rax]
  00066	48 85 f6	 test	 rsi, rsi
  00069	0f 84 05 02 00
	00		 je	 $LN3@VmAssemble
  0006f	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00074	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@VmAssemble:

; 844  : 	{
; 845  : 		if (!Link->IsLabel)

  00080	80 7e 10 00	 cmp	 BYTE PTR [rsi+16], 0
  00084	0f 85 d4 01 00
	00		 jne	 $LN2@VmAssemble

; 848  : 			OpCode = Assembler->Instructions[Link->InstructionId].OpCodes[rand() % Assembler->Instructions[Link->InstructionId].OpCodes.size()]; //rand() % Assembler->Instructions[Link->InstructionId].OpCodes.size()

  0008a	0f b6 7e 11	 movzx	 edi, BYTE PTR [rsi+17]
  0008e	48 8d 04 bf	 lea	 rax, QWORD PTR [rdi+rdi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00092	49 8b 5c c5 18	 mov	 rbx, QWORD PTR [r13+rax*8+24]
  00097	49 2b 5c c5 10	 sub	 rbx, QWORD PTR [r13+rax*8+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 848  : 			OpCode = Assembler->Instructions[Link->InstructionId].OpCodes[rand() % Assembler->Instructions[Link->InstructionId].OpCodes.size()]; //rand() % Assembler->Instructions[Link->InstructionId].OpCodes.size()

  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand

; 849  : 
; 850  : 			switch (Link->InstructionId)

  000a2	0f b6 6e 11	 movzx	 ebp, BYTE PTR [rsi+17]
  000a6	33 d2		 xor	 edx, edx
  000a8	48 98		 cdqe
  000aa	48 f7 f3	 div	 rbx
  000ad	48 8d 04 bf	 lea	 rax, QWORD PTR [rdi+rdi*4]
  000b1	49 8b 4c c5 10	 mov	 rcx, QWORD PTR [r13+rax*8+16]
  000b6	8d 45 fd	 lea	 eax, DWORD PTR [rbp-3]
  000b9	44 0f b6 3c 0a	 movzx	 r15d, BYTE PTR [rdx+rcx]
  000be	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  000c3	0f 87 8f 01 00
	00		 ja	 $LN16@VmAssemble
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  000d0	48 98		 cdqe
  000d2	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN101@VmAssemble[rdx+rax]
  000da	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN102@VmAssemble[rdx+rax*4]
  000e1	48 03 ca	 add	 rcx, rdx
  000e4	ff e1		 jmp	 rcx
$LN9@VmAssemble:

; 851  : 			{
; 852  : 			case LDIB:
; 853  : 			case LDIBSXW:
; 854  : 			case LDIBSXD:
; 855  : 			case LDIBSXQ:
; 856  : 			case LDIBZXW:
; 857  : 			case LDIBZXD:
; 858  : 			case LDIBZXQ:
; 859  : 			{
; 860  : #pragma pack(push, 1)
; 861  : 				struct
; 862  : 				{
; 863  : 					UCHAR v1;
; 864  : 					CHAR v2;
; 865  : 				}T;
; 866  : #pragma pack(pop)
; 867  : 				T.v1 = OpCode;
; 868  : 				T.v2 = (CHAR)Link->Data;

  000e6	0f b6 46 18	 movzx	 eax, BYTE PTR [rsi+24]
  000ea	88 44 24 61	 mov	 BYTE PTR T$1[rsp+1], al
  000ee	44 88 7c 24 60	 mov	 BYTE PTR T$1[rsp], r15b

; 869  : 				memcpy(BuffOff, &T, sizeof(T));

  000f3	0f b7 44 24 60	 movzx	 eax, WORD PTR T$1[rsp]
  000f8	66 41 89 06	 mov	 WORD PTR [r14], ax

; 870  : 				BuffOff += sizeof(T);

  000fc	49 83 c6 02	 add	 r14, 2

; 871  : 				break;

  00100	e9 59 01 00 00	 jmp	 $LN2@VmAssemble
$LN10@VmAssemble:

; 872  : 			}
; 873  : 			case LDIW:
; 874  : 			case EDITSP:
; 875  : 			case LDIWSXD:
; 876  : 			case LDIWSXQ:
; 877  : 			case LDIWZXD:
; 878  : 			case LDIWZXQ:
; 879  : 			case LDBPB:
; 880  : 			case LDBPW:
; 881  : 			case LDBPD:
; 882  : 			case LDBPQ:
; 883  : 			case STBPB:
; 884  : 			case STBPW:
; 885  : 			case STBPD:
; 886  : 			case STBPQ:
; 887  : 			{
; 888  : #pragma pack(push, 1)
; 889  : 				struct
; 890  : 				{
; 891  : 					UCHAR v1;
; 892  : 					SHORT v2;
; 893  : 				}T;
; 894  : #pragma pack(pop)
; 895  : 				T.v1 = OpCode;
; 896  : 				T.v2 = (SHORT)Link->Data;

  00105	0f b7 46 18	 movzx	 eax, WORD PTR [rsi+24]

; 897  : 				memcpy(BuffOff, &T, sizeof(T));

  00109	45 88 3e	 mov	 BYTE PTR [r14], r15b
  0010c	66 41 89 46 01	 mov	 WORD PTR [r14+1], ax

; 898  : 				BuffOff += sizeof(T);

  00111	49 83 c6 03	 add	 r14, 3

; 899  : 				break;

  00115	e9 44 01 00 00	 jmp	 $LN2@VmAssemble
$LN11@VmAssemble:

; 900  : 			}
; 901  : 			case LDID:
; 902  : 			case LDIDSXQ:
; 903  : 			case LDIDZXQ:
; 904  : 			{
; 905  : #pragma pack(push, 1)
; 906  : 				struct
; 907  : 				{
; 908  : 					UCHAR v1;
; 909  : 					INT v2;
; 910  : 				}T;
; 911  : #pragma pack(pop)
; 912  : 				T.v1 = OpCode;
; 913  : 				T.v2 = (INT)Link->Data;

  0011a	8b 46 18	 mov	 eax, DWORD PTR [rsi+24]

; 914  : 				memcpy(BuffOff, &T, sizeof(T));

  0011d	45 88 3e	 mov	 BYTE PTR [r14], r15b
  00120	41 89 46 01	 mov	 DWORD PTR [r14+1], eax

; 915  : 				BuffOff += sizeof(T);

  00124	49 83 c6 05	 add	 r14, 5

; 916  : 				break;

  00128	e9 31 01 00 00	 jmp	 $LN2@VmAssemble
$LN12@VmAssemble:

; 917  : 			}
; 918  : 			case LDIQ:
; 919  : 			case LDSB:
; 920  : 			case LDSW:
; 921  : 			case LDSD:
; 922  : 			case LDSQ:
; 923  : 			case STSB:
; 924  : 			case STSW:
; 925  : 			case STSD:
; 926  : 			case STSQ:
; 927  : 			{
; 928  : #pragma pack(push, 1)
; 929  : 				struct
; 930  : 				{
; 931  : 					UCHAR v1;
; 932  : 					LONG64 v2;
; 933  : 				}T;
; 934  : #pragma pack(pop)
; 935  : 				T.v1 = OpCode;
; 936  : 				T.v2 = (LONG64)Link->Data;

  0012d	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]

; 937  : 				memcpy(BuffOff, &T, sizeof(T));

  00131	45 88 3e	 mov	 BYTE PTR [r14], r15b
  00134	49 89 46 01	 mov	 QWORD PTR [r14+1], rax

; 938  : 				BuffOff += sizeof(T);

  00138	49 83 c6 09	 add	 r14, 9

; 939  : 				break;

  0013c	e9 1d 01 00 00	 jmp	 $LN2@VmAssemble
$LN13@VmAssemble:

; 940  : 			}
; 941  : 			case POPB:
; 942  : 			case POPW:
; 943  : 			case POPD:
; 944  : 			case POPQ:
; 945  : 			case PUSHB:
; 946  : 			case PUSHW:
; 947  : 			case PUSHD:
; 948  : 			case PUSHQ:
; 949  : 			case STSP:
; 950  : 			case LDSP:
; 951  : 			case STIP:
; 952  : 			case LDIP:
; 953  : 			{
; 954  : #pragma pack(push, 1)
; 955  : 				struct
; 956  : 				{
; 957  : 					UCHAR v1;
; 958  : 					UCHAR v2;
; 959  : 				}T;
; 960  : #pragma pack(pop)
; 961  : 				T.v1 = OpCode;
; 962  : 				T.v2 = (UCHAR)Link->Data;

  00141	0f b6 46 18	 movzx	 eax, BYTE PTR [rsi+24]
  00145	88 44 24 69	 mov	 BYTE PTR T$2[rsp+1], al
  00149	44 88 7c 24 68	 mov	 BYTE PTR T$2[rsp], r15b

; 963  : 				memcpy(BuffOff, &T, sizeof(T));

  0014e	0f b7 44 24 68	 movzx	 eax, WORD PTR T$2[rsp]
  00153	66 41 89 06	 mov	 WORD PTR [r14], ax

; 964  : 				BuffOff += sizeof(T);

  00157	49 83 c6 02	 add	 r14, 2

; 965  : 				break;

  0015b	e9 fe 00 00 00	 jmp	 $LN2@VmAssemble
$LN14@VmAssemble:

; 809  : 	LONGLONG Delta = 0;

  00160	33 ff		 xor	 edi, edi

; 810  : 	for (Temp = Jmp; Temp && Temp->Prev; Temp = Temp->Prev)

  00162	48 8b de	 mov	 rbx, rsi
$LL31@VmAssemble:
  00165	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00169	48 85 db	 test	 rbx, rbx
  0016c	74 5d		 je	 SHORT $LN30@VmAssemble

; 812  : 		if (Temp->Prev->IsLabel && Temp->Prev->Name == Jmp->Name)

  0016e	80 7b 10 00	 cmp	 BYTE PTR [rbx+16], 0
  00172	74 32		 je	 SHORT $LN54@VmAssemble
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00174	48 83 7e 38 10	 cmp	 QWORD PTR [rsi+56], 16
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 812  : 		if (Temp->Prev->IsLabel && Temp->Prev->Name == Jmp->Name)

  00179	48 8d 56 20	 lea	 rdx, QWORD PTR [rsi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0017d	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 812  : 		if (Temp->Prev->IsLabel && Temp->Prev->Name == Jmp->Name)

  00181	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  00185	72 03		 jb	 SHORT $LN43@VmAssemble

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00187	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN43@VmAssemble:

; 2153 :         return _BUF_SIZE <= _Myres;

  0018a	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0018f	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2145 :         if (_Large_string_engaged()) {

  00193	72 03		 jb	 SHORT $LN48@VmAssemble

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00195	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN48@VmAssemble:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00198	4c 3b c0	 cmp	 r8, rax
  0019b	75 09		 jne	 SHORT $LN54@VmAssemble

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  0019d	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  001a2	85 c0		 test	 eax, eax
  001a4	74 11		 je	 SHORT $LN82@VmAssemble
$LN54@VmAssemble:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 817  : 		Delta -= VmGetInstructionLength(Temp->Prev->InstructionId);

  001a6	0f b6 4b 11	 movzx	 ecx, BYTE PTR [rbx+17]
  001aa	e8 00 00 00 00	 call	 ?VmGetInstructionLength@@YAHE@Z ; VmGetInstructionLength
  001af	48 63 c8	 movsxd	 rcx, eax
  001b2	48 2b f9	 sub	 rdi, rcx
  001b5	eb ae		 jmp	 SHORT $LL31@VmAssemble
$LN82@VmAssemble:

; 988  : 				}
; 989  : 				T.v1 = OpCode;
; 990  : 				T.v2 = (LONG64)Link->Data;
; 991  : 				memcpy(BuffOff, &T, sizeof(T));

  001b7	48 89 7e 18	 mov	 QWORD PTR [rsi+24], rdi
  001bb	45 88 3e	 mov	 BYTE PTR [r14], r15b
  001be	49 89 7e 01	 mov	 QWORD PTR [r14+1], rdi

; 992  : 				BuffOff += sizeof(T);

  001c2	49 83 c6 09	 add	 r14, 9

; 993  : 
; 994  : 				break;

  001c6	e9 93 00 00 00	 jmp	 $LN2@VmAssemble
$LN30@VmAssemble:

; 821  : 	Delta = VmGetInstructionLength(Jmp->InstructionId); //9

  001cb	40 0f b6 cd	 movzx	 ecx, bpl
  001cf	e8 00 00 00 00	 call	 ?VmGetInstructionLength@@YAHE@Z ; VmGetInstructionLength
  001d4	48 63 f8	 movsxd	 rdi, eax

; 822  : 	for (Temp = Jmp; Temp && Temp->Next; Temp = Temp->Next)

  001d7	48 8b de	 mov	 rbx, rsi
  001da	66 0f 1f 44 00
	00		 npad	 6
$LL34@VmAssemble:
  001e0	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  001e3	48 85 db	 test	 rbx, rbx
  001e6	74 49		 je	 SHORT $LN33@VmAssemble

; 824  : 		if (Temp->Next->IsLabel && Temp->Next->Name == Jmp->Name)

  001e8	80 7b 10 00	 cmp	 BYTE PTR [rbx+16], 0
  001ec	74 32		 je	 SHORT $LN74@VmAssemble
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  001ee	48 83 7e 38 10	 cmp	 QWORD PTR [rsi+56], 16
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 824  : 		if (Temp->Next->IsLabel && Temp->Next->Name == Jmp->Name)

  001f3	48 8d 56 20	 lea	 rdx, QWORD PTR [rsi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  001f7	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 824  : 		if (Temp->Next->IsLabel && Temp->Next->Name == Jmp->Name)

  001fb	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  001ff	72 03		 jb	 SHORT $LN63@VmAssemble

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00201	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN63@VmAssemble:

; 2153 :         return _BUF_SIZE <= _Myres;

  00204	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00209	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2145 :         if (_Large_string_engaged()) {

  0020d	72 03		 jb	 SHORT $LN68@VmAssemble

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  0020f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN68@VmAssemble:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00212	4c 3b c0	 cmp	 r8, rax
  00215	75 09		 jne	 SHORT $LN74@VmAssemble

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  00217	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0021c	85 c0		 test	 eax, eax
  0021e	74 97		 je	 SHORT $LN82@VmAssemble
$LN74@VmAssemble:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 829  : 		Delta += VmGetInstructionLength(Temp->Next->InstructionId);

  00220	0f b6 4b 11	 movzx	 ecx, BYTE PTR [rbx+17]
  00224	e8 00 00 00 00	 call	 ?VmGetInstructionLength@@YAHE@Z ; VmGetInstructionLength
  00229	48 63 c8	 movsxd	 rcx, eax
  0022c	48 03 f9	 add	 rdi, rcx
  0022f	eb af		 jmp	 SHORT $LL34@VmAssemble
$LN33@VmAssemble:

; 966  : 			}
; 967  : 			case JMPI:
; 968  : 			case JL:
; 969  : 			case JLE:
; 970  : 			case JG:
; 971  : 			case JGE:
; 972  : 			case JZ:
; 973  : 			case JNZ:
; 974  : 			case CALL:
; 975  : 			{
; 976  : #pragma pack(push, 1)
; 977  : 				struct
; 978  : 				{
; 979  : 					UCHAR v1;
; 980  : 					LONG64 v2;
; 981  : 				}T;
; 982  : #pragma pack(pop)
; 983  : 
; 984  : 				if (!VmGetJumpDelta(Link))
; 985  : 				{
; 986  : 					system("pause");

  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05PDJBBECF@pause@
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_system

; 987  : 					free(BuffBase);

  0023e	49 8b cc	 mov	 rcx, r12
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00247	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 988  : 				}
; 989  : 				T.v1 = OpCode;
; 990  : 				T.v2 = (LONG64)Link->Data;
; 991  : 				memcpy(BuffOff, &T, sizeof(T));

  0024b	45 88 3e	 mov	 BYTE PTR [r14], r15b
  0024e	49 89 7e 01	 mov	 QWORD PTR [r14+1], rdi

; 992  : 				BuffOff += sizeof(T);

  00252	49 83 c6 09	 add	 r14, 9

; 993  : 
; 994  : 				break;

  00256	eb 06		 jmp	 SHORT $LN2@VmAssemble
$LN16@VmAssemble:

; 995  : 			}
; 996  : 			default:
; 997  : 				*(PUCHAR)BuffOff = OpCode;

  00258	45 88 3e	 mov	 BYTE PTR [r14], r15b

; 998  : 				BuffOff++;

  0025b	49 ff c6	 inc	 r14
$LN2@VmAssemble:

; 839  : 		return NULL;
; 840  : 
; 841  : 	PUCHAR BuffOff = (PUCHAR)BuffBase;
; 842  : 
; 843  : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  0025e	48 8b 36	 mov	 rsi, QWORD PTR [rsi]
  00261	48 85 f6	 test	 rsi, rsi
  00264	0f 85 16 fe ff
	ff		 jne	 $LL4@VmAssemble
  0026a	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  0026f	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
$LN3@VmAssemble:

; 999  : 			}
; 1000 : 
; 1001 : 		}
; 1002 : 	}
; 1003 : 
; 1004 : 	return BuffBase;

  00274	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  00279	49 8b c4	 mov	 rax, r12

; 1005 : }

  0027c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00280	41 5d		 pop	 r13
  00282	41 5c		 pop	 r12
  00284	5f		 pop	 rdi
  00285	5e		 pop	 rsi
  00286	5b		 pop	 rbx
  00287	c3		 ret	 0
$LN102@VmAssemble:
  00288	00 00 00 00	 DD	 $LN9@VmAssemble
  0028c	00 00 00 00	 DD	 $LN10@VmAssemble
  00290	00 00 00 00	 DD	 $LN11@VmAssemble
  00294	00 00 00 00	 DD	 $LN12@VmAssemble
  00298	00 00 00 00	 DD	 $LN13@VmAssemble
  0029c	00 00 00 00	 DD	 $LN14@VmAssemble
  002a0	00 00 00 00	 DD	 $LN16@VmAssemble
$LN101@VmAssemble:
  002a4	00		 DB	 0
  002a5	01		 DB	 1
  002a6	02		 DB	 2
  002a7	03		 DB	 3
  002a8	00		 DB	 0
  002a9	00		 DB	 0
  002aa	00		 DB	 0
  002ab	01		 DB	 1
  002ac	01		 DB	 1
  002ad	02		 DB	 2
  002ae	00		 DB	 0
  002af	00		 DB	 0
  002b0	00		 DB	 0
  002b1	01		 DB	 1
  002b2	01		 DB	 1
  002b3	02		 DB	 2
  002b4	06		 DB	 6
  002b5	06		 DB	 6
  002b6	06		 DB	 6
  002b7	06		 DB	 6
  002b8	06		 DB	 6
  002b9	06		 DB	 6
  002ba	06		 DB	 6
  002bb	06		 DB	 6
  002bc	06		 DB	 6
  002bd	06		 DB	 6
  002be	06		 DB	 6
  002bf	06		 DB	 6
  002c0	06		 DB	 6
  002c1	06		 DB	 6
  002c2	06		 DB	 6
  002c3	06		 DB	 6
  002c4	06		 DB	 6
  002c5	06		 DB	 6
  002c6	06		 DB	 6
  002c7	06		 DB	 6
  002c8	04		 DB	 4
  002c9	04		 DB	 4
  002ca	04		 DB	 4
  002cb	04		 DB	 4
  002cc	04		 DB	 4
  002cd	04		 DB	 4
  002ce	04		 DB	 4
  002cf	04		 DB	 4
  002d0	06		 DB	 6
  002d1	06		 DB	 6
  002d2	06		 DB	 6
  002d3	06		 DB	 6
  002d4	06		 DB	 6
  002d5	06		 DB	 6
  002d6	06		 DB	 6
  002d7	06		 DB	 6
  002d8	06		 DB	 6
  002d9	06		 DB	 6
  002da	06		 DB	 6
  002db	06		 DB	 6
  002dc	06		 DB	 6
  002dd	06		 DB	 6
  002de	06		 DB	 6
  002df	06		 DB	 6
  002e0	06		 DB	 6
  002e1	06		 DB	 6
  002e2	06		 DB	 6
  002e3	06		 DB	 6
  002e4	06		 DB	 6
  002e5	06		 DB	 6
  002e6	06		 DB	 6
  002e7	06		 DB	 6
  002e8	06		 DB	 6
  002e9	06		 DB	 6
  002ea	06		 DB	 6
  002eb	06		 DB	 6
  002ec	06		 DB	 6
  002ed	06		 DB	 6
  002ee	06		 DB	 6
  002ef	06		 DB	 6
  002f0	06		 DB	 6
  002f1	06		 DB	 6
  002f2	06		 DB	 6
  002f3	06		 DB	 6
  002f4	06		 DB	 6
  002f5	06		 DB	 6
  002f6	06		 DB	 6
  002f7	06		 DB	 6
  002f8	06		 DB	 6
  002f9	06		 DB	 6
  002fa	06		 DB	 6
  002fb	06		 DB	 6
  002fc	06		 DB	 6
  002fd	05		 DB	 5
  002fe	05		 DB	 5
  002ff	05		 DB	 5
  00300	05		 DB	 5
  00301	05		 DB	 5
  00302	05		 DB	 5
  00303	05		 DB	 5
  00304	05		 DB	 5
  00305	06		 DB	 6
  00306	06		 DB	 6
  00307	01		 DB	 1
  00308	04		 DB	 4
  00309	04		 DB	 4
  0030a	04		 DB	 4
  0030b	04		 DB	 4
  0030c	06		 DB	 6
  0030d	06		 DB	 6
  0030e	06		 DB	 6
  0030f	06		 DB	 6
  00310	06		 DB	 6
  00311	06		 DB	 6
  00312	06		 DB	 6
  00313	06		 DB	 6
  00314	06		 DB	 6
  00315	06		 DB	 6
  00316	06		 DB	 6
  00317	06		 DB	 6
  00318	06		 DB	 6
  00319	06		 DB	 6
  0031a	06		 DB	 6
  0031b	03		 DB	 3
  0031c	03		 DB	 3
  0031d	03		 DB	 3
  0031e	03		 DB	 3
  0031f	03		 DB	 3
  00320	03		 DB	 3
  00321	03		 DB	 3
  00322	03		 DB	 3
  00323	01		 DB	 1
  00324	01		 DB	 1
  00325	01		 DB	 1
  00326	01		 DB	 1
  00327	01		 DB	 1
  00328	01		 DB	 1
  00329	01		 DB	 1
  0032a	01		 DB	 1
?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ENDP ; VmAssembleCodeToBuffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetJumpDelta@@YAHPEAU_CODE_LINK@@@Z
_TEXT	SEGMENT
Jmp$ = 48
?VmGetJumpDelta@@YAHPEAU_CODE_LINK@@@Z PROC		; VmGetJumpDelta, COMDAT

; 806  : {

$LN67:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 807  : 	//FIRST ITERATE AND CHECK BEHIND THE JMP
; 808  : 	PCODE_LINK Temp;
; 809  : 	LONGLONG Delta = 0;

  0000f	33 f6		 xor	 esi, esi
  00011	48 8b f9	 mov	 rdi, rcx

; 810  : 	for (Temp = Jmp; Temp && Temp->Prev; Temp = Temp->Prev)

  00014	48 8b d9	 mov	 rbx, rcx
  00017	48 85 c9	 test	 rcx, rcx
  0001a	74 6f		 je	 SHORT $LN3@VmGetJumpD
  0001c	0f 1f 40 00	 npad	 4
$LL4@VmGetJumpD:
  00020	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00024	48 85 db	 test	 rbx, rbx
  00027	74 62		 je	 SHORT $LN3@VmGetJumpD

; 812  : 		if (Temp->Prev->IsLabel && Temp->Prev->Name == Jmp->Name)

  00029	80 7b 10 00	 cmp	 BYTE PTR [rbx+16], 0
  0002d	74 32		 je	 SHORT $LN27@VmGetJumpD
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  0002f	48 83 7f 38 10	 cmp	 QWORD PTR [rdi+56], 16
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 812  : 		if (Temp->Prev->IsLabel && Temp->Prev->Name == Jmp->Name)

  00034	48 8d 57 20	 lea	 rdx, QWORD PTR [rdi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00038	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 812  : 		if (Temp->Prev->IsLabel && Temp->Prev->Name == Jmp->Name)

  0003c	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  00040	72 03		 jb	 SHORT $LN16@VmGetJumpD

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00042	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN16@VmGetJumpD:

; 2153 :         return _BUF_SIZE <= _Myres;

  00045	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004a	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2145 :         if (_Large_string_engaged()) {

  0004e	72 03		 jb	 SHORT $LN21@VmGetJumpD

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00050	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN21@VmGetJumpD:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00053	4c 3b c0	 cmp	 r8, rax
  00056	75 09		 jne	 SHORT $LN27@VmGetJumpD

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  00058	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0005d	85 c0		 test	 eax, eax
  0005f	74 11		 je	 SHORT $LN53@VmGetJumpD
$LN27@VmGetJumpD:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 817  : 		Delta -= VmGetInstructionLength(Temp->Prev->InstructionId);

  00061	0f b6 4b 11	 movzx	 ecx, BYTE PTR [rbx+17]
  00065	e8 00 00 00 00	 call	 ?VmGetInstructionLength@@YAHE@Z ; VmGetInstructionLength
  0006a	48 63 c8	 movsxd	 rcx, eax
  0006d	48 2b f1	 sub	 rsi, rcx
  00070	eb ae		 jmp	 SHORT $LL4@VmGetJumpD
$LN53@VmGetJumpD:

; 830  : 	}
; 831  : 
; 832  : 	return FALSE;
; 833  : }

  00072	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi
  00076	b8 01 00 00 00	 mov	 eax, 1
  0007b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
$LN3@VmGetJumpD:

; 818  : 	}
; 819  : 
; 820  : 	//NOW LOOK IN FRONT
; 821  : 	Delta = VmGetInstructionLength(Jmp->InstructionId); //9

  0008b	0f b6 4f 11	 movzx	 ecx, BYTE PTR [rdi+17]
  0008f	e8 00 00 00 00	 call	 ?VmGetInstructionLength@@YAHE@Z ; VmGetInstructionLength
  00094	48 63 f0	 movsxd	 rsi, eax

; 822  : 	for (Temp = Jmp; Temp && Temp->Next; Temp = Temp->Next)

  00097	48 8b df	 mov	 rbx, rdi
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL7@VmGetJumpD:
  000a0	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  000a3	48 85 db	 test	 rbx, rbx
  000a6	74 49		 je	 SHORT $LN6@VmGetJumpD

; 824  : 		if (Temp->Next->IsLabel && Temp->Next->Name == Jmp->Name)

  000a8	80 7b 10 00	 cmp	 BYTE PTR [rbx+16], 0
  000ac	74 32		 je	 SHORT $LN47@VmGetJumpD
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  000ae	48 83 7f 38 10	 cmp	 QWORD PTR [rdi+56], 16
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 824  : 		if (Temp->Next->IsLabel && Temp->Next->Name == Jmp->Name)

  000b3	48 8d 57 20	 lea	 rdx, QWORD PTR [rdi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  000b7	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 824  : 		if (Temp->Next->IsLabel && Temp->Next->Name == Jmp->Name)

  000bb	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  000bf	72 03		 jb	 SHORT $LN36@VmGetJumpD

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  000c1	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN36@VmGetJumpD:

; 2153 :         return _BUF_SIZE <= _Myres;

  000c4	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  000c9	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2145 :         if (_Large_string_engaged()) {

  000cd	72 03		 jb	 SHORT $LN41@VmGetJumpD

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  000cf	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN41@VmGetJumpD:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  000d2	4c 3b c0	 cmp	 r8, rax
  000d5	75 09		 jne	 SHORT $LN47@VmGetJumpD

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  000d7	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  000dc	85 c0		 test	 eax, eax
  000de	74 92		 je	 SHORT $LN53@VmGetJumpD
$LN47@VmGetJumpD:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 829  : 		Delta += VmGetInstructionLength(Temp->Next->InstructionId);

  000e0	0f b6 4b 11	 movzx	 ecx, BYTE PTR [rbx+17]
  000e4	e8 00 00 00 00	 call	 ?VmGetInstructionLength@@YAHE@Z ; VmGetInstructionLength
  000e9	48 63 c8	 movsxd	 rcx, eax
  000ec	48 03 f1	 add	 rsi, rcx
  000ef	eb af		 jmp	 SHORT $LL7@VmGetJumpD
$LN6@VmGetJumpD:

; 830  : 	}
; 831  : 
; 832  : 	return FALSE;
; 833  : }

  000f1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f6	33 c0		 xor	 eax, eax
  000f8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00101	5f		 pop	 rdi
  00102	c3		 ret	 0
?VmGetJumpDelta@@YAHPEAU_CODE_LINK@@@Z ENDP		; VmGetJumpDelta
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetVmSize@@YAKPEAU_VM_ASSEMBLER@@@Z
_TEXT	SEGMENT
Assembler$ = 8
?VmGetVmSize@@YAKPEAU_VM_ASSEMBLER@@@Z PROC		; VmGetVmSize, COMDAT

; 798  : 	ULONG Size = 0;
; 799  : 	for (PVM_INSTRUCTION Inst : Assembler->UsedInstructions)

  00000	4c 8b 81 18 28
	00 00		 mov	 r8, QWORD PTR [rcx+10264]
  00007	33 c0		 xor	 eax, eax
  00009	48 8b 89 10 28
	00 00		 mov	 rcx, QWORD PTR [rcx+10256]
  00010	49 3b c8	 cmp	 rcx, r8
  00013	74 1a		 je	 SHORT $LN10@VmGetVmSiz
  00015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@VmGetVmSiz:

; 800  : 	{
; 801  : 		Size += Inst->Size;

  00020	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00023	48 83 c1 08	 add	 rcx, 8
  00027	03 42 1c	 add	 eax, DWORD PTR [rdx+28]
  0002a	49 3b c8	 cmp	 rcx, r8
  0002d	75 f1		 jne	 SHORT $LL4@VmGetVmSiz
$LN10@VmGetVmSiz:

; 802  : 	}
; 803  : 	return Size;
; 804  : }

  0002f	c3		 ret	 0
?VmGetVmSize@@YAKPEAU_VM_ASSEMBLER@@@Z ENDP		; VmGetVmSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetCodeSize@@YAKPEAU_VM_ASSEMBLER@@@Z
_TEXT	SEGMENT
Assembler$ = 8
?VmGetCodeSize@@YAKPEAU_VM_ASSEMBLER@@@Z PROC		; VmGetCodeSize, COMDAT

; 788  : 	ULONG Size = 0;
; 789  : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	45 33 c0	 xor	 r8d, r8d
  00006	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 64		 je	 SHORT $LN22@VmGetCodeS
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
$LL4@VmGetCodeS:

; 790  : 	{
; 791  : 		if (!Link->IsLabel)

  00015	80 78 10 00	 cmp	 BYTE PTR [rax+16], 0
  00019	75 4f		 jne	 SHORT $LN2@VmGetCodeS

; 45   : 	switch (InstructionId)

  0001b	0f b6 48 11	 movzx	 ecx, BYTE PTR [rax+17]
  0001f	ff c9		 dec	 ecx
  00021	81 f9 88 00 00
	00		 cmp	 ecx, 136		; 00000088H
  00027	77 3c		 ja	 SHORT $LN8@VmGetCodeS
  00029	48 63 c9	 movsxd	 rcx, ecx
  0002c	41 0f b6 8c 09
	00 00 00 00	 movzx	 ecx, BYTE PTR $LN20@VmGetCodeS[r9+rcx]
  00035	41 8b 94 89 00
	00 00 00	 mov	 edx, DWORD PTR $LN21@VmGetCodeS[r9+rcx*4]
  0003d	49 03 d1	 add	 rdx, r9
  00040	ff e2		 jmp	 rdx
$LN10@VmGetCodeS:

; 46   : 	{
; 47   : 	case VMEXIT:
; 48   : 	case NOP:
; 49   : 
; 50   : 	case LDAB:
; 51   : 	case LDAW:
; 52   : 	case LDAD:
; 53   : 	case LDAQ:
; 54   : 
; 55   : 	case STAB:
; 56   : 	case STAW:
; 57   : 	case STAD:
; 58   : 	case STAQ:
; 59   : 
; 60   : 	case SXBW:
; 61   : 	case SXBD:
; 62   : 	case SXBQ:
; 63   : 	case SXWD:
; 64   : 	case SXWQ:
; 65   : 	case SXDQ:
; 66   : 
; 67   : 	case ZXBW:
; 68   : 	case ZXBD:
; 69   : 	case ZXBQ:
; 70   : 	case ZXWD:
; 71   : 	case ZXWQ:
; 72   : 	case ZXDQ:
; 73   : 
; 74   : 	case ADDB:
; 75   : 	case ADDW:
; 76   : 	case ADDD:
; 77   : 	case ADDQ:
; 78   : 
; 79   : 	case SUBB:
; 80   : 	case SUBW:
; 81   : 	case SUBD:
; 82   : 	case SUBQ:
; 83   : 
; 84   : 	case MULB:
; 85   : 	case MULW:
; 86   : 	case MULD:
; 87   : 	case MULQ:
; 88   : 
; 89   : 	case DIVB:
; 90   : 	case DIVW:
; 91   : 	case DIVD:
; 92   : 	case DIVQ:
; 93   : 
; 94   : 	case ANDB:
; 95   : 	case ANDW:
; 96   : 	case ANDD:
; 97   : 	case ANDQ:
; 98   : 
; 99   : 	case ORB:
; 100  : 	case ORW:
; 101  : 	case ORD:
; 102  : 	case ORQ:
; 103  : 
; 104  : 	case XORB:
; 105  : 	case XORW:
; 106  : 	case XORD:
; 107  : 	case XORQ:
; 108  : 
; 109  : 	case SHLB:
; 110  : 	case SHLW:
; 111  : 	case SHLD:
; 112  : 	case SHLQ:
; 113  : 
; 114  : 	case SHRB:
; 115  : 	case SHRW:
; 116  : 	case SHRD:
; 117  : 	case SHRQ:
; 118  : 	case CMPB:
; 119  : 	case CMPW:
; 120  : 	case CMPD:
; 121  : 	case CMPQ:
; 122  : 	case RET:
; 123  : 	case X86CALL:
; 124  : 	case SWAPB:
; 125  : 	case SWAPW:
; 126  : 	case SWAPD:
; 127  : 	case SWAPQ:
; 128  : 	case DECB:
; 129  : 	case DECW:
; 130  : 	case DECD:
; 131  : 	case DECQ:
; 132  : 	case INCB:
; 133  : 	case INCW:
; 134  : 	case INCD:
; 135  : 	case INCQ:
; 136  : 	case NPOPB:
; 137  : 	case NPOPW:
; 138  : 	case NPOPD:
; 139  : 	case NPOPQ:
; 140  : 	case SWAPBQ:
; 141  : 	case SWAPWQ:
; 142  : 	case SWAPDQ:
; 143  : 	case JMP:
; 144  : 	{
; 145  : 		return 1;

  00042	b9 01 00 00 00	 mov	 ecx, 1
  00047	eb 1e		 jmp	 SHORT $LN7@VmGetCodeS
$LN11@VmGetCodeS:

; 146  : 	}
; 147  : 	case LDIB:
; 148  : 	case PUSHB:
; 149  : 	case PUSHW:
; 150  : 	case PUSHD:
; 151  : 	case PUSHQ:
; 152  : 	case POPB:
; 153  : 	case POPW:
; 154  : 	case POPD:
; 155  : 	case POPQ:
; 156  : 	case STSP:
; 157  : 	case LDSP:
; 158  : 	case STIP:
; 159  : 	case LDIP:
; 160  : 	case LDIBSXW:
; 161  : 	case LDIBSXD:
; 162  : 	case LDIBSXQ:
; 163  : 	case LDIBZXW:
; 164  : 	case LDIBZXD:
; 165  : 	case LDIBZXQ:
; 166  : 	{
; 167  : 		return 2;

  00049	b9 02 00 00 00	 mov	 ecx, 2
  0004e	eb 17		 jmp	 SHORT $LN7@VmGetCodeS
$LN12@VmGetCodeS:

; 168  : 	}
; 169  : 	case LDIW:
; 170  : 	case EDITSP:
; 171  : 	case LDIWSXD:
; 172  : 	case LDIWSXQ:
; 173  : 	case LDIWZXD:
; 174  : 	case LDIWZXQ:
; 175  : 	case LDBPB:
; 176  : 	case LDBPW:
; 177  : 	case LDBPD:
; 178  : 	case LDBPQ:
; 179  : 	case STBPB:
; 180  : 	case STBPW:
; 181  : 	case STBPD:
; 182  : 	case STBPQ:
; 183  : 	{
; 184  : 		return 3;

  00050	b9 03 00 00 00	 mov	 ecx, 3
  00055	eb 10		 jmp	 SHORT $LN7@VmGetCodeS
$LN13@VmGetCodeS:

; 185  : 	}
; 186  : 	case LDID:
; 187  : 	case LDIDSXQ:
; 188  : 	case LDIDZXQ:
; 189  : 	{
; 190  : 		return 5;

  00057	b9 05 00 00 00	 mov	 ecx, 5
  0005c	eb 09		 jmp	 SHORT $LN7@VmGetCodeS
$LN14@VmGetCodeS:

; 191  : 	}
; 192  : 	case LDIQ:
; 193  : 	case JMPI:
; 194  : 	case JL:
; 195  : 	case JLE:
; 196  : 	case JG:
; 197  : 	case JGE:
; 198  : 	case JZ:
; 199  : 	case JNZ:
; 200  : 	case CALL:
; 201  : 	case LDSB:
; 202  : 	case LDSW:
; 203  : 	case LDSD:
; 204  : 	case LDSQ:
; 205  : 	case STSB:
; 206  : 	case STSW:
; 207  : 	case STSD:
; 208  : 	case STSQ:
; 209  : 	{
; 210  : 		return 9;

  0005e	b9 09 00 00 00	 mov	 ecx, 9
  00063	eb 02		 jmp	 SHORT $LN7@VmGetCodeS
$LN8@VmGetCodeS:

; 211  : 	}
; 212  : 
; 213  : 	}
; 214  : 	return 0;

  00065	33 c9		 xor	 ecx, ecx
$LN7@VmGetCodeS:

; 792  : 			Size += VmGetInstructionLength(Link->InstructionId);

  00067	44 03 c1	 add	 r8d, ecx
$LN2@VmGetCodeS:

; 788  : 	ULONG Size = 0;
; 789  : 	for (PCODE_LINK Link = Assembler->CodeStart->Next; Link; Link = Link->Next)

  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006d	48 85 c0	 test	 rax, rax
  00070	75 a3		 jne	 SHORT $LL4@VmGetCodeS
$LN22@VmGetCodeS:

; 793  : 	}
; 794  : 	return Size;
; 795  : }

  00072	41 8b c0	 mov	 eax, r8d
  00075	c3		 ret	 0
  00076	66 90		 npad	 2
$LN21@VmGetCodeS:
  00078	00 00 00 00	 DD	 $LN10@VmGetCodeS
  0007c	00 00 00 00	 DD	 $LN11@VmGetCodeS
  00080	00 00 00 00	 DD	 $LN12@VmGetCodeS
  00084	00 00 00 00	 DD	 $LN13@VmGetCodeS
  00088	00 00 00 00	 DD	 $LN14@VmGetCodeS
$LN20@VmGetCodeS:
  0008c	00		 DB	 0
  0008d	00		 DB	 0
  0008e	01		 DB	 1
  0008f	02		 DB	 2
  00090	03		 DB	 3
  00091	04		 DB	 4
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	02		 DB	 2
  00096	02		 DB	 2
  00097	03		 DB	 3
  00098	01		 DB	 1
  00099	01		 DB	 1
  0009a	01		 DB	 1
  0009b	02		 DB	 2
  0009c	02		 DB	 2
  0009d	03		 DB	 3
  0009e	00		 DB	 0
  0009f	00		 DB	 0
  000a0	00		 DB	 0
  000a1	00		 DB	 0
  000a2	00		 DB	 0
  000a3	00		 DB	 0
  000a4	00		 DB	 0
  000a5	00		 DB	 0
  000a6	00		 DB	 0
  000a7	00		 DB	 0
  000a8	00		 DB	 0
  000a9	00		 DB	 0
  000aa	00		 DB	 0
  000ab	00		 DB	 0
  000ac	00		 DB	 0
  000ad	00		 DB	 0
  000ae	00		 DB	 0
  000af	00		 DB	 0
  000b0	00		 DB	 0
  000b1	00		 DB	 0
  000b2	01		 DB	 1
  000b3	01		 DB	 1
  000b4	01		 DB	 1
  000b5	01		 DB	 1
  000b6	01		 DB	 1
  000b7	01		 DB	 1
  000b8	01		 DB	 1
  000b9	01		 DB	 1
  000ba	00		 DB	 0
  000bb	00		 DB	 0
  000bc	00		 DB	 0
  000bd	00		 DB	 0
  000be	00		 DB	 0
  000bf	00		 DB	 0
  000c0	00		 DB	 0
  000c1	00		 DB	 0
  000c2	00		 DB	 0
  000c3	00		 DB	 0
  000c4	00		 DB	 0
  000c5	00		 DB	 0
  000c6	00		 DB	 0
  000c7	00		 DB	 0
  000c8	00		 DB	 0
  000c9	00		 DB	 0
  000ca	00		 DB	 0
  000cb	00		 DB	 0
  000cc	00		 DB	 0
  000cd	00		 DB	 0
  000ce	00		 DB	 0
  000cf	00		 DB	 0
  000d0	00		 DB	 0
  000d1	00		 DB	 0
  000d2	00		 DB	 0
  000d3	00		 DB	 0
  000d4	00		 DB	 0
  000d5	00		 DB	 0
  000d6	00		 DB	 0
  000d7	00		 DB	 0
  000d8	00		 DB	 0
  000d9	00		 DB	 0
  000da	00		 DB	 0
  000db	00		 DB	 0
  000dc	00		 DB	 0
  000dd	00		 DB	 0
  000de	00		 DB	 0
  000df	00		 DB	 0
  000e0	00		 DB	 0
  000e1	00		 DB	 0
  000e2	00		 DB	 0
  000e3	00		 DB	 0
  000e4	00		 DB	 0
  000e5	00		 DB	 0
  000e6	00		 DB	 0
  000e7	04		 DB	 4
  000e8	04		 DB	 4
  000e9	04		 DB	 4
  000ea	04		 DB	 4
  000eb	04		 DB	 4
  000ec	04		 DB	 4
  000ed	04		 DB	 4
  000ee	04		 DB	 4
  000ef	00		 DB	 0
  000f0	00		 DB	 0
  000f1	02		 DB	 2
  000f2	01		 DB	 1
  000f3	01		 DB	 1
  000f4	01		 DB	 1
  000f5	01		 DB	 1
  000f6	00		 DB	 0
  000f7	00		 DB	 0
  000f8	00		 DB	 0
  000f9	00		 DB	 0
  000fa	00		 DB	 0
  000fb	00		 DB	 0
  000fc	00		 DB	 0
  000fd	00		 DB	 0
  000fe	00		 DB	 0
  000ff	00		 DB	 0
  00100	00		 DB	 0
  00101	00		 DB	 0
  00102	00		 DB	 0
  00103	00		 DB	 0
  00104	00		 DB	 0
  00105	04		 DB	 4
  00106	04		 DB	 4
  00107	04		 DB	 4
  00108	04		 DB	 4
  00109	04		 DB	 4
  0010a	04		 DB	 4
  0010b	04		 DB	 4
  0010c	04		 DB	 4
  0010d	02		 DB	 2
  0010e	02		 DB	 2
  0010f	02		 DB	 2
  00110	02		 DB	 2
  00111	02		 DB	 2
  00112	02		 DB	 2
  00113	02		 DB	 2
  00114	02		 DB	 2
?VmGetCodeSize@@YAKPEAU_VM_ASSEMBLER@@@Z ENDP		; VmGetCodeSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
_RngFunc$3 = 48
g$4 = 80
__$ArrayPad$ = 5088
Assembler$ = 5152
?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z PROC	; VmGenerateRandomOpCodes, COMDAT

; 775  : {

$LN92:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	b8 f0 13 00 00	 mov	 eax, 5104		; 000013f0H
  00011	e8 00 00 00 00	 call	 __chkstk
  00016	48 2b e0	 sub	 rsp, rax
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 e0
	13 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 776  : 	Assembler->UsedInstructions.clear();

  0002b	48 8d b9 10 28
	00 00		 lea	 rdi, QWORD PTR [rcx+10256]
  00032	4c 8b f1	 mov	 r14, rcx
  00035	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00038	48 8d 71 28	 lea	 rsi, QWORD PTR [rcx+40]
  0003c	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  00040	48 8d 59 10	 lea	 rbx, QWORD PTR [rcx+16]
  00044	bd 00 01 00 00	 mov	 ebp, 256		; 00000100H
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@VmGenerate:

; 778  : 	{
; 779  : 		if (Assembler->Instructions[i].IsUsed)

  00050	80 3e 00	 cmp	 BYTE PTR [rsi], 0
  00053	74 2c		 je	 SHORT $LN2@VmGenerate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00055	49 8b 96 18 28
	00 00		 mov	 rdx, QWORD PTR [r14+10264]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 781  : 			Assembler->UsedInstructions.push_back(&Assembler->Instructions[i]);

  0005c	48 89 5c 24 28	 mov	 QWORD PTR $T2[rsp], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00061	49 3b 96 20 28
	00 00		 cmp	 rdx, QWORD PTR [r14+10272]
  00068	74 0a		 je	 SHORT $LN10@VmGenerate

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0006a	48 89 1a	 mov	 QWORD PTR [rdx], rbx

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  0006d	48 83 47 08 08	 add	 QWORD PTR [rdi+8], 8

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00072	eb 0d		 jmp	 SHORT $LN2@VmGenerate
$LN10@VmGenerate:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00074	4c 8d 44 24 28	 lea	 r8, QWORD PTR $T2[rsp]
  00079	48 8b cf	 mov	 rcx, rdi
  0007c	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@PEAU_VM_INSTRUCTION@@@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAAPEAPEAU_VM_INSTRUCTION@@QEAPEAU2@$$QEAPEAU2@@Z ; std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Emplace_reallocate<_VM_INSTRUCTION *>
$LN2@VmGenerate:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 777  : 	for (INT i = 0; i < 256; i++)

  00081	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00085	48 83 c6 28	 add	 rsi, 40			; 00000028H
  00089	48 83 ed 01	 sub	 rbp, 1
  0008d	75 c1		 jne	 SHORT $LL4@VmGenerate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0008f	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 763  : 	INT Increment = 256 / Assembler->UsedInstructions.size();

  00093	33 d2		 xor	 edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00095	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  00098	49 8b c8	 mov	 rcx, r8
  0009b	49 2b c9	 sub	 rcx, r9
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 763  : 	INT Increment = 256 / Assembler->UsedInstructions.size();

  0009e	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000a3	48 c1 f9 03	 sar	 rcx, 3
  000a7	33 f6		 xor	 esi, esi
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 763  : 	INT Increment = 256 / Assembler->UsedInstructions.size();

  000a9	48 f7 f1	 div	 rcx
  000ac	4c 8b f8	 mov	 r15, rax

; 764  : 	for (INT i = 0; i < Increment; i++)

  000af	85 c0		 test	 eax, eax
  000b1	0f 8e 2e 01 00
	00		 jle	 $LN16@VmGenerate
  000b7	4c 89 a4 24 28
	14 00 00	 mov	 QWORD PTR [rsp+5160], r12
  000bf	41 bc ff ff ff
	ff		 mov	 r12d, -1		; ffffffffH
  000c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL17@VmGenerate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000d0	4d 2b c1	 sub	 r8, r9
  000d3	49 c1 f8 03	 sar	 r8, 3
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 766  : 		INT FoldBase = Assembler->UsedInstructions.size() * i;

  000d7	44 0f af c6	 imul	 r8d, esi
  000db	41 8b e8	 mov	 ebp, r8d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 5041 :         return _Random_device();

  000de	e8 00 00 00 00	 call	 ?_Random_device@std@@YAIXZ ; std::_Random_device

; 1091 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  000e3	89 44 24 54	 mov	 DWORD PTR g$4[rsp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  000e7	b9 01 00 00 00	 mov	 ecx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 1080 :     explicit mersenne_twister(_Ty _X0, _Ty _Dxarg = _WMSK, _Ty _Fxarg = static_cast<_Ty>(1812433253)) : _Dxval(_Dxarg) {

  000ec	44 89 a4 24 d4
	13 00 00	 mov	 DWORD PTR g$4[rsp+4996], r12d
  000f4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL37@VmGenerate:

; 1093 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

  00100	8b d0		 mov	 edx, eax
  00102	c1 ea 1e	 shr	 edx, 30
  00105	33 d0		 xor	 edx, eax
  00107	69 c2 65 89 07
	6c		 imul	 eax, edx, 1812433253	; 6c078965H
  0010d	03 c1		 add	 eax, ecx
  0010f	89 44 8c 54	 mov	 DWORD PTR g$4[rsp+rcx*4+4], eax
  00113	48 ff c1	 inc	 rcx
  00116	48 81 f9 70 02
	00 00		 cmp	 rcx, 624		; 00000270H
  0011d	72 e1		 jb	 SHORT $LL37@VmGenerate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5744 :     explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {

  0011f	48 8d 44 24 50	 lea	 rax, QWORD PTR g$4[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 1096 :         this->_Idx = _Nx;

  00124	c7 44 24 50 70
	02 00 00	 mov	 DWORD PTR g$4[rsp], 624	; 00000270H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5744 :     explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {

  0012c	48 89 44 24 30	 mov	 QWORD PTR _RngFunc$3[rsp], rax
  00131	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00137	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0013e	66 90		 npad	 2
$LL56@VmGenerate:

; 5746 :             --_Bits;

  00140	49 ff c8	 dec	 r8
  00143	48 d1 e8	 shr	 rax, 1
  00146	49 3b c4	 cmp	 rax, r12
  00149	77 f5		 ja	 SHORT $LL56@VmGenerate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  0014b	49 8b 96 18 28
	00 00		 mov	 rdx, QWORD PTR [r14+10264]
  00152	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5746 :             --_Bits;

  00155	4c 89 44 24 38	 mov	 QWORD PTR _RngFunc$3[rsp+8], r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  0015a	4c 8d 44 24 30	 lea	 r8, QWORD PTR _RngFunc$3[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5745 :         for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {

  0015f	48 89 44 24 40	 mov	 QWORD PTR _RngFunc$3[rsp+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  00164	e8 00 00 00 00	 call	 ??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::_Rng_from_urng<__int64,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00169	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  0016d	33 db		 xor	 ebx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0016f	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  00172	49 8b c0	 mov	 rax, r8
  00175	49 2b c1	 sub	 rax, r9
  00178	48 c1 f8 03	 sar	 rax, 3
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  0017c	48 85 c0	 test	 rax, rax
  0017f	74 51		 je	 SHORT $LN15@VmGenerate
  00181	33 c9		 xor	 ecx, ecx
  00183	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL20@VmGenerate:

; 769  : 		{
; 770  : 			Assembler->UsedInstructions[j]->OpCodes.push_back(j + FoldBase);

  00190	49 8b 0c c9	 mov	 rcx, QWORD PTR [r9+rcx*8]
  00194	8d 04 2b	 lea	 eax, DWORD PTR [rbx+rbp]
  00197	88 44 24 20	 mov	 BYTE PTR $T1[rsp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0019b	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0019f	48 3b 51 10	 cmp	 rdx, QWORD PTR [rcx+16]
  001a3	74 08		 je	 SHORT $LN65@VmGenerate

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  001a5	88 02		 mov	 BYTE PTR [rdx], al

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  001a7	48 ff 41 08	 inc	 QWORD PTR [rcx+8]

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  001ab	eb 0a		 jmp	 SHORT $LN18@VmGenerate
$LN65@VmGenerate:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  001ad	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  001b2	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
$LN18@VmGenerate:

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001b7	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  001bb	ff c3		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001bd	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  001c0	49 8b c0	 mov	 rax, r8
  001c3	49 2b c1	 sub	 rax, r9
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  001c6	48 63 cb	 movsxd	 rcx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001c9	48 c1 f8 03	 sar	 rax, 3
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  001cd	48 3b c8	 cmp	 rcx, rax
  001d0	72 be		 jb	 SHORT $LL20@VmGenerate
$LN15@VmGenerate:

; 764  : 	for (INT i = 0; i < Increment; i++)

  001d2	ff c6		 inc	 esi
  001d4	41 3b f7	 cmp	 esi, r15d
  001d7	0f 8c f3 fe ff
	ff		 jl	 $LL17@VmGenerate
  001dd	4c 8b a4 24 28
	14 00 00	 mov	 r12, QWORD PTR [rsp+5160]
$LN16@VmGenerate:

; 782  : 		}
; 783  : 	}
; 784  : 	VmFoldTable(Assembler);
; 785  : }

  001e5	48 8b 8c 24 e0
	13 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001ed	48 33 cc	 xor	 rcx, rsp
  001f0	e8 00 00 00 00	 call	 __security_check_cookie
  001f5	48 8b 9c 24 30
	14 00 00	 mov	 rbx, QWORD PTR [rsp+5168]
  001fd	48 81 c4 f0 13
	00 00		 add	 rsp, 5104		; 000013f0H
  00204	41 5f		 pop	 r15
  00206	41 5e		 pop	 r14
  00208	5f		 pop	 rdi
  00209	5e		 pop	 rsi
  0020a	5d		 pop	 rbp
  0020b	c3		 ret	 0
?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z ENDP	; VmGenerateRandomOpCodes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z
_TEXT	SEGMENT
$T1 = 32
_RngFunc$2 = 40
g$3 = 64
__$ArrayPad$ = 5072
Assembler$ = 5120
?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z PROC		; VmFoldTable, COMDAT

; 762  : {

$LN75:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	b8 e0 13 00 00	 mov	 eax, 5088		; 000013e0H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 d0
	13 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00024	4c 8b 89 18 28
	00 00		 mov	 r9, QWORD PTR [rcx+10264]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 763  : 	INT Increment = 256 / Assembler->UsedInstructions.size();

  0002b	33 d2		 xor	 edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0002d	4c 8b 91 10 28
	00 00		 mov	 r10, QWORD PTR [rcx+10256]
  00034	4d 8b c1	 mov	 r8, r9
  00037	4d 2b c2	 sub	 r8, r10
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 763  : 	INT Increment = 256 / Assembler->UsedInstructions.size();

  0003a	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0003f	49 c1 f8 03	 sar	 r8, 3
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 762  : {

  00043	33 f6		 xor	 esi, esi

; 763  : 	INT Increment = 256 / Assembler->UsedInstructions.size();

  00045	49 f7 f0	 div	 r8
  00048	48 8b f9	 mov	 rdi, rcx
  0004b	4c 8b f0	 mov	 r14, rax

; 764  : 	for (INT i = 0; i < Increment; i++)

  0004e	85 c0		 test	 eax, eax
  00050	0f 8e 56 01 00
	00		 jle	 $LN3@VmFoldTabl
  00056	48 89 9c 24 08
	14 00 00	 mov	 QWORD PTR [rsp+5128], rbx
  0005e	48 89 ac 24 10
	14 00 00	 mov	 QWORD PTR [rsp+5136], rbp
  00066	4c 89 bc 24 18
	14 00 00	 mov	 QWORD PTR [rsp+5144], r15
  0006e	41 bf ff ff ff
	ff		 mov	 r15d, -1		; ffffffffH
  00074	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@VmFoldTabl:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00080	4d 2b ca	 sub	 r9, r10
  00083	49 c1 f9 03	 sar	 r9, 3
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 766  : 		INT FoldBase = Assembler->UsedInstructions.size() * i;

  00087	44 0f af ce	 imul	 r9d, esi
  0008b	41 8b e9	 mov	 ebp, r9d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 5041 :         return _Random_device();

  0008e	e8 00 00 00 00	 call	 ?_Random_device@std@@YAIXZ ; std::_Random_device

; 1091 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00093	89 44 24 44	 mov	 DWORD PTR g$3[rsp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00097	b9 01 00 00 00	 mov	 ecx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 1080 :     explicit mersenne_twister(_Ty _X0, _Ty _Dxarg = _WMSK, _Ty _Fxarg = static_cast<_Ty>(1812433253)) : _Dxval(_Dxarg) {

  0009c	44 89 bc 24 c4
	13 00 00	 mov	 DWORD PTR g$3[rsp+4996], r15d
  000a4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL24@VmFoldTabl:

; 1093 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

  000b0	8b d0		 mov	 edx, eax
  000b2	c1 ea 1e	 shr	 edx, 30
  000b5	33 d0		 xor	 edx, eax
  000b7	69 c2 65 89 07
	6c		 imul	 eax, edx, 1812433253	; 6c078965H
  000bd	03 c1		 add	 eax, ecx
  000bf	89 44 8c 44	 mov	 DWORD PTR g$3[rsp+rcx*4+4], eax
  000c3	48 ff c1	 inc	 rcx
  000c6	48 81 f9 70 02
	00 00		 cmp	 rcx, 624		; 00000270H
  000cd	72 e1		 jb	 SHORT $LL24@VmFoldTabl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5744 :     explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {

  000cf	48 8d 44 24 40	 lea	 rax, QWORD PTR g$3[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 1096 :         this->_Idx = _Nx;

  000d4	c7 44 24 40 70
	02 00 00	 mov	 DWORD PTR g$3[rsp], 624	; 00000270H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5744 :     explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {

  000dc	48 89 44 24 28	 mov	 QWORD PTR _RngFunc$2[rsp], rax
  000e1	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  000e7	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000ee	66 90		 npad	 2
$LL43@VmFoldTabl:

; 5746 :             --_Bits;

  000f0	49 ff c8	 dec	 r8
  000f3	48 d1 e8	 shr	 rax, 1
  000f6	49 3b c7	 cmp	 rax, r15
  000f9	77 f5		 ja	 SHORT $LL43@VmFoldTabl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  000fb	48 8b 97 18 28
	00 00		 mov	 rdx, QWORD PTR [rdi+10264]
  00102	48 8b 8f 10 28
	00 00		 mov	 rcx, QWORD PTR [rdi+10256]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5746 :             --_Bits;

  00109	4c 89 44 24 30	 mov	 QWORD PTR _RngFunc$2[rsp+8], r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  0010e	4c 8d 44 24 28	 lea	 r8, QWORD PTR _RngFunc$2[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5745 :         for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {

  00113	48 89 44 24 38	 mov	 QWORD PTR _RngFunc$2[rsp+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  00118	e8 00 00 00 00	 call	 ??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::_Rng_from_urng<__int64,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0011d	4c 8b 8f 18 28
	00 00		 mov	 r9, QWORD PTR [rdi+10264]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  00124	33 db		 xor	 ebx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00126	4c 8b 97 10 28
	00 00		 mov	 r10, QWORD PTR [rdi+10256]
  0012d	49 8b c1	 mov	 rax, r9
  00130	49 2b c2	 sub	 rax, r10
  00133	48 c1 f8 03	 sar	 rax, 3
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  00137	48 85 c0	 test	 rax, rax
  0013a	74 4d		 je	 SHORT $LN2@VmFoldTabl
  0013c	33 c9		 xor	 ecx, ecx
  0013e	66 90		 npad	 2
$LL7@VmFoldTabl:

; 769  : 		{
; 770  : 			Assembler->UsedInstructions[j]->OpCodes.push_back(j + FoldBase);

  00140	49 8b 0c ca	 mov	 rcx, QWORD PTR [r10+rcx*8]
  00144	8d 04 2b	 lea	 eax, DWORD PTR [rbx+rbp]
  00147	88 44 24 20	 mov	 BYTE PTR $T1[rsp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0014b	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0014f	48 3b 51 10	 cmp	 rdx, QWORD PTR [rcx+16]
  00153	74 08		 je	 SHORT $LN52@VmFoldTabl

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00155	88 02		 mov	 BYTE PTR [rdx], al

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  00157	48 ff 41 08	 inc	 QWORD PTR [rcx+8]

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0015b	eb 0a		 jmp	 SHORT $LN5@VmFoldTabl
$LN52@VmFoldTabl:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0015d	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  00162	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
$LN5@VmFoldTabl:

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00167	4c 8b 8f 18 28
	00 00		 mov	 r9, QWORD PTR [rdi+10264]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  0016e	ff c3		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00170	4c 8b 97 10 28
	00 00		 mov	 r10, QWORD PTR [rdi+10256]
  00177	49 8b c1	 mov	 rax, r9
  0017a	49 2b c2	 sub	 rax, r10
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  0017d	48 63 cb	 movsxd	 rcx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00180	48 c1 f8 03	 sar	 rax, 3
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 768  : 		for (INT j = 0; j < Assembler->UsedInstructions.size(); j++)

  00184	48 3b c8	 cmp	 rcx, rax
  00187	72 b7		 jb	 SHORT $LL7@VmFoldTabl
$LN2@VmFoldTabl:

; 764  : 	for (INT i = 0; i < Increment; i++)

  00189	ff c6		 inc	 esi
  0018b	41 3b f6	 cmp	 esi, r14d
  0018e	0f 8c ec fe ff
	ff		 jl	 $LL4@VmFoldTabl
  00194	4c 8b bc 24 18
	14 00 00	 mov	 r15, QWORD PTR [rsp+5144]
  0019c	48 8b ac 24 10
	14 00 00	 mov	 rbp, QWORD PTR [rsp+5136]
  001a4	48 8b 9c 24 08
	14 00 00	 mov	 rbx, QWORD PTR [rsp+5128]
$LN3@VmFoldTabl:

; 771  : 		}
; 772  : 	}
; 773  : }

  001ac	48 8b 8c 24 d0
	13 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b4	48 33 cc	 xor	 rcx, rsp
  001b7	e8 00 00 00 00	 call	 __security_check_cookie
  001bc	48 81 c4 e0 13
	00 00		 add	 rsp, 5088		; 000013e0H
  001c3	41 5e		 pop	 r14
  001c5	5f		 pop	 rdi
  001c6	5e		 pop	 rsi
  001c7	c3		 ret	 0
?VmFoldTable@@YAXPEAU_VM_ASSEMBLER@@@Z ENDP		; VmFoldTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z
_TEXT	SEGMENT
_RngFunc$1 = 32
g$ = 64
__$ArrayPad$ = 5072
Assembler$ = 5104
?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z PROC ; VmShuffleUsedHandlerOder, COMDAT

; 756  : {

$LN43:
  00000	40 53		 push	 rbx
  00002	b8 e0 13 00 00	 mov	 eax, 5088		; 000013e0H
  00007	e8 00 00 00 00	 call	 __chkstk
  0000c	48 2b e0	 sub	 rsp, rax
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 84 24 d0
	13 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00021	48 8b d9	 mov	 rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 5041 :         return _Random_device();

  00024	e8 00 00 00 00	 call	 ?_Random_device@std@@YAIXZ ; std::_Random_device

; 1080 :     explicit mersenne_twister(_Ty _X0, _Ty _Dxarg = _WMSK, _Ty _Fxarg = static_cast<_Ty>(1812433253)) : _Dxval(_Dxarg) {

  00029	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH

; 1091 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  0002e	89 44 24 44	 mov	 DWORD PTR g$[rsp+4], eax

; 1080 :     explicit mersenne_twister(_Ty _X0, _Ty _Dxarg = _WMSK, _Ty _Fxarg = static_cast<_Ty>(1812433253)) : _Dxval(_Dxarg) {

  00032	89 8c 24 c4 13
	00 00		 mov	 DWORD PTR g$[rsp+4996], ecx

; 5041 :         return _Random_device();

  00039	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003f	90		 npad	 1
$LL12@VmShuffleU:

; 1093 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

  00040	8b d0		 mov	 edx, eax
  00042	c1 ea 1e	 shr	 edx, 30
  00045	33 d0		 xor	 edx, eax
  00047	69 c2 65 89 07
	6c		 imul	 eax, edx, 1812433253	; 6c078965H
  0004d	41 03 c0	 add	 eax, r8d
  00050	42 89 44 84 44	 mov	 DWORD PTR g$[rsp+r8*4+4], eax
  00055	49 ff c0	 inc	 r8
  00058	49 81 f8 70 02
	00 00		 cmp	 r8, 624			; 00000270H
  0005f	72 df		 jb	 SHORT $LL12@VmShuffleU
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5744 :     explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {

  00061	48 8d 44 24 40	 lea	 rax, QWORD PTR g$[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\random

; 1096 :         this->_Idx = _Nx;

  00066	c7 44 24 40 70
	02 00 00	 mov	 DWORD PTR g$[rsp], 624	; 00000270H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5744 :     explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {

  0006e	48 89 44 24 20	 mov	 QWORD PTR _RngFunc$1[rsp], rax
  00073	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00079	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LL31@VmShuffleU:

; 5746 :             --_Bits;

  00080	49 ff c8	 dec	 r8
  00083	48 d1 e8	 shr	 rax, 1
  00086	48 3b c1	 cmp	 rax, rcx
  00089	77 f5		 ja	 SHORT $LL31@VmShuffleU
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  0008b	48 8b 93 18 28
	00 00		 mov	 rdx, QWORD PTR [rbx+10264]
  00092	48 8b 8b 10 28
	00 00		 mov	 rcx, QWORD PTR [rbx+10256]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5746 :             --_Bits;

  00099	4c 89 44 24 28	 mov	 QWORD PTR _RngFunc$1[rsp+8], r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  0009e	4c 8d 44 24 20	 lea	 r8, QWORD PTR _RngFunc$1[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility

; 5745 :         for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {

  000a3	48 89 44 24 30	 mov	 QWORD PTR _RngFunc$1[rsp+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2857 :     _Random_shuffle1(_First, _Last, _RngFunc);

  000a8	e8 00 00 00 00	 call	 ??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@std@@V?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAU_VM_INSTRUCTION@@@std@@@std@@@0@0AEAV?$_Rng_from_urng@_JV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@0@@Z ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_VM_INSTRUCTION *> > >,std::_Rng_from_urng<__int64,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> > >
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 760  : }

  000ad	48 8b 8c 24 d0
	13 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b5	48 33 cc	 xor	 rcx, rsp
  000b8	e8 00 00 00 00	 call	 __security_check_cookie
  000bd	48 81 c4 e0 13
	00 00		 add	 rsp, 5088		; 000013e0H
  000c4	5b		 pop	 rbx
  000c5	c3		 ret	 0
?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z ENDP ; VmShuffleUsedHandlerOder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z
_TEXT	SEGMENT
Assembler$ = 48
?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z PROC	; VmAppendJumpsToUsed, COMDAT

; 738  : {

$LN18:
  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 739  : 	for (PVM_INSTRUCTION Instruction : Assembler->UsedInstructions)

  0000a	48 8b b9 10 28
	00 00		 mov	 rdi, QWORD PTR [rcx+10256]
  00011	48 8b b1 18 28
	00 00		 mov	 rsi, QWORD PTR [rcx+10264]
  00018	48 3b fe	 cmp	 rdi, rsi
  0001b	74 79		 je	 SHORT $LN13@VmAppendJu
  0001d	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00022	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00027	48 bd 48 0f b6
	02 41 ff 24 c0	 mov	 rbp, -4601272264582361272 ; c024ff4102b60f48H
  00031	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  00036	49 c7 c6 ff ff
	ff ff		 mov	 r14, -1
  0003d	0f 1f 00	 npad	 3
$LL4@VmAppendJu:
  00040	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 740  : 	{
; 741  : 		if (Instruction->Code)

  00043	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00047	48 85 c9	 test	 rcx, rcx
  0004a	74 24		 je	 SHORT $LN2@VmAppendJu

; 742  : 		{
; 743  : 			PVOID T = realloc(Instruction->Code, Instruction->Size + 8);

  0004c	8b 53 1c	 mov	 edx, DWORD PTR [rbx+28]
  0004f	83 c2 08	 add	 edx, 8
  00052	49 0f 42 d6	 cmovb	 rdx, r14
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc

; 744  : 			if (!T)

  0005c	48 85 c0	 test	 rax, rax
  0005f	74 1a		 je	 SHORT $LN9@VmAppendJu

; 747  : 				return;
; 748  : 			}
; 749  : 			Instruction->Code = T;
; 750  : 			*(PVOID*)((PUCHAR)Instruction->Code + Instruction->Size) = (PVOID)INSTRUCTION_JMP_NUMBER_R;

  00061	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  00064	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00068	48 89 2c 01	 mov	 QWORD PTR [rcx+rax], rbp

; 751  : 			Instruction->Size = Instruction->Size + 8;

  0006c	83 43 1c 08	 add	 DWORD PTR [rbx+28], 8
$LN2@VmAppendJu:

; 739  : 	for (PVM_INSTRUCTION Instruction : Assembler->UsedInstructions)

  00070	48 83 c7 08	 add	 rdi, 8
  00074	48 3b fe	 cmp	 rdi, rsi
  00077	75 c7		 jne	 SHORT $LL4@VmAppendJu
  00079	eb 0c		 jmp	 SHORT $LN16@VmAppendJu
$LN9@VmAppendJu:

; 745  : 			{
; 746  : 				printf("Ur out of memory son.\n");

  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@MGKFCHMA@Ur?5out?5of?5memory?5son?4?6@
  00082	e8 00 00 00 00	 call	 printf
$LN16@VmAppendJu:
  00087	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$LN13@VmAppendJu:

; 752  : 		}
; 753  : 	}
; 754  : }

  00096	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z ENDP	; VmAppendJumpsToUsed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; VmLoadFile, COMDAT

; 692  : {

$LN616:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 8d ac 24 60
	ff ff ff	 lea	 rbp, QWORD PTR [rsp-160]
  0001a	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 85 98 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00032	48 8b da	 mov	 rbx, rdx
  00035	4c 8b f9	 mov	 r15, rcx
  00038	48 8d 41 28	 lea	 rax, QWORD PTR [rcx+40]
  0003c	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
$LL4@VmLoadFile:

; 694  : 		Assembler->Instructions[i].IsUsed = FALSE;

  00041	c6 00 00	 mov	 BYTE PTR [rax], 0

; 693  : 	for (INT i = 0; i < 256; i++)

  00044	48 8d 40 28	 lea	 rax, QWORD PTR [rax+40]
  00048	48 83 ea 01	 sub	 rdx, 1
  0004c	75 f3		 jne	 SHORT $LL4@VmLoadFile
  0004e	41 b8 10 01 00
	00		 mov	 r8d, 272		; 00000110H
  00054	48 8d 4c 24 50	 lea	 rcx, QWORD PTR InputFile$[rsp]
  00059	e8 00 00 00 00	 call	 memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  0005e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
  00063	72 03		 jb	 SHORT $LN41@VmLoadFile

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00065	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN41@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 817  :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

  00068	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00070	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00076	45 8d 41 c1	 lea	 r8d, QWORD PTR [r9-63]
  0007a	48 8b d3	 mov	 rdx, rbx
  0007d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR InputFile$[rsp]
  00082	e8 00 00 00 00	 call	 ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
  00087	48 8b 44 24 50	 mov	 rax, QWORD PTR InputFile$[rsp]
  0008c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00090	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00097	4c 89 64 0c 50	 mov	 QWORD PTR InputFile$[rsp+rcx], r12
  0009c	48 8b 44 24 50	 mov	 rax, QWORD PTR InputFile$[rsp]
  000a1	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000a5	8d 91 50 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-176]
  000ab	89 54 0c 4c	 mov	 DWORD PTR InputFile$[rsp+rcx-4], edx
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 697  : 	if (InputFile.fail())

  000af	48 8b 44 24 50	 mov	 rax, QWORD PTR InputFile$[rsp]
  000b4	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 303  :         return rdstate() & (ios_base::badbit | ios_base::failbit);

  000b8	f6 44 0c 60 06	 test	 BYTE PTR InputFile$[rsp+rcx+16], 6
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 697  : 	if (InputFile.fail())

  000bd	74 07		 je	 SHORT $LN17@VmLoadFile
  000bf	33 f6		 xor	 esi, esi
  000c1	e9 13 06 00 00	 jmp	 $LN32@VmLoadFile
$LN17@VmLoadFile:

; 700  : 	Assembler->CodeStart = new CODE_LINK;

  000c6	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000cb	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d0	33 f6		 xor	 esi, esi
  000d2	48 85 c0	 test	 rax, rax
  000d5	74 12		 je	 SHORT $LN25@VmLoadFile
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  000d7	48 89 70 30	 mov	 QWORD PTR [rax+48], rsi

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  000db	48 c7 40 38 0f
	00 00 00	 mov	 QWORD PTR [rax+56], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  000e3	40 88 70 20	 mov	 BYTE PTR [rax+32], sil
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 700  : 	Assembler->CodeStart = new CODE_LINK;

  000e7	eb 03		 jmp	 SHORT $LN26@VmLoadFile
$LN25@VmLoadFile:
  000e9	48 8b c6	 mov	 rax, rsi
$LN26@VmLoadFile:
  000ec	49 89 07	 mov	 QWORD PTR [r15], rax

; 701  : 	Assembler->CodeEnd = Assembler->CodeStart;

  000ef	49 89 47 08	 mov	 QWORD PTR [r15+8], rax

; 702  : 	Assembler->CodeStart->Data = (PVOID)0xDEADBEEF00000000;

  000f3	48 b9 00 00 00
	00 ef be ad de	 mov	 rcx, -2401053092612145152 ; deadbeef00000000H
  000fd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 703  : 	Assembler->CodeStart->Name = "THIS IS THE START XDDDDDD!!!!";

  00101	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  00104	48 83 c1 20	 add	 rcx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00108	41 b8 1d 00 00
	00		 mov	 r8d, 29
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@EBMDFMC@THIS?5IS?5THE?5START?5XDDDDDD?$CB?$CB?$CB?$CB@
  00115	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 704  : 	Assembler->CodeStart->Prev = Assembler->CodeStart->Next = NULL;

  0011a	49 8b 07	 mov	 rax, QWORD PTR [r15]
  0011d	48 89 30	 mov	 QWORD PTR [rax], rsi
  00120	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00123	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00127	48 89 75 70	 mov	 QWORD PTR Line$2[rbp-240], rsi

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0012b	48 c7 45 78 0f
	00 00 00	 mov	 QWORD PTR Line$2[rbp-232], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00133	c6 45 60 00	 mov	 BYTE PTR Line$2[rbp-256], 0
$LN451@VmLoadFile:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 708  : 		if (Line.length() < 1)

  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR InputFile$[rsp]
  0013c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00140	48 8d 44 24 50	 lea	 rax, QWORD PTR InputFile$[rsp]
  00145	b2 0a		 mov	 dl, 10
  00147	48 03 c8	 add	 rcx, rax
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  00150	44 0f b6 c0	 movzx	 r8d, al
  00154	48 8d 55 60	 lea	 rdx, QWORD PTR Line$2[rbp-256]
  00158	48 8d 4c 24 50	 lea	 rcx, QWORD PTR InputFile$[rsp]
  0015d	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00162	48 8b d0	 mov	 rdx, rax
  00165	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00168	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0016c	f6 44 11 10 06	 test	 BYTE PTR [rcx+rdx+16], 6
  00171	0f 85 f2 04 00
	00		 jne	 $LN593@VmLoadFile
  00177	48 8b 4d 70	 mov	 rcx, QWORD PTR Line$2[rbp-240]
  0017b	48 83 f9 01	 cmp	 rcx, 1
  0017f	72 b6		 jb	 SHORT $LN451@VmLoadFile

; 712  : 		for (i = 0; i < Line.length(); i++) if (Line[i] == ';') break; //REMOVE COMMENTS

  00181	44 8b ce	 mov	 r9d, esi
  00184	48 8b 55 78	 mov	 rdx, QWORD PTR Line$2[rbp-232]
  00188	4c 8b 45 60	 mov	 r8, QWORD PTR Line$2[rbp-256]
  0018c	48 85 c9	 test	 rcx, rcx
  0018f	74 21		 je	 SHORT $LN560@VmLoadFile
  00191	4c 8b d6	 mov	 r10, rsi
$LL10@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  00194	48 8d 45 60	 lea	 rax, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  00198	48 83 fa 10	 cmp	 rdx, 16
  0019c	49 0f 43 c0	 cmovae	 rax, r8
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 712  : 		for (i = 0; i < Line.length(); i++) if (Line[i] == ';') break; //REMOVE COMMENTS

  001a0	42 80 3c 10 3b	 cmp	 BYTE PTR [rax+r10], 59	; 0000003bH
  001a5	74 0b		 je	 SHORT $LN560@VmLoadFile
  001a7	41 ff c1	 inc	 r9d
  001aa	45 8b d1	 mov	 r10d, r9d
  001ad	4c 3b d1	 cmp	 r10, rcx
  001b0	72 e2		 jb	 SHORT $LL10@VmLoadFile
$LN560@VmLoadFile:

; 713  : 		while (Line.length() > i) Line.pop_back();

  001b2	45 8b d1	 mov	 r10d, r9d
  001b5	49 3b ca	 cmp	 rcx, r10
  001b8	76 2e		 jbe	 SHORT $LN554@VmLoadFile
  001ba	66 0f 1f 44 00
	00		 npad	 6
$LL11@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 3632 :         _Eos(_Old_size - 1);

  001c0	48 ff c9	 dec	 rcx

; 2135 :         value_type* _Result = _Bx._Buf;

  001c3	48 8d 45 60	 lea	 rax, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  001c7	48 83 fa 10	 cmp	 rdx, 16
  001cb	49 0f 43 c0	 cmovae	 rax, r8

; 4289 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  001cf	48 89 4d 70	 mov	 QWORD PTR Line$2[rbp-240], rcx
  001d3	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 713  : 		while (Line.length() > i) Line.pop_back();

  001d7	48 8b 4d 70	 mov	 rcx, QWORD PTR Line$2[rbp-240]
  001db	48 8b 55 78	 mov	 rdx, QWORD PTR Line$2[rbp-232]
  001df	4c 8b 45 60	 mov	 r8, QWORD PTR Line$2[rbp-256]
  001e3	49 3b ca	 cmp	 rcx, r10
  001e6	77 d8		 ja	 SHORT $LL11@VmLoadFile
$LN554@VmLoadFile:

; 714  : 		while (!Line.empty() && (Line[Line.length() - 1] == (CHAR)9 || Line[Line.length() - 1] == ' ')) Line.pop_back(); //remove whitespace

  001e8	48 85 c9	 test	 rcx, rcx
  001eb	0f 84 ff 00 00
	00		 je	 $LN16@VmLoadFile
$LL13@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  001f1	48 8d 45 60	 lea	 rax, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  001f5	48 83 fa 10	 cmp	 rdx, 16
  001f9	49 0f 43 c0	 cmovae	 rax, r8
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 714  : 		while (!Line.empty() && (Line[Line.length() - 1] == (CHAR)9 || Line[Line.length() - 1] == ' ')) Line.pop_back(); //remove whitespace

  001fd	80 7c 01 ff 09	 cmp	 BYTE PTR [rcx+rax-1], 9
  00202	74 13		 je	 SHORT $LN20@VmLoadFile
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  00204	48 8d 45 60	 lea	 rax, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  00208	48 83 fa 10	 cmp	 rdx, 16
  0020c	49 0f 43 c0	 cmovae	 rax, r8
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 714  : 		while (!Line.empty() && (Line[Line.length() - 1] == (CHAR)9 || Line[Line.length() - 1] == ' ')) Line.pop_back(); //remove whitespace

  00210	80 7c 01 ff 20	 cmp	 BYTE PTR [rcx+rax-1], 32 ; 00000020H
  00215	75 2e		 jne	 SHORT $LN555@VmLoadFile
$LN20@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 3632 :         _Eos(_Old_size - 1);

  00217	48 ff c9	 dec	 rcx

; 2135 :         value_type* _Result = _Bx._Buf;

  0021a	48 8d 45 60	 lea	 rax, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  0021e	48 83 fa 10	 cmp	 rdx, 16
  00222	49 0f 43 c0	 cmovae	 rax, r8

; 4289 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00226	48 89 4d 70	 mov	 QWORD PTR Line$2[rbp-240], rcx
  0022a	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 714  : 		while (!Line.empty() && (Line[Line.length() - 1] == (CHAR)9 || Line[Line.length() - 1] == ' ')) Line.pop_back(); //remove whitespace

  0022e	48 8b 4d 70	 mov	 rcx, QWORD PTR Line$2[rbp-240]
  00232	48 85 c9	 test	 rcx, rcx
  00235	0f 84 fc fe ff
	ff		 je	 $LN451@VmLoadFile
  0023b	48 8b 55 78	 mov	 rdx, QWORD PTR Line$2[rbp-232]
  0023f	4c 8b 45 60	 mov	 r8, QWORD PTR Line$2[rbp-256]
  00243	eb ac		 jmp	 SHORT $LL13@VmLoadFile
$LN555@VmLoadFile:

; 715  : 		while (!Line.empty() && !std::isalpha(Line[0])) Line.erase(Line.begin());

  00245	48 85 c9	 test	 rcx, rcx
  00248	0f 84 a2 00 00
	00		 je	 $LN16@VmLoadFile
  0024e	66 90		 npad	 2
$LL15@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  00250	48 8d 45 60	 lea	 rax, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  00254	48 83 fa 10	 cmp	 rdx, 16
  00258	49 0f 43 c0	 cmovae	 rax, r8
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 715  : 		while (!Line.empty() && !std::isalpha(Line[0])) Line.erase(Line.begin());

  0025c	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalpha
  00265	85 c0		 test	 eax, eax
  00267	75 7b		 jne	 SHORT $LN596@VmLoadFile
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  00269	4c 8d 4d 60	 lea	 r9, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  0026d	48 8b 4d 60	 mov	 rcx, QWORD PTR Line$2[rbp-256]
  00271	4c 8b 55 78	 mov	 r10, QWORD PTR Line$2[rbp-232]
  00275	49 83 fa 10	 cmp	 r10, 16
  00279	4c 0f 43 c9	 cmovae	 r9, rcx

; 2135 :         value_type* _Result = _Bx._Buf;

  0027d	48 8d 45 60	 lea	 rax, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  00281	48 0f 43 c1	 cmovae	 rax, rcx

; 3231 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());

  00285	4c 2b c8	 sub	 r9, rax

; 2157 :         if (_Mysize < _Off) {

  00288	4c 8b 45 70	 mov	 r8, QWORD PTR Line$2[rbp-240]
  0028c	4d 3b c1	 cmp	 r8, r9
  0028f	0f 82 b3 04 00
	00		 jb	 $LN561@VmLoadFile

; 2174 :         return (_STD min)(_Size, _Mysize - _Off);

  00295	49 8b c0	 mov	 rax, r8
  00298	49 2b c1	 sub	 rax, r9
  0029b	ba 01 00 00 00	 mov	 edx, 1
  002a0	48 3b c2	 cmp	 rax, rdx
  002a3	48 0f 42 d0	 cmovb	 rdx, rax

; 2135 :         value_type* _Result = _Bx._Buf;

  002a7	48 8d 45 60	 lea	 rax, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  002ab	49 83 fa 10	 cmp	 r10, 16
  002af	48 0f 43 c1	 cmovae	 rax, rcx

; 3220 :         _Elem* const _Erase_at    = _My_ptr + _Off;

  002b3	4a 8d 0c 08	 lea	 rcx, QWORD PTR [rax+r9]

; 3221 :         const size_type _New_size = _Old_size - _Count;

  002b7	4c 2b c2	 sub	 r8, rdx

; 3222 :         _Mypair._Myval2._Mysize   = _New_size;

  002ba	4c 89 45 70	 mov	 QWORD PTR Line$2[rbp-240], r8

; 3223 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  002be	4d 2b c1	 sub	 r8, r9
  002c1	49 ff c0	 inc	 r8
  002c4	48 03 d1	 add	 rdx, rcx

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  002c7	e8 00 00 00 00	 call	 memmove
  002cc	90		 npad	 1
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 715  : 		while (!Line.empty() && !std::isalpha(Line[0])) Line.erase(Line.begin());

  002cd	48 8b 4d 70	 mov	 rcx, QWORD PTR Line$2[rbp-240]
  002d1	48 8b 55 78	 mov	 rdx, QWORD PTR Line$2[rbp-232]
  002d5	4c 8b 45 60	 mov	 r8, QWORD PTR Line$2[rbp-256]
  002d9	48 85 c9	 test	 rcx, rcx
  002dc	0f 85 6e ff ff
	ff		 jne	 $LL15@VmLoadFile
  002e2	eb 0c		 jmp	 SHORT $LN16@VmLoadFile
$LN596@VmLoadFile:
  002e4	48 8b 55 78	 mov	 rdx, QWORD PTR Line$2[rbp-232]
  002e8	48 8b 4d 70	 mov	 rcx, QWORD PTR Line$2[rbp-240]
  002ec	4c 8b 45 60	 mov	 r8, QWORD PTR Line$2[rbp-256]
$LN16@VmLoadFile:

; 716  : 
; 717  : 		if (Line.length() < 1)

  002f0	48 83 f9 01	 cmp	 rcx, 1
  002f4	0f 82 3d fe ff
	ff		 jb	 $LN451@VmLoadFile
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2135 :         value_type* _Result = _Bx._Buf;

  002fa	48 8d 7d 60	 lea	 rdi, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  002fe	48 83 fa 10	 cmp	 rdx, 16
  00302	49 0f 43 f8	 cmovae	 rdi, r8

; 2135 :         value_type* _Result = _Bx._Buf;

  00306	4c 8d 75 60	 lea	 r14, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  0030a	4d 0f 43 f0	 cmovae	 r14, r8

; 3494 :         return iterator(

  0030e	4c 03 f1	 add	 r14, rcx

; 2135 :         value_type* _Result = _Bx._Buf;

  00311	48 8d 5d 60	 lea	 rbx, QWORD PTR Line$2[rbp-256]

; 2136 :         if (_Large_string_engaged()) {

  00315	48 83 fa 10	 cmp	 rdx, 16
  00319	49 0f 43 d8	 cmovae	 rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm

; 2215 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {

  0031d	49 3b de	 cmp	 rbx, r14
  00320	74 17		 je	 SHORT $LN231@VmLoadFile
  00322	48 2b fb	 sub	 rdi, rbx
$LL232@VmLoadFile:

; 2216 :         *_UDest = _Func(*_UFirst);

  00325	0f be 0b	 movsx	 ecx, BYTE PTR [rbx]
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  0032e	88 04 1f	 mov	 BYTE PTR [rdi+rbx], al

; 2215 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {

  00331	48 ff c3	 inc	 rbx
  00334	49 3b de	 cmp	 rbx, r14
  00337	75 ec		 jne	 SHORT $LL232@VmLoadFile
$LN231@VmLoadFile:
  00339	0f 57 c0	 xorps	 xmm0, xmm0
  0033c	33 c0		 xor	 eax, eax
  0033e	0f 11 85 80 00
	00 00		 movups	 XMMWORD PTR Tokens$3[rbp-256], xmm0
  00345	48 89 85 90 00
	00 00		 mov	 QWORD PTR Tokens$3[rbp-240], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  0034c	48 89 74 24 40	 mov	 QWORD PTR $T1[rsp+16], rsi

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00351	48 c7 44 24 48
	0f 00 00 00	 mov	 QWORD PTR $T1[rsp+24], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0035a	88 44 24 30	 mov	 BYTE PTR $T1[rsp], al

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0035e	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  00362	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5@
  00369	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0036e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00373	90		 npad	 1
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 722  : 		VECTOR<STRING> Tokens = VmTokenizeLine(Line, " ");

  00374	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T1[rsp]
  00379	48 8d 55 60	 lea	 rdx, QWORD PTR Line$2[rbp-256]
  0037d	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR Tokens$3[rbp-256]
  00384	e8 00 00 00 00	 call	 ?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; VmTokenizeLine
  00389	90		 npad	 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0038a	48 8b 54 24 48	 mov	 rdx, QWORD PTR $T1[rsp+24]
  0038f	48 83 fa 10	 cmp	 rdx, 16
  00393	72 32		 jb	 SHORT $LN262@VmLoadFile

; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00395	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00398	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
  0039d	48 8b c1	 mov	 rax, rcx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003a0	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  003a7	72 19		 jb	 SHORT $LN272@VmLoadFile

; 134  :     _Bytes += _Non_user_size;

  003a9	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003ad	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  003b1	48 2b c1	 sub	 rax, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003b4	48 83 c0 f8	 add	 rax, -8
  003b8	48 83 f8 1f	 cmp	 rax, 31
  003bc	0f 87 67 01 00
	00		 ja	 $LN269@VmLoadFile
$LN272@VmLoadFile:

; 221  :     ::operator delete(_Ptr, _Bytes);

  003c2	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN262@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  003c7	48 8b bd 88 00
	00 00		 mov	 rdi, QWORD PTR Tokens$3[rbp-248]
  003ce	48 8b c7	 mov	 rax, rdi
  003d1	48 8b 9d 80 00
	00 00		 mov	 rbx, QWORD PTR Tokens$3[rbp-256]
  003d8	48 2b c3	 sub	 rax, rbx
  003db	48 c1 f8 05	 sar	 rax, 5
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 724  : 		if (Tokens.size() < 1)

  003df	48 83 f8 01	 cmp	 rax, 1
  003e3	73 72		 jae	 SHORT $LN22@VmLoadFile
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  003e5	48 85 db	 test	 rbx, rbx
  003e8	0f 84 49 fd ff
	ff		 je	 $LN451@VmLoadFile

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  003ee	48 3b df	 cmp	 rbx, rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  003f1	0f 84 f2 00 00
	00		 je	 $LN457@VmLoadFile
  003f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL289@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00400	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00404	48 83 fa 10	 cmp	 rdx, 16
  00408	72 30		 jb	 SHORT $LN308@VmLoadFile

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0040a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0040d	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00410	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00417	72 1c		 jb	 SHORT $LN318@VmLoadFile

; 134  :     _Bytes += _Non_user_size;

  00419	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0041d	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00421	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00424	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00428	48 83 f8 1f	 cmp	 rax, 31
  0042c	0f 87 d2 01 00
	00		 ja	 $LN508@VmLoadFile

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00432	49 8b c8	 mov	 rcx, r8
$LN318@VmLoadFile:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00435	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN308@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  0043a	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0043e	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00446	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  00449	48 83 c3 20	 add	 rbx, 32			; 00000020H
  0044d	48 3b df	 cmp	 rbx, rdi
  00450	75 ae		 jne	 SHORT $LL289@VmLoadFile
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 725  : 			continue;

  00452	e9 8b 00 00 00	 jmp	 $LN612@VmLoadFile
$LN22@VmLoadFile:

; 726  : 
; 727  : 		if (!VmAddInstruction(Assembler, Tokens))

  00457	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR Tokens$3[rbp-256]
  0045e	49 8b cf	 mov	 rcx, r15
  00461	e8 00 00 00 00	 call	 ?VmAddInstruction@@YAHPEAU_VM_ASSEMBLER@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; VmAddInstruction
  00466	85 c0		 test	 eax, eax
  00468	0f 84 c2 00 00
	00		 je	 $LN562@VmLoadFile
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  0046e	48 8b 9d 80 00
	00 00		 mov	 rbx, QWORD PTR Tokens$3[rbp-256]
  00475	48 85 db	 test	 rbx, rbx
  00478	0f 84 b9 fc ff
	ff		 je	 $LN451@VmLoadFile

; 1694 :             _Destroy(_Myfirst, _Mylast);

  0047e	48 8b bd 88 00
	00 00		 mov	 rdi, QWORD PTR Tokens$3[rbp-248]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00485	48 3b df	 cmp	 rbx, rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  00488	74 5f		 je	 SHORT $LN457@VmLoadFile
  0048a	66 0f 1f 44 00
	00		 npad	 6
$LL458@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00490	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00494	48 83 fa 10	 cmp	 rdx, 16
  00498	72 30		 jb	 SHORT $LN477@VmLoadFile

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0049a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0049d	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  004a0	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  004a7	72 1c		 jb	 SHORT $LN487@VmLoadFile

; 134  :     _Bytes += _Non_user_size;

  004a9	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004ad	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  004b1	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004b4	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  004b8	48 83 f8 1f	 cmp	 rax, 31
  004bc	0f 87 42 01 00
	00		 ja	 $LN508@VmLoadFile

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  004c2	49 8b c8	 mov	 rcx, r8
$LN487@VmLoadFile:

; 221  :     ::operator delete(_Ptr, _Bytes);

  004c5	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN477@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  004ca	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  004ce	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  004d6	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  004d9	48 83 c3 20	 add	 rbx, 32			; 00000020H
  004dd	48 3b df	 cmp	 rbx, rdi
  004e0	75 ae		 jne	 SHORT $LL458@VmLoadFile
$LN612@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string

; 84   :     return getline(_STD move(_Istr), _Str, _Istr.widen('\n'));

  004e2	48 8b 9d 80 00
	00 00		 mov	 rbx, QWORD PTR Tokens$3[rbp-256]
$LN457@VmLoadFile:
  004e9	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR Tokens$3[rbp-240]
  004f0	48 2b d3	 sub	 rdx, rbx
  004f3	48 83 e2 e0	 and	 rdx, -32		; ffffffffffffffe0H
  004f7	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  004fe	48 8b c3	 mov	 rax, rbx
  00501	72 19		 jb	 SHORT $LN511@VmLoadFile
  00503	48 8b 5b f8	 mov	 rbx, QWORD PTR [rbx-8]
  00507	48 2b c3	 sub	 rax, rbx
  0050a	48 83 c2 27	 add	 rdx, 39			; 00000027H
  0050e	48 83 c0 f8	 add	 rax, -8
  00512	48 83 f8 1f	 cmp	 rax, 31
  00516	0f 87 e8 00 00
	00		 ja	 $LN508@VmLoadFile
$LN511@VmLoadFile:
  0051c	48 8b cb	 mov	 rcx, rbx
  0051f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 706  : 	for (STRING Line; std::getline(InputFile, Line); )

  00524	e9 0e fc ff ff	 jmp	 $LN451@VmLoadFile
$LN269@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00529	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0052f	cc		 int	 3
$LN562@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 976  :         if (!_Filebuffer.close()) {

  00530	48 8d 4c 24 60	 lea	 rcx, QWORD PTR InputFile$[rsp+16]
  00535	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  0053a	48 85 c0	 test	 rax, rax
  0053d	75 1f		 jne	 SHORT $LN347@VmLoadFile

; 977  :             _Myios::setstate(ios_base::failbit);

  0053f	48 8b 44 24 50	 mov	 rax, QWORD PTR InputFile$[rsp]
  00544	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00548	48 8d 44 24 50	 lea	 rax, QWORD PTR InputFile$[rsp]
  0054d	48 03 c8	 add	 rcx, rax
  00550	45 33 c0	 xor	 r8d, r8d
  00553	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  00557	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0055d	90		 npad	 1
$LN347@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  0055e	48 8b 9d 80 00
	00 00		 mov	 rbx, QWORD PTR Tokens$3[rbp-256]
  00565	48 85 db	 test	 rbx, rbx
  00568	0f 84 b7 00 00
	00		 je	 $LN352@VmLoadFile

; 1694 :             _Destroy(_Myfirst, _Mylast);

  0056e	48 8b bd 88 00
	00 00		 mov	 rdi, QWORD PTR Tokens$3[rbp-248]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00575	48 3b df	 cmp	 rbx, rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  00578	74 5b		 je	 SHORT $LN358@VmLoadFile
  0057a	66 0f 1f 44 00
	00		 npad	 6
$LL359@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00580	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00584	48 83 fa 10	 cmp	 rdx, 16
  00588	72 2c		 jb	 SHORT $LN378@VmLoadFile

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0058a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0058d	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00590	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00597	72 18		 jb	 SHORT $LN388@VmLoadFile

; 134  :     _Bytes += _Non_user_size;

  00599	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0059d	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  005a1	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005a4	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  005a8	48 83 f8 1f	 cmp	 rax, 31
  005ac	77 56		 ja	 SHORT $LN508@VmLoadFile

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  005ae	49 8b c8	 mov	 rcx, r8
$LN388@VmLoadFile:

; 221  :     ::operator delete(_Ptr, _Bytes);

  005b1	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN378@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  005b6	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  005ba	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  005c2	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 959  :         for (; _First != _Last; ++_First) {

  005c5	48 83 c3 20	 add	 rbx, 32			; 00000020H
  005c9	48 3b df	 cmp	 rbx, rdi
  005cc	75 b2		 jne	 SHORT $LL359@VmLoadFile
  005ce	48 8b 9d 80 00
	00 00		 mov	 rbx, QWORD PTR Tokens$3[rbp-256]
$LN358@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  005d5	48 8b 95 90 00
	00 00		 mov	 rdx, QWORD PTR Tokens$3[rbp-240]
  005dc	48 2b d3	 sub	 rdx, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005df	48 83 e2 e0	 and	 rdx, -32		; ffffffffffffffe0H
  005e3	48 8b c3	 mov	 rax, rbx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  005e6	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  005ed	72 1c		 jb	 SHORT $LN412@VmLoadFile

; 134  :     _Bytes += _Non_user_size;

  005ef	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005f3	48 8b 5b f8	 mov	 rbx, QWORD PTR [rbx-8]
  005f7	48 2b c3	 sub	 rax, rbx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005fa	48 83 c0 f8	 add	 rax, -8
  005fe	48 83 f8 1f	 cmp	 rax, 31
  00602	76 07		 jbe	 SHORT $LN412@VmLoadFile
$LN508@VmLoadFile:
  00604	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0060a	cc		 int	 3
$LN412@VmLoadFile:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0060b	48 8b cb	 mov	 rcx, rbx
  0060e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00613	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00616	f3 0f 7f 85 80
	00 00 00	 movdqu	 XMMWORD PTR Tokens$3[rbp-256], xmm0

; 1698 :             _Mylast  = pointer();
; 1699 :             _Myend   = pointer();

  0061e	48 89 b5 90 00
	00 00		 mov	 QWORD PTR Tokens$3[rbp-240], rsi
$LN352@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00625	48 8b 55 78	 mov	 rdx, QWORD PTR Line$2[rbp-232]
  00629	48 83 fa 10	 cmp	 rdx, 16
  0062d	0f 82 a6 00 00
	00		 jb	 $LN32@VmLoadFile

; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00633	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00636	48 8b 4d 60	 mov	 rcx, QWORD PTR Line$2[rbp-256]
  0063a	48 8b c1	 mov	 rax, rcx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0063d	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00644	72 1c		 jb	 SHORT $LN438@VmLoadFile

; 134  :     _Bytes += _Non_user_size;

  00646	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0064a	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0064e	48 2b c1	 sub	 rax, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00651	48 83 c0 f8	 add	 rax, -8
  00655	48 83 f8 1f	 cmp	 rax, 31
  00659	76 07		 jbe	 SHORT $LN438@VmLoadFile
  0065b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00661	cc		 int	 3
$LN438@VmLoadFile:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00662	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00667	eb 70		 jmp	 SHORT $LN32@VmLoadFile
$LN593@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00669	48 8b 55 78	 mov	 rdx, QWORD PTR Line$2[rbp-232]
  0066d	48 83 fa 10	 cmp	 rdx, 16
  00671	72 34		 jb	 SHORT $LN527@VmLoadFile

; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00673	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00676	48 8b 4d 60	 mov	 rcx, QWORD PTR Line$2[rbp-256]
  0067a	48 8b c1	 mov	 rax, rcx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0067d	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00684	72 1c		 jb	 SHORT $LN537@VmLoadFile

; 134  :     _Bytes += _Non_user_size;

  00686	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0068a	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0068e	48 2b c1	 sub	 rax, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00691	48 83 c0 f8	 add	 rax, -8
  00695	48 83 f8 1f	 cmp	 rax, 31
  00699	76 07		 jbe	 SHORT $LN537@VmLoadFile
  0069b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  006a1	cc		 int	 3
$LN537@VmLoadFile:

; 221  :     ::operator delete(_Ptr, _Bytes);

  006a2	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN527@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 976  :         if (!_Filebuffer.close()) {

  006a7	48 8d 4c 24 60	 lea	 rcx, QWORD PTR InputFile$[rsp+16]
  006ac	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  006b1	48 85 c0	 test	 rax, rax
  006b4	75 1e		 jne	 SHORT $LN543@VmLoadFile

; 977  :             _Myios::setstate(ios_base::failbit);

  006b6	48 8b 44 24 50	 mov	 rax, QWORD PTR InputFile$[rsp]
  006bb	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  006bf	48 8d 44 24 50	 lea	 rax, QWORD PTR InputFile$[rsp]
  006c4	48 03 c8	 add	 rcx, rax
  006c7	45 33 c0	 xor	 r8d, r8d
  006ca	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  006ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN543@VmLoadFile:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 735  : 	return TRUE;

  006d4	be 01 00 00 00	 mov	 esi, 1
$LN32@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream

; 944  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

  006d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR InputFile$[rsp]
  006de	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]
  006e2	4c 89 64 14 50	 mov	 QWORD PTR InputFile$[rsp+rdx], r12
  006e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR InputFile$[rsp]
  006ec	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]
  006f0	44 8d 82 50 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-176]
  006f7	44 89 44 14 4c	 mov	 DWORD PTR InputFile$[rsp+rdx-4], r8d
  006fc	48 8d 4c 24 60	 lea	 rcx, QWORD PTR InputFile$[rsp+16]
  00701	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00706	48 8d 4c 24 68	 lea	 rcx, QWORD PTR InputFile$[rsp+24]
  0070b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00711	48 8d 4d 00	 lea	 rcx, QWORD PTR InputFile$[rbp-80]
  00715	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 735  : 	return TRUE;

  0071b	8b c6		 mov	 eax, esi

; 736  : }

  0071d	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00724	48 33 cc	 xor	 rcx, rsp
  00727	e8 00 00 00 00	 call	 __security_check_cookie
  0072c	4c 8d 9c 24 a0
	01 00 00	 lea	 r11, QWORD PTR [rsp+416]
  00734	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  00738	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0073c	49 8b e3	 mov	 rsp, r11
  0073f	41 5f		 pop	 r15
  00741	41 5e		 pop	 r14
  00743	41 5c		 pop	 r12
  00745	5f		 pop	 rdi
  00746	5d		 pop	 rbp
  00747	c3		 ret	 0
$LN561@VmLoadFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2158 :             _Xran();

  00748	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  0074d	90		 npad	 1
$LN609@VmLoadFile:
?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; VmLoadFile
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?dtor$0@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `VmLoadFile'::`1'::dtor$0
  00000	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR InputFile$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$0@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `VmLoadFile'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?dtor$1@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `VmLoadFile'::`1'::dtor$1
  00000	48 8d 8a 60 01
	00 00		 lea	 rcx, QWORD PTR Line$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `VmLoadFile'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?dtor$2@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `VmLoadFile'::`1'::dtor$2
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `VmLoadFile'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?dtor$3@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `VmLoadFile'::`1'::dtor$3
  00000	48 8d 8a 80 01
	00 00		 lea	 rcx, QWORD PTR Tokens$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$3@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `VmLoadFile'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?dtor$0@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `VmLoadFile'::`1'::dtor$0
  00000	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR InputFile$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$0@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `VmLoadFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?dtor$1@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `VmLoadFile'::`1'::dtor$1
  00000	48 8d 8a 60 01
	00 00		 lea	 rcx, QWORD PTR Line$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `VmLoadFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?dtor$2@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `VmLoadFile'::`1'::dtor$2
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `VmLoadFile'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
InputFile$ = 80
Line$2 = 352
Tokens$3 = 384
__$ArrayPad$ = 408
Assembler$ = 464
Filepath$ = 472
?dtor$3@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `VmLoadFile'::`1'::dtor$3
  00000	48 8d 8a 80 01
	00 00		 lea	 rcx, QWORD PTR Tokens$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$3@?0??VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `VmLoadFile'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmAddInstruction@@YAHPEAU_VM_ASSEMBLER@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
Assembler$ = 80
Tokens$ = 88
?VmAddInstruction@@YAHPEAU_VM_ASSEMBLER@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; VmAddInstruction, COMDAT

; 577  : {

$LN165:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 56		 push	 r14
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000b	4c 8b e1	 mov	 r12, rcx
  0000e	4c 8b f2	 mov	 r14, rdx

; 578  : 	PCODE_LINK Link = new CODE_LINK;

  00011	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00016	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001b	48 8b d8	 mov	 rbx, rax
  0001e	48 85 c0	 test	 rax, rax
  00021	74 16		 je	 SHORT $LN16@VmAddInstr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00023	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0002b	48 c7 40 38 0f
	00 00 00	 mov	 QWORD PTR [rax+56], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00033	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 578  : 	PCODE_LINK Link = new CODE_LINK;

  00037	eb 02		 jmp	 SHORT $LN17@VmAddInstr
$LN16@VmAddInstr:
  00039	33 db		 xor	 ebx, ebx
$LN17@VmAddInstr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0003b	49 8b 36	 mov	 rsi, QWORD PTR [r14]
  0003e	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  00042	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00047	48 2b c6	 sub	 rax, rsi
  0004a	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 579  : 	if (Tokens.size() == 1 && Tokens[0][Tokens[0].length() - 1] == ':')

  0004f	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H
  00053	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00058	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0005d	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  00061	75 5f		 jne	 SHORT $LN157@VmAddInstr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00063	48 83 7e 18 10	 cmp	 QWORD PTR [rsi+24], 16

; 2144 :         const value_type* _Result = _Bx._Buf;

  00068	48 8b ce	 mov	 rcx, rsi
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 579  : 	if (Tokens.size() == 1 && Tokens[0][Tokens[0].length() - 1] == ':')

  0006b	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  0006f	72 03		 jb	 SHORT $LN158@VmAddInstr

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00071	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN158@VmAddInstr:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 579  : 	if (Tokens.size() == 1 && Tokens[0][Tokens[0].length() - 1] == ':')

  00074	80 7c 08 ff 3a	 cmp	 BYTE PTR [rax+rcx-1], 58 ; 0000003aH
  00079	75 47		 jne	 SHORT $LN157@VmAddInstr

; 580  : 	{
; 581  : 		Link->IsLabel = TRUE;

  0007b	c6 43 10 01	 mov	 BYTE PTR [rbx+16], 1

; 582  : 		Link->Name = Tokens[0];

  0007f	48 8d 7b 20	 lea	 rdi, QWORD PTR [rbx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  00083	49 8b 16	 mov	 rdx, QWORD PTR [r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2785 :         if (this != _STD addressof(_Right)) {

  00086	48 3b fa	 cmp	 rdi, rdx
  00089	74 16		 je	 SHORT $LN50@VmAddInstr

; 2153 :         return _BUF_SIZE <= _Myres;

  0008b	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 2750 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00090	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]

; 2145 :         if (_Large_string_engaged()) {

  00094	72 03		 jb	 SHORT $LN55@VmAddInstr

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00096	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN55@VmAddInstr:

; 2750 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00099	48 8b cf	 mov	 rcx, rdi
  0009c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN50@VmAddInstr:

; 3632 :         _Eos(_Old_size - 1);

  000a1	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  000a5	48 8d 4f 10	 lea	 rcx, QWORD PTR [rdi+16]
  000a9	48 ff c8	 dec	 rax

; 2153 :         return _BUF_SIZE <= _Myres;

  000ac	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 2136 :         if (_Large_string_engaged()) {

  000b1	72 03		 jb	 SHORT $LN64@VmAddInstr

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  000b3	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
$LN64@VmAddInstr:

; 4289 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  000b6	48 89 01	 mov	 QWORD PTR [rcx], rax
  000b9	c6 04 07 00	 mov	 BYTE PTR [rdi+rax], 0
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 584  : 	}

  000bd	e9 9d 01 00 00	 jmp	 $LN129@VmAddInstr
$LN157@VmAddInstr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  000c2	4c 8b 7e 18	 mov	 r15, QWORD PTR [rsi+24]

; 4096 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  000c6	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:__ImageBase
  000cd	48 8b 6e 10	 mov	 rbp, QWORD PTR [rsi+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 21   : 	for (INT i = 0; i < ARRAYSIZE(InstructionBindings); i++)

  000d1	33 ff		 xor	 edi, edi
$LL73@VmAddInstr:

; 22   : 	{
; 23   : 		if (Instruction == InstructionBindings[i])

  000d3	48 63 c7	 movsxd	 rax, edi
  000d6	49 8b 94 c5 00
	00 00 00	 mov	 rdx, QWORD PTR ?InstructionBindings@@3PAPEBDA[r13+rax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 318  :             return __builtin_strlen(_First);

  000de	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LL162@VmAddInstr:
  000e5	48 ff c0	 inc	 rax
  000e8	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  000ec	75 f7		 jne	 SHORT $LL162@VmAddInstr

; 2144 :         const value_type* _Result = _Bx._Buf;

  000ee	48 8b ce	 mov	 rcx, rsi

; 2153 :         return _BUF_SIZE <= _Myres;

  000f1	49 83 ff 10	 cmp	 r15, 16

; 2145 :         if (_Large_string_engaged()) {

  000f5	72 03		 jb	 SHORT $LN83@VmAddInstr

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  000f7	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN83@VmAddInstr:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  000fa	48 3b e8	 cmp	 rbp, rax
  000fd	75 0c		 jne	 SHORT $LN89@VmAddInstr

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  000ff	4c 8b c5	 mov	 r8, rbp
  00102	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00107	85 c0		 test	 eax, eax
  00109	74 3d		 je	 SHORT $LN140@VmAddInstr
$LN89@VmAddInstr:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 21   : 	for (INT i = 0; i < ARRAYSIZE(InstructionBindings); i++)

  0010b	ff c7		 inc	 edi
  0010d	81 ff 8a 00 00
	00		 cmp	 edi, 138		; 0000008aH
  00113	72 be		 jb	 SHORT $LL73@VmAddInstr

; 585  : 	else
; 586  : 	{
; 587  : 		UCHAR Iid;
; 588  : 		if (!VmGetInstructionId(Tokens[0], &Iid))
; 589  : 		{
; 590  : 			delete Link;

  00115	48 85 db	 test	 rbx, rbx
  00118	74 0d		 je	 SHORT $LN18@VmAddInstr
$LN105@VmAddInstr:

; 690  : }

  0011a	ba 01 00 00 00	 mov	 edx, 1
  0011f	48 8b cb	 mov	 rcx, rbx
  00122	e8 00 00 00 00	 call	 ??_G_CODE_LINK@@QEAAPEAXI@Z
$LN18@VmAddInstr:
  00127	33 c0		 xor	 eax, eax
$LN1@VmAddInstr:
  00129	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  0012e	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
  00133	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00138	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0013d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00141	41 5e		 pop	 r14
  00143	41 5c		 pop	 r12
  00145	5e		 pop	 rsi
  00146	5b		 pop	 rbx
  00147	c3		 ret	 0
$LN140@VmAddInstr:

; 591  : 			return FALSE;
; 592  : 		}
; 593  : 		Assembler->Instructions[Iid].IsUsed = TRUE;

  00148	40 0f b6 c7	 movzx	 eax, dil
  0014c	48 ff c0	 inc	 rax
  0014f	48 8d 04 80	 lea	 rax, QWORD PTR [rax+rax*4]
  00153	41 c6 04 c4 01	 mov	 BYTE PTR [r12+rax*8], 1

; 594  : 		Link->IsLabel = FALSE;
; 595  : 		Link->InstructionId = Iid;
; 596  : 
; 597  : 		switch (Iid)

  00158	40 0f b6 c7	 movzx	 eax, dil
  0015c	83 c0 fd	 add	 eax, -3
  0015f	c6 43 10 00	 mov	 BYTE PTR [rbx+16], 0
  00163	40 88 7b 11	 mov	 BYTE PTR [rbx+17], dil
  00167	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  0016c	0f 87 ed 00 00
	00		 ja	 $LN129@VmAddInstr
  00172	48 98		 cdqe
  00174	42 0f b6 84 28
	00 00 00 00	 movzx	 eax, BYTE PTR $LN160@VmAddInstr[rax+r13]
  0017d	41 8b 8c 85 00
	00 00 00	 mov	 ecx, DWORD PTR $LN161@VmAddInstr[r13+rax*4]
  00185	49 03 cd	 add	 rcx, r13
  00188	ff e1		 jmp	 rcx
$LN7@VmAddInstr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  0018a	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 607  : 			Link->Data = (PVOID)(CHAR)std::stoi(Tokens[1]);

  0018d	33 d2		 xor	 edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  0018f	48 83 c1 20	 add	 rcx, 32			; 00000020H
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 607  : 			Link->Data = (PVOID)(CHAR)std::stoi(Tokens[1]);

  00193	44 8d 42 0a	 lea	 r8d, QWORD PTR [rdx+10]
  00197	e8 00 00 00 00	 call	 ?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
  0019c	48 0f be c8	 movsx	 rcx, al
  001a0	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 608  : 			break;

  001a4	e9 b6 00 00 00	 jmp	 $LN129@VmAddInstr
$LN8@VmAddInstr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  001a9	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 625  : 			Link->Data = (PVOID)(SHORT)std::stoi(Tokens[1]);

  001ac	33 d2		 xor	 edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  001ae	48 83 c1 20	 add	 rcx, 32			; 00000020H
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 625  : 			Link->Data = (PVOID)(SHORT)std::stoi(Tokens[1]);

  001b2	44 8d 42 0a	 lea	 r8d, QWORD PTR [rdx+10]
  001b6	e8 00 00 00 00	 call	 ?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
  001bb	48 0f bf c8	 movsx	 rcx, ax
  001bf	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 626  : 			break;

  001c3	e9 97 00 00 00	 jmp	 $LN129@VmAddInstr
$LN9@VmAddInstr:

; 685  : 	Link->Prev = Assembler->CodeEnd;

  001c8	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  001cb	33 d2		 xor	 edx, edx
  001cd	48 83 c1 20	 add	 rcx, 32			; 00000020H
  001d1	44 8d 42 0a	 lea	 r8d, QWORD PTR [rdx+10]
  001d5	e8 00 00 00 00	 call	 ?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
  001da	48 63 c8	 movsxd	 rcx, eax
  001dd	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx
  001e1	eb 7c		 jmp	 SHORT $LN129@VmAddInstr
$LN11@VmAddInstr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  001e3	49 8b 36	 mov	 rsi, QWORD PTR [r14]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 33   : 	for (INT i = 0; i < ARRAYSIZE(RegisterBindings); i++)

  001e6	33 ff		 xor	 edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  001e8	4c 8b 76 38	 mov	 r14, QWORD PTR [rsi+56]

; 4096 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  001ec	48 8b 6e 30	 mov	 rbp, QWORD PTR [rsi+48]
$LL106@VmAddInstr:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 35   : 		if (Register == RegisterBindings[i])

  001f0	48 63 c7	 movsxd	 rax, edi
  001f3	49 8b 94 c5 00
	00 00 00	 mov	 rdx, QWORD PTR ?RegisterBindings@@3PAPEBDA[r13+rax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 318  :             return __builtin_strlen(_First);

  001fb	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LL159@VmAddInstr:
  00202	48 ff c0	 inc	 rax
  00205	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00209	75 f7		 jne	 SHORT $LL159@VmAddInstr

; 2144 :         const value_type* _Result = _Bx._Buf;

  0020b	48 8d 4e 20	 lea	 rcx, QWORD PTR [rsi+32]

; 2153 :         return _BUF_SIZE <= _Myres;

  0020f	49 83 fe 10	 cmp	 r14, 16

; 2145 :         if (_Large_string_engaged()) {

  00213	72 04		 jb	 SHORT $LN116@VmAddInstr

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00215	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
$LN116@VmAddInstr:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00219	48 3b e8	 cmp	 rbp, rax
  0021c	75 0c		 jne	 SHORT $LN122@VmAddInstr

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  0021e	4c 8b c5	 mov	 r8, rbp
  00221	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00226	85 c0		 test	 eax, eax
  00228	74 0c		 je	 SHORT $LN141@VmAddInstr
$LN122@VmAddInstr:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 33   : 	for (INT i = 0; i < ARRAYSIZE(RegisterBindings); i++)

  0022a	ff c7		 inc	 edi
  0022c	83 ff 20	 cmp	 edi, 32			; 00000020H
  0022f	72 bf		 jb	 SHORT $LL106@VmAddInstr
  00231	e9 e4 fe ff ff	 jmp	 $LN105@VmAddInstr
$LN141@VmAddInstr:

; 36   : 		{
; 37   : 			*Id = i;

  00236	40 88 7b 18	 mov	 BYTE PTR [rbx+24], dil

; 38   : 			return TRUE;

  0023a	eb 23		 jmp	 SHORT $LN129@VmAddInstr
$LN13@VmAddInstr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  0023c	49 8b 16	 mov	 rdx, QWORD PTR [r14]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 677  : 			Link->Name = Tokens[1];

  0023f	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  00243	48 83 c2 20	 add	 rdx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2785 :         if (this != _STD addressof(_Right)) {

  00247	48 3b ca	 cmp	 rcx, rdx
  0024a	74 13		 je	 SHORT $LN129@VmAddInstr

; 2153 :         return _BUF_SIZE <= _Myres;

  0024c	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 2750 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00251	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]

; 2145 :         if (_Large_string_engaged()) {

  00255	72 03		 jb	 SHORT $LN134@VmAddInstr

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00257	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN134@VmAddInstr:

; 2750 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0025a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN129@VmAddInstr:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 685  : 	Link->Prev = Assembler->CodeEnd;

  0025f	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  00264	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 686  : 	Link->Next = NULL;

  00268	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 687  : 	Assembler->CodeEnd->Next = Link;

  0026f	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  00274	48 89 18	 mov	 QWORD PTR [rax], rbx

; 688  : 	Assembler->CodeEnd = Link;
; 689  : 	return TRUE;

  00277	b8 01 00 00 00	 mov	 eax, 1
  0027c	49 89 5c 24 08	 mov	 QWORD PTR [r12+8], rbx
  00281	e9 a3 fe ff ff	 jmp	 $LN1@VmAddInstr
  00286	66 90		 npad	 2
$LN161@VmAddInstr:

; 690  : }

  00288	00 00 00 00	 DD	 $LN7@VmAddInstr
  0028c	00 00 00 00	 DD	 $LN8@VmAddInstr
  00290	00 00 00 00	 DD	 $LN9@VmAddInstr
  00294	00 00 00 00	 DD	 $LN11@VmAddInstr
  00298	00 00 00 00	 DD	 $LN13@VmAddInstr
  0029c	00 00 00 00	 DD	 $LN129@VmAddInstr
$LN160@VmAddInstr:
  002a0	00		 DB	 0
  002a1	01		 DB	 1
  002a2	02		 DB	 2
  002a3	02		 DB	 2
  002a4	00		 DB	 0
  002a5	00		 DB	 0
  002a6	00		 DB	 0
  002a7	01		 DB	 1
  002a8	01		 DB	 1
  002a9	02		 DB	 2
  002aa	00		 DB	 0
  002ab	00		 DB	 0
  002ac	00		 DB	 0
  002ad	01		 DB	 1
  002ae	01		 DB	 1
  002af	02		 DB	 2
  002b0	05		 DB	 5
  002b1	05		 DB	 5
  002b2	05		 DB	 5
  002b3	05		 DB	 5
  002b4	05		 DB	 5
  002b5	05		 DB	 5
  002b6	05		 DB	 5
  002b7	05		 DB	 5
  002b8	05		 DB	 5
  002b9	05		 DB	 5
  002ba	05		 DB	 5
  002bb	05		 DB	 5
  002bc	05		 DB	 5
  002bd	05		 DB	 5
  002be	05		 DB	 5
  002bf	05		 DB	 5
  002c0	05		 DB	 5
  002c1	05		 DB	 5
  002c2	05		 DB	 5
  002c3	05		 DB	 5
  002c4	03		 DB	 3
  002c5	03		 DB	 3
  002c6	03		 DB	 3
  002c7	03		 DB	 3
  002c8	03		 DB	 3
  002c9	03		 DB	 3
  002ca	03		 DB	 3
  002cb	03		 DB	 3
  002cc	05		 DB	 5
  002cd	05		 DB	 5
  002ce	05		 DB	 5
  002cf	05		 DB	 5
  002d0	05		 DB	 5
  002d1	05		 DB	 5
  002d2	05		 DB	 5
  002d3	05		 DB	 5
  002d4	05		 DB	 5
  002d5	05		 DB	 5
  002d6	05		 DB	 5
  002d7	05		 DB	 5
  002d8	05		 DB	 5
  002d9	05		 DB	 5
  002da	05		 DB	 5
  002db	05		 DB	 5
  002dc	05		 DB	 5
  002dd	05		 DB	 5
  002de	05		 DB	 5
  002df	05		 DB	 5
  002e0	05		 DB	 5
  002e1	05		 DB	 5
  002e2	05		 DB	 5
  002e3	05		 DB	 5
  002e4	05		 DB	 5
  002e5	05		 DB	 5
  002e6	05		 DB	 5
  002e7	05		 DB	 5
  002e8	05		 DB	 5
  002e9	05		 DB	 5
  002ea	05		 DB	 5
  002eb	05		 DB	 5
  002ec	05		 DB	 5
  002ed	05		 DB	 5
  002ee	05		 DB	 5
  002ef	05		 DB	 5
  002f0	05		 DB	 5
  002f1	05		 DB	 5
  002f2	05		 DB	 5
  002f3	05		 DB	 5
  002f4	05		 DB	 5
  002f5	05		 DB	 5
  002f6	05		 DB	 5
  002f7	05		 DB	 5
  002f8	05		 DB	 5
  002f9	04		 DB	 4
  002fa	04		 DB	 4
  002fb	04		 DB	 4
  002fc	04		 DB	 4
  002fd	04		 DB	 4
  002fe	04		 DB	 4
  002ff	04		 DB	 4
  00300	04		 DB	 4
  00301	05		 DB	 5
  00302	05		 DB	 5
  00303	01		 DB	 1
  00304	03		 DB	 3
  00305	03		 DB	 3
  00306	03		 DB	 3
  00307	03		 DB	 3
  00308	05		 DB	 5
  00309	05		 DB	 5
  0030a	05		 DB	 5
  0030b	05		 DB	 5
  0030c	05		 DB	 5
  0030d	05		 DB	 5
  0030e	05		 DB	 5
  0030f	05		 DB	 5
  00310	05		 DB	 5
  00311	05		 DB	 5
  00312	05		 DB	 5
  00313	05		 DB	 5
  00314	05		 DB	 5
  00315	05		 DB	 5
  00316	05		 DB	 5
  00317	02		 DB	 2
  00318	02		 DB	 2
  00319	02		 DB	 2
  0031a	02		 DB	 2
  0031b	02		 DB	 2
  0031c	02		 DB	 2
  0031d	02		 DB	 2
  0031e	02		 DB	 2
  0031f	01		 DB	 1
  00320	01		 DB	 1
  00321	01		 DB	 1
  00322	01		 DB	 1
  00323	01		 DB	 1
  00324	01		 DB	 1
  00325	01		 DB	 1
  00326	01		 DB	 1
?VmAddInstruction@@YAHPEAU_VM_ASSEMBLER@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; VmAddInstruction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmAddOpaqueBranch@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@HH@Z
_TEXT	SEGMENT
Assembler$ = 8
Start$ = 16
InstructionsToInclude$ = 24
JunkCount$ = 32
?VmAddOpaqueBranch@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@HH@Z PROC ; VmAddOpaqueBranch, COMDAT

; 571  : 	PCODE_LINK Take = NULL, NotTake = NULL;
; 572  : 
; 573  : 
; 574  : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 575  : }

  00002	c3		 ret	 0
?VmAddOpaqueBranch@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@HH@Z ENDP ; VmAddOpaqueBranch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetInverseStackChangeForRange@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@H@Z
_TEXT	SEGMENT
Assembler$ = 8
Start$ = 16
Count$ = 24
?VmGetInverseStackChangeForRange@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@H@Z PROC ; VmGetInverseStackChangeForRange, COMDAT

; 557  : 	INT StackChange = 0;

  00000	45 33 c9	 xor	 r9d, r9d

; 558  : 	INT i = 0;

  00003	45 33 d2	 xor	 r10d, r10d

; 559  : 	for (PCODE_LINK Link = Start; Link && (i < Count); Link = Link->Next)

  00006	48 85 d2	 test	 rdx, rdx
  00009	0f 84 a9 00 00
	00		 je	 $LN30@VmGetInver
  0000f	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
$LL4@VmGetInver:
  00016	45 3b d0	 cmp	 r10d, r8d
  00019	0f 8d 99 00 00
	00		 jge	 $LN30@VmGetInver

; 560  : 	{
; 561  : 		if (!Link->IsLabel)

  0001f	80 7a 10 00	 cmp	 BYTE PTR [rdx+16], 0
  00023	0f 85 83 00 00
	00		 jne	 $LN2@VmGetInver

; 427  : 	switch (Link->InstructionId)

  00029	0f b6 42 11	 movzx	 eax, BYTE PTR [rdx+17]
  0002d	83 c0 fd	 add	 eax, -3
  00030	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  00035	77 6d		 ja	 SHORT $LN22@VmGetInver
  00037	48 98		 cdqe
  00039	41 0f b6 84 03
	00 00 00 00	 movzx	 eax, BYTE PTR $LN28@VmGetInver[r11+rax]
  00042	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN29@VmGetInver[r11+rax*4]
  0004a	49 03 cb	 add	 rcx, r11
  0004d	ff e1		 jmp	 rcx
$LN10@VmGetInver:

; 428  : 	{
; 429  : 	case LDIB:
; 430  : 	case LDAB:
; 431  : 	case SXBW:
; 432  : 	case ZXBW:
; 433  : 	case PUSHB:
; 434  : 	case LDSB:
; 435  : 	case LDBPB:
; 436  : 		return 1;

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	eb 50		 jmp	 SHORT $LN7@VmGetInver
$LN11@VmGetInver:

; 437  : 	case LDIW:
; 438  : 	case LDIBSXW:
; 439  : 	case LDIBZXW:
; 440  : 	case LDAW:
; 441  : 	case SXWD:
; 442  : 	case ZXWD:
; 443  : 	case PUSHW:
; 444  : 	case LDSW:
; 445  : 	case LDBPW:
; 446  : 		return 2;

  00056	b8 02 00 00 00	 mov	 eax, 2
  0005b	eb 49		 jmp	 SHORT $LN7@VmGetInver
$LN12@VmGetInver:

; 447  : 	case SXBD:
; 448  : 	case ZXBD:
; 449  : 		return 3;

  0005d	b8 03 00 00 00	 mov	 eax, 3
  00062	eb 42		 jmp	 SHORT $LN7@VmGetInver
$LN13@VmGetInver:

; 450  : 	case LDID:
; 451  : 	case LDIBSXD:
; 452  : 	case LDIWSXD:
; 453  : 	case LDIBZXD:
; 454  : 	case LDIWZXD:
; 455  : 	case LDAD:
; 456  : 	case SXDQ:
; 457  : 	case ZXDQ:
; 458  : 	case PUSHD:
; 459  : 	case ADDD:
; 460  : 	case SUBD:
; 461  : 	case ANDD:
; 462  : 	case ORD:
; 463  : 	case XORD:
; 464  : 	case LDSD:
; 465  : 	case LDBPD:
; 466  : 		return 4;

  00064	b8 04 00 00 00	 mov	 eax, 4
  00069	eb 3b		 jmp	 SHORT $LN7@VmGetInver
$LN14@VmGetInver:

; 467  : 	case SXWQ:
; 468  : 	case ZXWQ:
; 469  : 	case ADDW:
; 470  : 	case SUBW:
; 471  : 	case ANDW:
; 472  : 	case ORW:
; 473  : 	case XORW:
; 474  : 		return 6;

  0006b	b8 06 00 00 00	 mov	 eax, 6
  00070	eb 34		 jmp	 SHORT $LN7@VmGetInver
$LN15@VmGetInver:

; 475  : 	case SXBQ:
; 476  : 	case ZXBQ:
; 477  : 	case ADDB:
; 478  : 	case SUBB:
; 479  : 	case ANDB:
; 480  : 	case ORB:
; 481  : 	case XORB:
; 482  : 	case SHLB:
; 483  : 	case SHLW:
; 484  : 	case SHLD:
; 485  : 	case SHLQ:
; 486  : 	case SHRB:
; 487  : 	case SHRW:
; 488  : 	case SHRD:
; 489  : 	case SHRQ:
; 490  : 		return 7;

  00072	b8 07 00 00 00	 mov	 eax, 7
  00077	eb 2d		 jmp	 SHORT $LN7@VmGetInver
$LN16@VmGetInver:

; 491  : 	case LDIQ:
; 492  : 	case LDIBSXQ:
; 493  : 	case LDIWSXQ:
; 494  : 	case LDIDSXQ:
; 495  : 	case LDIBZXQ:
; 496  : 	case LDIWZXQ:
; 497  : 	case LDIDZXQ:
; 498  : 	case LDAQ:
; 499  : 	case PUSHQ:
; 500  : 	case CMPB:
; 501  : 	case CMPW:
; 502  : 	case CMPD:
; 503  : 	case CMPQ:
; 504  : 	case JMP:
; 505  : 	case CALL:
; 506  : 	case DECB:
; 507  : 	case DECW:
; 508  : 	case DECD:
; 509  : 	case DECQ:
; 510  : 	case INCB:
; 511  : 	case INCW:
; 512  : 	case INCD:
; 513  : 	case INCQ:
; 514  : 	case LDSQ:
; 515  : 	case LDBPQ:
; 516  : 		return 8;

  00079	b8 08 00 00 00	 mov	 eax, 8
  0007e	eb 26		 jmp	 SHORT $LN7@VmGetInver
$LN17@VmGetInver:

; 517  : 
; 518  : 	case STAB:
; 519  : 	case POPB:
; 520  : 	case NPOPB:
; 521  : 	case STSB:
; 522  : 	case STBPB:
; 523  : 		return -1;

  00080	b8 ff ff ff ff	 mov	 eax, -1
  00085	eb 1f		 jmp	 SHORT $LN7@VmGetInver
$LN18@VmGetInver:

; 524  : 	case STAW:
; 525  : 	case POPW:
; 526  : 	case NPOPW:
; 527  : 	case STSW:
; 528  : 	case STBPW:
; 529  : 		return -2;

  00087	b8 fe ff ff ff	 mov	 eax, -2
  0008c	eb 18		 jmp	 SHORT $LN7@VmGetInver
$LN19@VmGetInver:

; 530  : 	case STAD:
; 531  : 	case POPD:
; 532  : 	case NPOPD:
; 533  : 	case STSD:
; 534  : 	case STBPD:
; 535  : 		return -4;

  0008e	b8 fc ff ff ff	 mov	 eax, -4
  00093	eb 11		 jmp	 SHORT $LN7@VmGetInver
$LN20@VmGetInver:

; 536  : 	case STAQ:
; 537  : 	case POPQ:
; 538  : 	case NPOPQ:
; 539  : 	case RET:
; 540  : 	case STSQ:
; 541  : 	case STBPQ:
; 542  : 	case JL:
; 543  : 	case JLE:
; 544  : 	case JG:
; 545  : 	case JGE:
; 546  : 	case JZ:
; 547  : 	case JNZ:
; 548  : 		return -8;

  00095	b8 f8 ff ff ff	 mov	 eax, -8
  0009a	eb 0a		 jmp	 SHORT $LN7@VmGetInver
$LN21@VmGetInver:

; 549  : 	case EDITSP:
; 550  : 		return ((SHORT)Link->Data) * -1;

  0009c	0f bf 42 18	 movsx	 eax, WORD PTR [rdx+24]
  000a0	f7 d8		 neg	 eax
  000a2	eb 02		 jmp	 SHORT $LN7@VmGetInver
$LN22@VmGetInver:

; 551  : 	default:
; 552  : 		return 0;

  000a4	33 c0		 xor	 eax, eax
$LN7@VmGetInver:

; 562  : 		{
; 563  : 			StackChange += VmGetInverseStackChange(Link);

  000a6	44 03 c8	 add	 r9d, eax

; 564  : 			++i;

  000a9	41 ff c2	 inc	 r10d
$LN2@VmGetInver:

; 559  : 	for (PCODE_LINK Link = Start; Link && (i < Count); Link = Link->Next)

  000ac	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000af	48 85 d2	 test	 rdx, rdx
  000b2	0f 85 5e ff ff
	ff		 jne	 $LL4@VmGetInver
$LN30@VmGetInver:

; 565  : 		}
; 566  : 	}
; 567  : 	return StackChange;
; 568  : }

  000b8	41 8b c1	 mov	 eax, r9d
  000bb	c3		 ret	 0
$LN29@VmGetInver:
  000bc	00 00 00 00	 DD	 $LN10@VmGetInver
  000c0	00 00 00 00	 DD	 $LN11@VmGetInver
  000c4	00 00 00 00	 DD	 $LN13@VmGetInver
  000c8	00 00 00 00	 DD	 $LN16@VmGetInver
  000cc	00 00 00 00	 DD	 $LN17@VmGetInver
  000d0	00 00 00 00	 DD	 $LN18@VmGetInver
  000d4	00 00 00 00	 DD	 $LN19@VmGetInver
  000d8	00 00 00 00	 DD	 $LN20@VmGetInver
  000dc	00 00 00 00	 DD	 $LN12@VmGetInver
  000e0	00 00 00 00	 DD	 $LN15@VmGetInver
  000e4	00 00 00 00	 DD	 $LN14@VmGetInver
  000e8	00 00 00 00	 DD	 $LN21@VmGetInver
  000ec	00 00 00 00	 DD	 $LN22@VmGetInver
$LN28@VmGetInver:
  000f0	00		 DB	 0
  000f1	01		 DB	 1
  000f2	02		 DB	 2
  000f3	03		 DB	 3
  000f4	01		 DB	 1
  000f5	02		 DB	 2
  000f6	03		 DB	 3
  000f7	02		 DB	 2
  000f8	03		 DB	 3
  000f9	03		 DB	 3
  000fa	01		 DB	 1
  000fb	02		 DB	 2
  000fc	03		 DB	 3
  000fd	02		 DB	 2
  000fe	03		 DB	 3
  000ff	03		 DB	 3
  00100	00		 DB	 0
  00101	01		 DB	 1
  00102	02		 DB	 2
  00103	03		 DB	 3
  00104	04		 DB	 4
  00105	05		 DB	 5
  00106	06		 DB	 6
  00107	07		 DB	 7
  00108	00		 DB	 0
  00109	08		 DB	 8
  0010a	09		 DB	 9
  0010b	01		 DB	 1
  0010c	0a		 DB	 10
  0010d	02		 DB	 2
  0010e	00		 DB	 0
  0010f	08		 DB	 8
  00110	09		 DB	 9
  00111	01		 DB	 1
  00112	0a		 DB	 10
  00113	02		 DB	 2
  00114	00		 DB	 0
  00115	01		 DB	 1
  00116	02		 DB	 2
  00117	03		 DB	 3
  00118	04		 DB	 4
  00119	05		 DB	 5
  0011a	06		 DB	 6
  0011b	07		 DB	 7
  0011c	04		 DB	 4
  0011d	05		 DB	 5
  0011e	06		 DB	 6
  0011f	07		 DB	 7
  00120	09		 DB	 9
  00121	0a		 DB	 10
  00122	02		 DB	 2
  00123	0c		 DB	 12
  00124	09		 DB	 9
  00125	0a		 DB	 10
  00126	02		 DB	 2
  00127	0c		 DB	 12
  00128	0c		 DB	 12
  00129	0c		 DB	 12
  0012a	0c		 DB	 12
  0012b	0c		 DB	 12
  0012c	0c		 DB	 12
  0012d	0c		 DB	 12
  0012e	0c		 DB	 12
  0012f	0c		 DB	 12
  00130	09		 DB	 9
  00131	0a		 DB	 10
  00132	02		 DB	 2
  00133	0c		 DB	 12
  00134	09		 DB	 9
  00135	0a		 DB	 10
  00136	02		 DB	 2
  00137	0c		 DB	 12
  00138	09		 DB	 9
  00139	0a		 DB	 10
  0013a	02		 DB	 2
  0013b	0c		 DB	 12
  0013c	09		 DB	 9
  0013d	09		 DB	 9
  0013e	09		 DB	 9
  0013f	09		 DB	 9
  00140	09		 DB	 9
  00141	09		 DB	 9
  00142	09		 DB	 9
  00143	09		 DB	 9
  00144	03		 DB	 3
  00145	03		 DB	 3
  00146	03		 DB	 3
  00147	03		 DB	 3
  00148	03		 DB	 3
  00149	0c		 DB	 12
  0014a	07		 DB	 7
  0014b	07		 DB	 7
  0014c	07		 DB	 7
  0014d	07		 DB	 7
  0014e	07		 DB	 7
  0014f	07		 DB	 7
  00150	03		 DB	 3
  00151	07		 DB	 7
  00152	0c		 DB	 12
  00153	0b		 DB	 11
  00154	0c		 DB	 12
  00155	0c		 DB	 12
  00156	0c		 DB	 12
  00157	0c		 DB	 12
  00158	0c		 DB	 12
  00159	0c		 DB	 12
  0015a	0c		 DB	 12
  0015b	0c		 DB	 12
  0015c	03		 DB	 3
  0015d	03		 DB	 3
  0015e	03		 DB	 3
  0015f	03		 DB	 3
  00160	03		 DB	 3
  00161	03		 DB	 3
  00162	03		 DB	 3
  00163	03		 DB	 3
  00164	0c		 DB	 12
  00165	0c		 DB	 12
  00166	0c		 DB	 12
  00167	00		 DB	 0
  00168	01		 DB	 1
  00169	02		 DB	 2
  0016a	03		 DB	 3
  0016b	04		 DB	 4
  0016c	05		 DB	 5
  0016d	06		 DB	 6
  0016e	07		 DB	 7
  0016f	00		 DB	 0
  00170	01		 DB	 1
  00171	02		 DB	 2
  00172	03		 DB	 3
  00173	04		 DB	 4
  00174	05		 DB	 5
  00175	06		 DB	 6
  00176	07		 DB	 7
?VmGetInverseStackChangeForRange@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@H@Z ENDP ; VmGetInverseStackChangeForRange
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetInverseStackChange@@YAHPEAU_CODE_LINK@@@Z
_TEXT	SEGMENT
Link$ = 8
?VmGetInverseStackChange@@YAHPEAU_CODE_LINK@@@Z PROC	; VmGetInverseStackChange, COMDAT

; 427  : 	switch (Link->InstructionId)

  00000	0f b6 41 11	 movzx	 eax, BYTE PTR [rcx+17]
  00004	83 c0 fd	 add	 eax, -3
  00007	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  0000c	77 68		 ja	 SHORT $LN16@VmGetInver
  0000e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00015	48 98		 cdqe
  00017	41 0f b6 84 00
	00 00 00 00	 movzx	 eax, BYTE PTR $LN18@VmGetInver[r8+rax]
  00020	41 8b 94 80 00
	00 00 00	 mov	 edx, DWORD PTR $LN19@VmGetInver[r8+rax*4]
  00028	49 03 d0	 add	 rdx, r8
  0002b	ff e2		 jmp	 rdx
$LN4@VmGetInver:

; 428  : 	{
; 429  : 	case LDIB:
; 430  : 	case LDAB:
; 431  : 	case SXBW:
; 432  : 	case ZXBW:
; 433  : 	case PUSHB:
; 434  : 	case LDSB:
; 435  : 	case LDBPB:
; 436  : 		return 1;

  0002d	b8 01 00 00 00	 mov	 eax, 1

; 553  : 	}
; 554  : }

  00032	c3		 ret	 0
$LN5@VmGetInver:

; 437  : 	case LDIW:
; 438  : 	case LDIBSXW:
; 439  : 	case LDIBZXW:
; 440  : 	case LDAW:
; 441  : 	case SXWD:
; 442  : 	case ZXWD:
; 443  : 	case PUSHW:
; 444  : 	case LDSW:
; 445  : 	case LDBPW:
; 446  : 		return 2;

  00033	b8 02 00 00 00	 mov	 eax, 2

; 553  : 	}
; 554  : }

  00038	c3		 ret	 0
$LN6@VmGetInver:

; 447  : 	case SXBD:
; 448  : 	case ZXBD:
; 449  : 		return 3;

  00039	b8 03 00 00 00	 mov	 eax, 3

; 553  : 	}
; 554  : }

  0003e	c3		 ret	 0
$LN7@VmGetInver:

; 450  : 	case LDID:
; 451  : 	case LDIBSXD:
; 452  : 	case LDIWSXD:
; 453  : 	case LDIBZXD:
; 454  : 	case LDIWZXD:
; 455  : 	case LDAD:
; 456  : 	case SXDQ:
; 457  : 	case ZXDQ:
; 458  : 	case PUSHD:
; 459  : 	case ADDD:
; 460  : 	case SUBD:
; 461  : 	case ANDD:
; 462  : 	case ORD:
; 463  : 	case XORD:
; 464  : 	case LDSD:
; 465  : 	case LDBPD:
; 466  : 		return 4;

  0003f	b8 04 00 00 00	 mov	 eax, 4

; 553  : 	}
; 554  : }

  00044	c3		 ret	 0
$LN8@VmGetInver:

; 467  : 	case SXWQ:
; 468  : 	case ZXWQ:
; 469  : 	case ADDW:
; 470  : 	case SUBW:
; 471  : 	case ANDW:
; 472  : 	case ORW:
; 473  : 	case XORW:
; 474  : 		return 6;

  00045	b8 06 00 00 00	 mov	 eax, 6

; 553  : 	}
; 554  : }

  0004a	c3		 ret	 0
$LN9@VmGetInver:

; 475  : 	case SXBQ:
; 476  : 	case ZXBQ:
; 477  : 	case ADDB:
; 478  : 	case SUBB:
; 479  : 	case ANDB:
; 480  : 	case ORB:
; 481  : 	case XORB:
; 482  : 	case SHLB:
; 483  : 	case SHLW:
; 484  : 	case SHLD:
; 485  : 	case SHLQ:
; 486  : 	case SHRB:
; 487  : 	case SHRW:
; 488  : 	case SHRD:
; 489  : 	case SHRQ:
; 490  : 		return 7;

  0004b	b8 07 00 00 00	 mov	 eax, 7

; 553  : 	}
; 554  : }

  00050	c3		 ret	 0
$LN10@VmGetInver:

; 491  : 	case LDIQ:
; 492  : 	case LDIBSXQ:
; 493  : 	case LDIWSXQ:
; 494  : 	case LDIDSXQ:
; 495  : 	case LDIBZXQ:
; 496  : 	case LDIWZXQ:
; 497  : 	case LDIDZXQ:
; 498  : 	case LDAQ:
; 499  : 	case PUSHQ:
; 500  : 	case CMPB:
; 501  : 	case CMPW:
; 502  : 	case CMPD:
; 503  : 	case CMPQ:
; 504  : 	case JMP:
; 505  : 	case CALL:
; 506  : 	case DECB:
; 507  : 	case DECW:
; 508  : 	case DECD:
; 509  : 	case DECQ:
; 510  : 	case INCB:
; 511  : 	case INCW:
; 512  : 	case INCD:
; 513  : 	case INCQ:
; 514  : 	case LDSQ:
; 515  : 	case LDBPQ:
; 516  : 		return 8;

  00051	b8 08 00 00 00	 mov	 eax, 8

; 553  : 	}
; 554  : }

  00056	c3		 ret	 0
$LN11@VmGetInver:

; 517  : 
; 518  : 	case STAB:
; 519  : 	case POPB:
; 520  : 	case NPOPB:
; 521  : 	case STSB:
; 522  : 	case STBPB:
; 523  : 		return -1;

  00057	b8 ff ff ff ff	 mov	 eax, -1

; 553  : 	}
; 554  : }

  0005c	c3		 ret	 0
$LN12@VmGetInver:

; 524  : 	case STAW:
; 525  : 	case POPW:
; 526  : 	case NPOPW:
; 527  : 	case STSW:
; 528  : 	case STBPW:
; 529  : 		return -2;

  0005d	b8 fe ff ff ff	 mov	 eax, -2

; 553  : 	}
; 554  : }

  00062	c3		 ret	 0
$LN13@VmGetInver:

; 530  : 	case STAD:
; 531  : 	case POPD:
; 532  : 	case NPOPD:
; 533  : 	case STSD:
; 534  : 	case STBPD:
; 535  : 		return -4;

  00063	b8 fc ff ff ff	 mov	 eax, -4

; 553  : 	}
; 554  : }

  00068	c3		 ret	 0
$LN14@VmGetInver:

; 536  : 	case STAQ:
; 537  : 	case POPQ:
; 538  : 	case NPOPQ:
; 539  : 	case RET:
; 540  : 	case STSQ:
; 541  : 	case STBPQ:
; 542  : 	case JL:
; 543  : 	case JLE:
; 544  : 	case JG:
; 545  : 	case JGE:
; 546  : 	case JZ:
; 547  : 	case JNZ:
; 548  : 		return -8;

  00069	b8 f8 ff ff ff	 mov	 eax, -8

; 553  : 	}
; 554  : }

  0006e	c3		 ret	 0
$LN15@VmGetInver:

; 549  : 	case EDITSP:
; 550  : 		return ((SHORT)Link->Data) * -1;

  0006f	0f bf 41 18	 movsx	 eax, WORD PTR [rcx+24]
  00073	f7 d8		 neg	 eax

; 553  : 	}
; 554  : }

  00075	c3		 ret	 0
$LN16@VmGetInver:

; 551  : 	default:
; 552  : 		return 0;

  00076	33 c0		 xor	 eax, eax

; 553  : 	}
; 554  : }

  00078	c3		 ret	 0
  00079	0f 1f 00	 npad	 3
$LN19@VmGetInver:
  0007c	00 00 00 00	 DD	 $LN4@VmGetInver
  00080	00 00 00 00	 DD	 $LN5@VmGetInver
  00084	00 00 00 00	 DD	 $LN7@VmGetInver
  00088	00 00 00 00	 DD	 $LN10@VmGetInver
  0008c	00 00 00 00	 DD	 $LN11@VmGetInver
  00090	00 00 00 00	 DD	 $LN12@VmGetInver
  00094	00 00 00 00	 DD	 $LN13@VmGetInver
  00098	00 00 00 00	 DD	 $LN14@VmGetInver
  0009c	00 00 00 00	 DD	 $LN6@VmGetInver
  000a0	00 00 00 00	 DD	 $LN9@VmGetInver
  000a4	00 00 00 00	 DD	 $LN8@VmGetInver
  000a8	00 00 00 00	 DD	 $LN15@VmGetInver
  000ac	00 00 00 00	 DD	 $LN16@VmGetInver
$LN18@VmGetInver:
  000b0	00		 DB	 0
  000b1	01		 DB	 1
  000b2	02		 DB	 2
  000b3	03		 DB	 3
  000b4	01		 DB	 1
  000b5	02		 DB	 2
  000b6	03		 DB	 3
  000b7	02		 DB	 2
  000b8	03		 DB	 3
  000b9	03		 DB	 3
  000ba	01		 DB	 1
  000bb	02		 DB	 2
  000bc	03		 DB	 3
  000bd	02		 DB	 2
  000be	03		 DB	 3
  000bf	03		 DB	 3
  000c0	00		 DB	 0
  000c1	01		 DB	 1
  000c2	02		 DB	 2
  000c3	03		 DB	 3
  000c4	04		 DB	 4
  000c5	05		 DB	 5
  000c6	06		 DB	 6
  000c7	07		 DB	 7
  000c8	00		 DB	 0
  000c9	08		 DB	 8
  000ca	09		 DB	 9
  000cb	01		 DB	 1
  000cc	0a		 DB	 10
  000cd	02		 DB	 2
  000ce	00		 DB	 0
  000cf	08		 DB	 8
  000d0	09		 DB	 9
  000d1	01		 DB	 1
  000d2	0a		 DB	 10
  000d3	02		 DB	 2
  000d4	00		 DB	 0
  000d5	01		 DB	 1
  000d6	02		 DB	 2
  000d7	03		 DB	 3
  000d8	04		 DB	 4
  000d9	05		 DB	 5
  000da	06		 DB	 6
  000db	07		 DB	 7
  000dc	04		 DB	 4
  000dd	05		 DB	 5
  000de	06		 DB	 6
  000df	07		 DB	 7
  000e0	09		 DB	 9
  000e1	0a		 DB	 10
  000e2	02		 DB	 2
  000e3	0c		 DB	 12
  000e4	09		 DB	 9
  000e5	0a		 DB	 10
  000e6	02		 DB	 2
  000e7	0c		 DB	 12
  000e8	0c		 DB	 12
  000e9	0c		 DB	 12
  000ea	0c		 DB	 12
  000eb	0c		 DB	 12
  000ec	0c		 DB	 12
  000ed	0c		 DB	 12
  000ee	0c		 DB	 12
  000ef	0c		 DB	 12
  000f0	09		 DB	 9
  000f1	0a		 DB	 10
  000f2	02		 DB	 2
  000f3	0c		 DB	 12
  000f4	09		 DB	 9
  000f5	0a		 DB	 10
  000f6	02		 DB	 2
  000f7	0c		 DB	 12
  000f8	09		 DB	 9
  000f9	0a		 DB	 10
  000fa	02		 DB	 2
  000fb	0c		 DB	 12
  000fc	09		 DB	 9
  000fd	09		 DB	 9
  000fe	09		 DB	 9
  000ff	09		 DB	 9
  00100	09		 DB	 9
  00101	09		 DB	 9
  00102	09		 DB	 9
  00103	09		 DB	 9
  00104	03		 DB	 3
  00105	03		 DB	 3
  00106	03		 DB	 3
  00107	03		 DB	 3
  00108	03		 DB	 3
  00109	0c		 DB	 12
  0010a	07		 DB	 7
  0010b	07		 DB	 7
  0010c	07		 DB	 7
  0010d	07		 DB	 7
  0010e	07		 DB	 7
  0010f	07		 DB	 7
  00110	03		 DB	 3
  00111	07		 DB	 7
  00112	0c		 DB	 12
  00113	0b		 DB	 11
  00114	0c		 DB	 12
  00115	0c		 DB	 12
  00116	0c		 DB	 12
  00117	0c		 DB	 12
  00118	0c		 DB	 12
  00119	0c		 DB	 12
  0011a	0c		 DB	 12
  0011b	0c		 DB	 12
  0011c	03		 DB	 3
  0011d	03		 DB	 3
  0011e	03		 DB	 3
  0011f	03		 DB	 3
  00120	03		 DB	 3
  00121	03		 DB	 3
  00122	03		 DB	 3
  00123	03		 DB	 3
  00124	0c		 DB	 12
  00125	0c		 DB	 12
  00126	0c		 DB	 12
  00127	00		 DB	 0
  00128	01		 DB	 1
  00129	02		 DB	 2
  0012a	03		 DB	 3
  0012b	04		 DB	 4
  0012c	05		 DB	 5
  0012d	06		 DB	 6
  0012e	07		 DB	 7
  0012f	00		 DB	 0
  00130	01		 DB	 1
  00131	02		 DB	 2
  00132	03		 DB	 3
  00133	04		 DB	 4
  00134	05		 DB	 5
  00135	06		 DB	 6
  00136	07		 DB	 7
?VmGetInverseStackChange@@YAHPEAU_CODE_LINK@@@Z ENDP	; VmGetInverseStackChange
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z
_TEXT	SEGMENT
HandlerTable$ = 32
Assembler$ = 2128
?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z PROC ; VmLoadDefaultInstructions, COMDAT

; 217  : {

$LN21:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0000b	55		 push	 rbp
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	49 8d ab b8 f8
	ff ff		 lea	 rbp, QWORD PTR [r11-1864]
  0001b	48 81 ec 20 08
	00 00		 sub	 rsp, 2080		; 00000820H

; 218  : 	PVOID HandlerTable[256];
; 219  : 	{
; 220  : 		HandlerTable[VMENTER] = VmEnter;

  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VmEnter
  00029	4c 8b e9	 mov	 r13, rcx
  0002c	48 89 44 24 20	 mov	 QWORD PTR HandlerTable$[rsp], rax

; 221  : 		HandlerTable[VMEXIT] = ViVmExit;

  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViVmExit
  00038	48 89 44 24 28	 mov	 QWORD PTR HandlerTable$[rsp+8], rax

; 222  : 		HandlerTable[NOP] = ViNop;

  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViNop
  00044	48 89 44 24 30	 mov	 QWORD PTR HandlerTable$[rsp+16], rax

; 223  : 
; 224  : 		HandlerTable[LDIB] = ViLdib;

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdib
  00050	48 89 44 24 38	 mov	 QWORD PTR HandlerTable$[rsp+24], rax

; 225  : 		HandlerTable[LDIW] = ViLdiw;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdiw
  0005c	48 89 44 24 40	 mov	 QWORD PTR HandlerTable$[rsp+32], rax

; 226  : 		HandlerTable[LDID] = ViLdid;

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdid
  00068	48 89 44 24 48	 mov	 QWORD PTR HandlerTable$[rsp+40], rax

; 227  : 		HandlerTable[LDIQ] = ViLdiq;

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdiq
  00074	48 89 44 24 50	 mov	 QWORD PTR HandlerTable$[rsp+48], rax

; 228  : 
; 229  : 		HandlerTable[LDIBSXW] = ViLdibsxw;

  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdibsxw
  00080	48 89 44 24 58	 mov	 QWORD PTR HandlerTable$[rsp+56], rax

; 230  : 		HandlerTable[LDIBSXD] = ViLdibsxd;

  00085	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdibsxd
  0008c	48 89 44 24 60	 mov	 QWORD PTR HandlerTable$[rsp+64], rax

; 231  : 		HandlerTable[LDIBSXQ] = ViLdibsxq;

  00091	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdibsxq
  00098	48 89 44 24 68	 mov	 QWORD PTR HandlerTable$[rsp+72], rax

; 232  : 		HandlerTable[LDIWSXD] = ViLdiwsxd;

  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdiwsxd
  000a4	48 89 44 24 70	 mov	 QWORD PTR HandlerTable$[rsp+80], rax

; 233  : 		HandlerTable[LDIWSXQ] = ViLdiwsxq;

  000a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdiwsxq
  000b0	48 89 44 24 78	 mov	 QWORD PTR HandlerTable$[rsp+88], rax

; 234  : 		HandlerTable[LDIDSXQ] = ViLdidsxq;

  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdidsxq
  000bc	48 89 45 80	 mov	 QWORD PTR HandlerTable$[rbp-160], rax

; 235  : 
; 236  : 		HandlerTable[LDIBZXW] = ViLdibzxw;

  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdibzxw
  000c7	48 89 45 88	 mov	 QWORD PTR HandlerTable$[rbp-152], rax

; 237  : 		HandlerTable[LDIBZXD] = ViLdibzxd;

  000cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdibzxd
  000d2	48 89 45 90	 mov	 QWORD PTR HandlerTable$[rbp-144], rax

; 238  : 		HandlerTable[LDIBZXQ] = ViLdibzxq;

  000d6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdibzxq
  000dd	48 89 45 98	 mov	 QWORD PTR HandlerTable$[rbp-136], rax

; 239  : 		HandlerTable[LDIWZXD] = ViLdiwzxd;

  000e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdiwzxd
  000e8	48 89 45 a0	 mov	 QWORD PTR HandlerTable$[rbp-128], rax

; 240  : 		HandlerTable[LDIWZXQ] = ViLdiwzxq;

  000ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdiwzxq
  000f3	48 89 45 a8	 mov	 QWORD PTR HandlerTable$[rbp-120], rax

; 241  : 		HandlerTable[LDIDZXQ] = ViLdidzxq;

  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdidzxq
  000fe	48 89 45 b0	 mov	 QWORD PTR HandlerTable$[rbp-112], rax

; 242  : 
; 243  : 		HandlerTable[LDAB] = ViLdab;

  00102	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdab
  00109	48 89 45 b8	 mov	 QWORD PTR HandlerTable$[rbp-104], rax

; 244  : 		HandlerTable[LDAW] = ViLdaw;

  0010d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdaw
  00114	48 89 45 c0	 mov	 QWORD PTR HandlerTable$[rbp-96], rax

; 245  : 		HandlerTable[LDAD] = ViLdad;

  00118	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdad
  0011f	48 89 45 c8	 mov	 QWORD PTR HandlerTable$[rbp-88], rax

; 246  : 		HandlerTable[LDAQ] = ViLdaq;

  00123	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdaq
  0012a	48 89 45 d0	 mov	 QWORD PTR HandlerTable$[rbp-80], rax

; 247  : 
; 248  : 		HandlerTable[STAB] = ViStab;

  0012e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStab
  00135	48 89 45 d8	 mov	 QWORD PTR HandlerTable$[rbp-72], rax

; 249  : 		HandlerTable[STAW] = ViStaw;

  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStaw
  00140	48 89 45 e0	 mov	 QWORD PTR HandlerTable$[rbp-64], rax

; 250  : 		HandlerTable[STAD] = ViStad;

  00144	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStad
  0014b	48 89 45 e8	 mov	 QWORD PTR HandlerTable$[rbp-56], rax

; 251  : 		HandlerTable[STAQ] = ViStaq;

  0014f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStaq
  00156	48 89 45 f0	 mov	 QWORD PTR HandlerTable$[rbp-48], rax

; 252  : 
; 253  : 		HandlerTable[SXBW] = ViSxbw;

  0015a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSxbw
  00161	48 89 45 f8	 mov	 QWORD PTR HandlerTable$[rbp-40], rax

; 254  : 		HandlerTable[SXBD] = ViSxbd;

  00165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSxbd
  0016c	48 89 45 00	 mov	 QWORD PTR HandlerTable$[rbp-32], rax

; 255  : 		HandlerTable[SXBQ] = ViSxbq;

  00170	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSxbq
  00177	48 89 45 08	 mov	 QWORD PTR HandlerTable$[rbp-24], rax

; 256  : 		HandlerTable[SXWD] = ViSxwd;

  0017b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSxwd
  00182	48 89 45 10	 mov	 QWORD PTR HandlerTable$[rbp-16], rax

; 257  : 		HandlerTable[SXWQ] = ViSxwq;

  00186	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSxwq
  0018d	48 89 45 18	 mov	 QWORD PTR HandlerTable$[rbp-8], rax

; 258  : 		HandlerTable[SXDQ] = ViSxdq;

  00191	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSxdq
  00198	48 89 45 20	 mov	 QWORD PTR HandlerTable$[rbp], rax

; 259  : 
; 260  : 		HandlerTable[ZXBW] = ViZxbw;

  0019c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViZxbw
  001a3	48 89 45 28	 mov	 QWORD PTR HandlerTable$[rbp+8], rax

; 261  : 		HandlerTable[ZXBD] = ViZxbd;

  001a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViZxbd
  001ae	48 89 45 30	 mov	 QWORD PTR HandlerTable$[rbp+16], rax

; 262  : 		HandlerTable[ZXBQ] = ViZxbq;

  001b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViZxbq
  001b9	48 89 45 38	 mov	 QWORD PTR HandlerTable$[rbp+24], rax

; 263  : 		HandlerTable[ZXWD] = ViZxwd;

  001bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViZxwd
  001c4	48 89 45 40	 mov	 QWORD PTR HandlerTable$[rbp+32], rax

; 264  : 		HandlerTable[ZXWQ] = ViZxwq;

  001c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViZxwq
  001cf	48 89 45 48	 mov	 QWORD PTR HandlerTable$[rbp+40], rax

; 265  : 		HandlerTable[ZXDQ] = ViZxdq;

  001d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViZxdq
  001da	48 89 45 50	 mov	 QWORD PTR HandlerTable$[rbp+48], rax

; 266  : 
; 267  : 		HandlerTable[PUSHB] = ViPushb;

  001de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViPushb
  001e5	48 89 45 58	 mov	 QWORD PTR HandlerTable$[rbp+56], rax

; 268  : 		HandlerTable[PUSHW] = ViPushw;

  001e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViPushw
  001f0	48 89 45 60	 mov	 QWORD PTR HandlerTable$[rbp+64], rax

; 269  : 		HandlerTable[PUSHD] = ViPushd;

  001f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViPushd
  001fb	48 89 45 68	 mov	 QWORD PTR HandlerTable$[rbp+72], rax

; 270  : 		HandlerTable[PUSHQ] = ViPushq;

  001ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViPushq
  00206	48 89 45 70	 mov	 QWORD PTR HandlerTable$[rbp+80], rax

; 271  : 
; 272  : 		HandlerTable[POPB] = ViPopb;

  0020a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViPopb
  00211	48 89 45 78	 mov	 QWORD PTR HandlerTable$[rbp+88], rax

; 273  : 		HandlerTable[POPW] = ViPopw;

  00215	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViPopw
  0021c	48 89 85 80 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+96], rax

; 274  : 		HandlerTable[POPD] = ViPopd;

  00223	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViPopd
  0022a	48 89 85 88 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+104], rax

; 275  : 		HandlerTable[POPQ] = ViPopq;

  00231	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViPopq
  00238	48 89 85 90 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+112], rax

; 276  : 
; 277  : 		HandlerTable[NPOPB] = ViNpopb;

  0023f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViNpopb
  00246	48 89 85 98 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+120], rax

; 278  : 		HandlerTable[NPOPW] = ViNpopw;

  0024d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViNpopw
  00254	48 89 85 a0 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+128], rax

; 279  : 		HandlerTable[NPOPD] = ViNpopd;

  0025b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViNpopd
  00262	48 89 85 a8 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+136], rax

; 280  : 		HandlerTable[NPOPQ] = ViNpopq;

  00269	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViNpopq
  00270	48 89 85 b0 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+144], rax

; 281  : 
; 282  : 		HandlerTable[ADDB] = ViAddb;

  00277	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViAddb
  0027e	48 89 85 b8 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+152], rax

; 283  : 		HandlerTable[ADDW] = ViAddw;

  00285	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViAddw
  0028c	48 89 85 c0 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+160], rax

; 284  : 		HandlerTable[ADDD] = ViAddd;

  00293	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViAddd
  0029a	48 89 85 c8 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+168], rax

; 285  : 		HandlerTable[ADDQ] = ViAddq;

  002a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViAddq
  002a8	48 89 85 d0 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+176], rax

; 286  : 
; 287  : 		HandlerTable[SUBB] = ViSubb;

  002af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSubb
  002b6	48 89 85 d8 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+184], rax

; 288  : 		HandlerTable[SUBW] = ViSubw;

  002bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSubw
  002c4	48 89 85 e0 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+192], rax

; 289  : 		HandlerTable[SUBD] = ViSubd;

  002cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSubd
  002d2	48 89 85 e8 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+200], rax

; 290  : 		HandlerTable[SUBQ] = ViSubq;

  002d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSubq
  002e0	48 89 85 f0 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+208], rax

; 291  : 
; 292  : 		HandlerTable[MULB] = ViMulb;

  002e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViMulb
  002ee	48 89 85 f8 00
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+216], rax

; 293  : 		HandlerTable[MULW] = ViMulw;

  002f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViMulw
  002fc	48 89 85 00 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+224], rax

; 294  : 		HandlerTable[MULD] = ViMuld;

  00303	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViMuld
  0030a	48 89 85 08 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+232], rax

; 295  : 		HandlerTable[MULQ] = ViMulq;

  00311	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViMulq
  00318	48 89 85 10 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+240], rax

; 296  : 
; 297  : 		HandlerTable[DIVB] = ViDivb;

  0031f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViDivb
  00326	48 89 85 18 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+248], rax

; 298  : 		HandlerTable[DIVW] = ViDivw;

  0032d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViDivw
  00334	48 89 85 20 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+256], rax

; 299  : 		HandlerTable[DIVD] = ViDivd;

  0033b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViDivd
  00342	48 89 85 28 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+264], rax

; 300  : 		HandlerTable[DIVQ] = ViDivq;

  00349	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViDivq
  00350	48 89 85 30 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+272], rax

; 301  : 
; 302  : 		HandlerTable[ANDB] = ViAndb;

  00357	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViAndb
  0035e	48 89 85 38 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+280], rax

; 303  : 		HandlerTable[ANDW] = ViAndw;

  00365	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViAndw
  0036c	48 89 85 40 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+288], rax

; 304  : 		HandlerTable[ANDD] = ViAndd;

  00373	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViAndd
  0037a	48 89 85 48 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+296], rax

; 305  : 		HandlerTable[ANDQ] = ViAndq;

  00381	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViAndq
  00388	48 89 85 50 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+304], rax

; 306  : 
; 307  : 		HandlerTable[ORB] = ViOrb;

  0038f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViOrb
  00396	48 89 85 58 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+312], rax

; 308  : 		HandlerTable[ORW] = ViOrw;

  0039d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViOrw
  003a4	48 89 85 60 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+320], rax

; 309  : 		HandlerTable[ORD] = ViOrd;

  003ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViOrd
  003b2	48 89 85 68 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+328], rax

; 310  : 		HandlerTable[ORQ] = ViOrq;

  003b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViOrq
  003c0	48 89 85 70 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+336], rax

; 311  : 
; 312  : 		HandlerTable[XORB] = ViXorb;

  003c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViXorb
  003ce	48 89 85 78 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+344], rax

; 313  : 		HandlerTable[XORW] = ViXorw;

  003d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViXorw
  003dc	48 89 85 80 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+352], rax

; 314  : 		HandlerTable[XORD] = ViXord;

  003e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViXord
  003ea	48 89 85 88 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+360], rax

; 315  : 		HandlerTable[XORQ] = ViXorq;

  003f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViXorq
  003f8	48 89 85 90 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+368], rax

; 316  : 
; 317  : 		HandlerTable[SHLB] = ViShlb;

  003ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViShlb
  00406	48 89 85 98 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+376], rax

; 318  : 		HandlerTable[SHLW] = ViShlw;

  0040d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViShlw
  00414	48 89 85 a0 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+384], rax

; 319  : 		HandlerTable[SHLD] = ViShld;

  0041b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViShld
  00422	48 89 85 a8 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+392], rax

; 320  : 		HandlerTable[SHLQ] = ViShlq;

  00429	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViShlq
  00430	48 89 85 b0 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+400], rax

; 321  : 
; 322  : 		HandlerTable[SHRB] = ViShrb;

  00437	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViShrb
  0043e	48 89 85 b8 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+408], rax

; 323  : 		HandlerTable[SHRW] = ViShrw;

  00445	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViShrw
  0044c	48 89 85 c0 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+416], rax

; 324  : 		HandlerTable[SHRD] = ViShrd;

  00453	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViShrd
  0045a	48 89 85 c8 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+424], rax

; 325  : 		HandlerTable[SHRQ] = ViShrq;

  00461	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViShrq
  00468	48 89 85 d0 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+432], rax

; 326  : 
; 327  : 		HandlerTable[CMPB] = ViCmpb;

  0046f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViCmpb
  00476	48 89 85 d8 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+440], rax

; 328  : 		HandlerTable[CMPW] = ViCmpw;

  0047d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViCmpw
  00484	48 89 85 e0 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+448], rax

; 329  : 		HandlerTable[CMPD] = ViCmpd;

  0048b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViCmpd
  00492	48 89 85 e8 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+456], rax

; 330  : 		HandlerTable[CMPQ] = ViCmpq;

  00499	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViCmpq
  004a0	48 89 85 f0 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+464], rax

; 331  : 
; 332  : 		HandlerTable[JMP] = ViJmp;

  004a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViJmp
  004ae	48 89 85 f8 01
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+472], rax

; 333  : 		HandlerTable[JMPI] = ViJmpi;

  004b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViJmpi
  004bc	48 89 85 00 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+480], rax

; 334  : 		HandlerTable[JL] = ViJl;

  004c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViJl
  004ca	48 89 85 08 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+488], rax

; 335  : 		HandlerTable[JLE] = ViJle;

  004d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViJle
  004d8	48 89 85 10 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+496], rax

; 336  : 		HandlerTable[JG] = ViJg;

  004df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViJg
  004e6	48 89 85 18 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+504], rax

; 337  : 		HandlerTable[JGE] = ViJge;

  004ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViJge
  004f4	48 89 85 20 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+512], rax

; 338  : 		HandlerTable[JZ] = ViJz;

  004fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViJz
  00502	48 89 85 28 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+520], rax

; 339  : 		HandlerTable[JNZ] = ViJnz;

  00509	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViJnz
  00510	48 89 85 30 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+528], rax

; 340  : 
; 341  : 		HandlerTable[CALL] = ViCall;

  00517	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViCall
  0051e	48 89 85 38 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+536], rax

; 342  : 		HandlerTable[RET] = ViRet;

  00525	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViRet
  0052c	48 89 85 40 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+544], rax

; 343  : 		HandlerTable[X86CALL] = ViX86Call;

  00533	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViX86Call
  0053a	48 89 85 48 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+552], rax

; 344  : 
; 345  : 		HandlerTable[EDITSP] = ViEditsp;

  00541	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViEditsp
  00548	48 89 85 50 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+560], rax

; 346  : 
; 347  : 		HandlerTable[STSP] = ViStsp;

  0054f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStsp
  00556	48 89 85 58 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+568], rax

; 348  : 		HandlerTable[LDSP] = ViLdsp;

  0055d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdsp
  00564	48 89 85 60 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+576], rax

; 349  : 		HandlerTable[STIP] = ViStip;

  0056b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStip
  00572	48 89 85 68 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+584], rax

; 350  : 		HandlerTable[LDIP] = ViLdip;

  00579	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdip
  00580	48 89 85 70 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+592], rax

; 351  : 
; 352  : 		HandlerTable[SWAPB] = ViSwapb;

  00587	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSwapb
  0058e	48 89 85 78 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+600], rax

; 353  : 		HandlerTable[SWAPW] = ViSwapw;

  00595	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSwapw
  0059c	48 89 85 80 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+608], rax

; 354  : 		HandlerTable[SWAPD] = ViSwapd;

  005a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSwapd
  005aa	48 89 85 88 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+616], rax

; 355  : 		HandlerTable[SWAPQ] = ViSwapq;

  005b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSwapq
  005b8	48 89 85 90 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+624], rax

; 356  : 
; 357  : 		HandlerTable[DECB] = ViDecb;

  005bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViDecb
  005c6	48 89 85 98 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+632], rax

; 358  : 		HandlerTable[DECW] = ViDecw;

  005cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViDecw
  005d4	48 89 85 a0 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+640], rax

; 359  : 		HandlerTable[DECD] = ViDecd;

  005db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViDecd
  005e2	48 89 85 a8 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+648], rax

; 360  : 		HandlerTable[DECQ] = ViDecq;

  005e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViDecq
  005f0	48 89 85 b0 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+656], rax

; 361  : 
; 362  : 		HandlerTable[INCB] = ViIncb;

  005f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViIncb
  005fe	48 89 85 b8 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+664], rax

; 363  : 		HandlerTable[INCW] = ViIncw;

  00605	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViIncw
  0060c	48 89 85 c0 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+672], rax

; 364  : 		HandlerTable[INCD] = ViIncd;

  00613	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViIncd
  0061a	48 89 85 c8 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+680], rax

; 365  : 		HandlerTable[INCQ] = ViIncq;

  00621	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViIncq
  00628	48 89 85 d0 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+688], rax

; 366  : 
; 367  : 		HandlerTable[SWAPBQ] = ViSwapbq;

  0062f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSwapbq
  00636	48 89 85 d8 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+696], rax

; 368  : 		HandlerTable[SWAPWQ] = ViSwapwq;

  0063d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSwapwq
  00644	48 89 85 e0 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+704], rax

; 369  : 		HandlerTable[SWAPDQ] = ViSwapdq;

  0064b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViSwapdq
  00652	49 89 7b 08	 mov	 QWORD PTR [r11+8], rdi
  00656	48 89 85 e8 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+712], rax
  0065d	4c 8d b1 80 00
	00 00		 lea	 r14, QWORD PTR [rcx+128]

; 370  : 
; 371  : 		HandlerTable[LDSB] = ViLdsb;

  00664	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdsb
  0066b	41 bf 02 00 00
	00		 mov	 r15d, 2
  00671	48 89 85 f0 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+720], rax
  00678	4c 8d 64 24 30	 lea	 r12, QWORD PTR HandlerTable$[rsp+16]

; 372  : 		HandlerTable[LDSW] = ViLdsw;

  0067d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdsw
  00684	48 b9 48 0f b6
	02 41 ff 24 c0	 mov	 rcx, -4601272264582361272 ; c024ff4102b60f48H
  0068e	48 89 85 f8 02
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+728], rax

; 373  : 		HandlerTable[LDSD] = ViLdsd;

  00695	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdsd
  0069c	48 89 85 00 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+736], rax

; 374  : 		HandlerTable[LDSQ] = ViLdsq;

  006a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdsq
  006aa	48 89 85 08 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+744], rax

; 375  : 
; 376  : 		HandlerTable[STSB] = ViStsb;

  006b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStsb
  006b8	48 89 85 10 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+752], rax

; 377  : 		HandlerTable[STSW] = ViStsw;

  006bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStsw
  006c6	48 89 85 18 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+760], rax

; 378  : 		HandlerTable[STSD] = ViStsd;

  006cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStsd
  006d4	48 89 85 20 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+768], rax

; 379  : 		HandlerTable[STSQ] = ViStsq;

  006db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStsq
  006e2	48 89 85 28 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+776], rax

; 380  : 
; 381  : 		HandlerTable[LDBPB] = ViLdbpb;

  006e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdbpb
  006f0	48 89 85 30 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+784], rax

; 382  : 		HandlerTable[LDBPW] = ViLdbpw;

  006f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdbpw
  006fe	48 89 85 38 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+792], rax

; 383  : 		HandlerTable[LDBPD] = ViLdbpd;

  00705	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdbpd
  0070c	48 89 85 40 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+800], rax

; 384  : 		HandlerTable[LDBPQ] = ViLdbpq;

  00713	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViLdbpq
  0071a	48 89 85 48 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+808], rax

; 385  : 
; 386  : 		HandlerTable[STBPB] = ViStbpb;

  00721	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStbpb
  00728	48 89 85 50 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+816], rax

; 387  : 		HandlerTable[STBPW] = ViStbpw;

  0072f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStbpw
  00736	48 89 85 58 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+824], rax

; 388  : 		HandlerTable[STBPD] = ViStbpd;

  0073d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStbpd
  00744	48 89 85 60 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+832], rax

; 389  : 		HandlerTable[STBPQ] = ViStbpq;

  0074b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ViStbpq
  00752	48 89 85 68 03
	00 00		 mov	 QWORD PTR HandlerTable$[rbp+840], rax
  00759	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@VmLoadDefa:

; 393  : 	{
; 394  : 		if (i == JL || i == JLE || i == JG || i == JGE || i == JZ || i == JNZ)

  00760	41 8d 47 a3	 lea	 eax, DWORD PTR [r15-93]
  00764	83 f8 05	 cmp	 eax, 5
  00767	76 2e		 jbe	 SHORT $LN9@VmLoadDefa

; 399  : 		}
; 400  : 		else
; 401  : 		{
; 402  : 			ULONG Size = 0;
; 403  : 			while (*(PVOID*)((PUCHAR)HandlerTable[i] + Size) != (PVOID)INSTRUCTION_JMP_NUMBER_R)

  00769	49 8b 34 24	 mov	 rsi, QWORD PTR [r12]
  0076d	33 db		 xor	 ebx, ebx
  0076f	48 39 0e	 cmp	 QWORD PTR [rsi], rcx
  00772	74 08		 je	 SHORT $LN6@VmLoadDefa
$LL5@VmLoadDefa:

; 404  : 				++Size;

  00774	ff c3		 inc	 ebx
  00776	48 39 0c 33	 cmp	 QWORD PTR [rbx+rsi], rcx
  0077a	75 f8		 jne	 SHORT $LL5@VmLoadDefa
$LN6@VmLoadDefa:

; 405  : 			Assembler->Instructions[i].Code = malloc(Size);

  0077c	8b cb		 mov	 ecx, ebx
  0077e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 406  : 			memcpy(Assembler->Instructions[i].Code, HandlerTable[i], Size);

  00784	44 8b c3	 mov	 r8d, ebx
  00787	48 8b d6	 mov	 rdx, rsi
  0078a	48 8b c8	 mov	 rcx, rax
  0078d	49 89 06	 mov	 QWORD PTR [r14], rax
  00790	e8 00 00 00 00	 call	 memcpy

; 407  : 			Assembler->Instructions[i].Size = Size;

  00795	eb 2b		 jmp	 SHORT $LN2@VmLoadDefa
$LN9@VmLoadDefa:

; 395  : 		{
; 396  : 			Assembler->Instructions[i].Code = malloc(JCC_INSTRUCTION_LENGTH);

  00797	b9 16 00 00 00	 mov	 ecx, 22
  0079c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 397  : 			memcpy(Assembler->Instructions[i].Code, HandlerTable[i], JCC_INSTRUCTION_LENGTH);

  007a2	49 8b 14 24	 mov	 rdx, QWORD PTR [r12]

; 398  : 			Assembler->Instructions[i].Size = JCC_INSTRUCTION_LENGTH;

  007a6	bb 16 00 00 00	 mov	 ebx, 22
  007ab	49 89 06	 mov	 QWORD PTR [r14], rax
  007ae	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  007b1	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  007b4	8b 4a 10	 mov	 ecx, DWORD PTR [rdx+16]
  007b7	89 48 10	 mov	 DWORD PTR [rax+16], ecx
  007ba	0f b7 4a 14	 movzx	 ecx, WORD PTR [rdx+20]
  007be	66 89 48 14	 mov	 WORD PTR [rax+20], cx
$LN2@VmLoadDefa:

; 390  : 	}
; 391  : 
; 392  : 	for (INT i = NOP; i < MAX_INSTRUCTION_ID; i++)

  007c2	41 89 5e fc	 mov	 DWORD PTR [r14-4], ebx
  007c6	41 ff c7	 inc	 r15d
  007c9	49 83 c6 28	 add	 r14, 40			; 00000028H
  007cd	49 83 c4 08	 add	 r12, 8
  007d1	48 b9 48 0f b6
	02 41 ff 24 c0	 mov	 rcx, -4601272264582361272 ; c024ff4102b60f48H
  007db	41 81 ff 8a 00
	00 00		 cmp	 r15d, 138		; 0000008aH
  007e2	0f 8c 78 ff ff
	ff		 jl	 $LL4@VmLoadDefa

; 408  : 		}
; 409  : 	}
; 410  : 
; 411  : 	//SETUP VMEXIT
; 412  : 	Assembler->Instructions[VMEXIT].Code = malloc(4);

  007e8	b9 04 00 00 00	 mov	 ecx, 4
  007ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 413  : 	Assembler->Instructions[VMEXIT].Size = 4;

  007f3	41 c7 45 54 04
	00 00 00	 mov	 DWORD PTR [r13+84], 4

; 414  : 	Assembler->Instructions[VMEXIT].IsUsed = TRUE;
; 415  : 	*((PULONG)Assembler->Instructions[VMEXIT].Code) = 0xC3218B4D;
; 416  : 
; 417  : 	//SETUP VMENTER
; 418  : 	UCHAR VmEnterCode[] = { 0x4D, 0x89, 0x21 };
; 419  : 	Assembler->Instructions[VMENTER].Code = malloc(sizeof(VmEnterCode));

  007fb	b9 03 00 00 00	 mov	 ecx, 3
  00800	49 89 45 58	 mov	 QWORD PTR [r13+88], rax
  00804	41 c6 45 50 01	 mov	 BYTE PTR [r13+80], 1
  00809	c7 00 4d 8b 21
	c3		 mov	 DWORD PTR [rax], -1021211827 ; c3218b4dH
  0080f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00815	49 89 45 30	 mov	 QWORD PTR [r13+48], rax

; 420  : 	memcpy(Assembler->Instructions[VMENTER].Code, VmEnterCode, sizeof(VmEnterCode));
; 421  : 	Assembler->Instructions[VMENTER].Size = sizeof(VmEnterCode);
; 422  : 	Assembler->Instructions[VMENTER].IsUsed = TRUE;
; 423  : 
; 424  : }

  00819	4c 8d 9c 24 20
	08 00 00	 lea	 r11, QWORD PTR [rsp+2080]
  00821	66 c7 00 4d 89	 mov	 WORD PTR [rax], 35149	; 0000894dH
  00826	c6 40 02 21	 mov	 BYTE PTR [rax+2], 33	; 00000021H
  0082a	48 8b bc 24 50
	08 00 00	 mov	 rdi, QWORD PTR [rsp+2128]
  00832	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00836	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  0083a	41 c7 45 2c 03
	00 00 00	 mov	 DWORD PTR [r13+44], 3
  00842	41 c6 45 28 01	 mov	 BYTE PTR [r13+40], 1
  00847	49 8b e3	 mov	 rsp, r11
  0084a	41 5f		 pop	 r15
  0084c	41 5e		 pop	 r14
  0084e	41 5d		 pop	 r13
  00850	41 5c		 pop	 r12
  00852	5d		 pop	 rbp
  00853	c3		 ret	 0
?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z ENDP ; VmLoadDefaultInstructions
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetInstructionLength@@YAHE@Z
_TEXT	SEGMENT
InstructionId$ = 8
?VmGetInstructionLength@@YAHE@Z PROC			; VmGetInstructionLength, COMDAT

; 45   : 	switch (InstructionId)

  00000	0f b6 c1	 movzx	 eax, cl
  00003	ff c8		 dec	 eax
  00005	3d 88 00 00 00	 cmp	 eax, 136		; 00000088H
  0000a	77 3b		 ja	 SHORT $LN2@VmGetInstr
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00013	48 98		 cdqe
  00015	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN10@VmGetInstr[rdx+rax]
  0001d	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN11@VmGetInstr[rdx+rax*4]
  00024	48 03 ca	 add	 rcx, rdx
  00027	ff e1		 jmp	 rcx
$LN4@VmGetInstr:

; 46   : 	{
; 47   : 	case VMEXIT:
; 48   : 	case NOP:
; 49   : 
; 50   : 	case LDAB:
; 51   : 	case LDAW:
; 52   : 	case LDAD:
; 53   : 	case LDAQ:
; 54   : 
; 55   : 	case STAB:
; 56   : 	case STAW:
; 57   : 	case STAD:
; 58   : 	case STAQ:
; 59   : 
; 60   : 	case SXBW:
; 61   : 	case SXBD:
; 62   : 	case SXBQ:
; 63   : 	case SXWD:
; 64   : 	case SXWQ:
; 65   : 	case SXDQ:
; 66   : 
; 67   : 	case ZXBW:
; 68   : 	case ZXBD:
; 69   : 	case ZXBQ:
; 70   : 	case ZXWD:
; 71   : 	case ZXWQ:
; 72   : 	case ZXDQ:
; 73   : 
; 74   : 	case ADDB:
; 75   : 	case ADDW:
; 76   : 	case ADDD:
; 77   : 	case ADDQ:
; 78   : 
; 79   : 	case SUBB:
; 80   : 	case SUBW:
; 81   : 	case SUBD:
; 82   : 	case SUBQ:
; 83   : 
; 84   : 	case MULB:
; 85   : 	case MULW:
; 86   : 	case MULD:
; 87   : 	case MULQ:
; 88   : 
; 89   : 	case DIVB:
; 90   : 	case DIVW:
; 91   : 	case DIVD:
; 92   : 	case DIVQ:
; 93   : 
; 94   : 	case ANDB:
; 95   : 	case ANDW:
; 96   : 	case ANDD:
; 97   : 	case ANDQ:
; 98   : 
; 99   : 	case ORB:
; 100  : 	case ORW:
; 101  : 	case ORD:
; 102  : 	case ORQ:
; 103  : 
; 104  : 	case XORB:
; 105  : 	case XORW:
; 106  : 	case XORD:
; 107  : 	case XORQ:
; 108  : 
; 109  : 	case SHLB:
; 110  : 	case SHLW:
; 111  : 	case SHLD:
; 112  : 	case SHLQ:
; 113  : 
; 114  : 	case SHRB:
; 115  : 	case SHRW:
; 116  : 	case SHRD:
; 117  : 	case SHRQ:
; 118  : 	case CMPB:
; 119  : 	case CMPW:
; 120  : 	case CMPD:
; 121  : 	case CMPQ:
; 122  : 	case RET:
; 123  : 	case X86CALL:
; 124  : 	case SWAPB:
; 125  : 	case SWAPW:
; 126  : 	case SWAPD:
; 127  : 	case SWAPQ:
; 128  : 	case DECB:
; 129  : 	case DECW:
; 130  : 	case DECD:
; 131  : 	case DECQ:
; 132  : 	case INCB:
; 133  : 	case INCW:
; 134  : 	case INCD:
; 135  : 	case INCQ:
; 136  : 	case NPOPB:
; 137  : 	case NPOPW:
; 138  : 	case NPOPD:
; 139  : 	case NPOPQ:
; 140  : 	case SWAPBQ:
; 141  : 	case SWAPWQ:
; 142  : 	case SWAPDQ:
; 143  : 	case JMP:
; 144  : 	{
; 145  : 		return 1;

  00029	b8 01 00 00 00	 mov	 eax, 1

; 215  : }

  0002e	c3		 ret	 0
$LN5@VmGetInstr:

; 146  : 	}
; 147  : 	case LDIB:
; 148  : 	case PUSHB:
; 149  : 	case PUSHW:
; 150  : 	case PUSHD:
; 151  : 	case PUSHQ:
; 152  : 	case POPB:
; 153  : 	case POPW:
; 154  : 	case POPD:
; 155  : 	case POPQ:
; 156  : 	case STSP:
; 157  : 	case LDSP:
; 158  : 	case STIP:
; 159  : 	case LDIP:
; 160  : 	case LDIBSXW:
; 161  : 	case LDIBSXD:
; 162  : 	case LDIBSXQ:
; 163  : 	case LDIBZXW:
; 164  : 	case LDIBZXD:
; 165  : 	case LDIBZXQ:
; 166  : 	{
; 167  : 		return 2;

  0002f	b8 02 00 00 00	 mov	 eax, 2

; 215  : }

  00034	c3		 ret	 0
$LN6@VmGetInstr:

; 168  : 	}
; 169  : 	case LDIW:
; 170  : 	case EDITSP:
; 171  : 	case LDIWSXD:
; 172  : 	case LDIWSXQ:
; 173  : 	case LDIWZXD:
; 174  : 	case LDIWZXQ:
; 175  : 	case LDBPB:
; 176  : 	case LDBPW:
; 177  : 	case LDBPD:
; 178  : 	case LDBPQ:
; 179  : 	case STBPB:
; 180  : 	case STBPW:
; 181  : 	case STBPD:
; 182  : 	case STBPQ:
; 183  : 	{
; 184  : 		return 3;

  00035	b8 03 00 00 00	 mov	 eax, 3

; 215  : }

  0003a	c3		 ret	 0
$LN7@VmGetInstr:

; 185  : 	}
; 186  : 	case LDID:
; 187  : 	case LDIDSXQ:
; 188  : 	case LDIDZXQ:
; 189  : 	{
; 190  : 		return 5;

  0003b	b8 05 00 00 00	 mov	 eax, 5

; 215  : }

  00040	c3		 ret	 0
$LN8@VmGetInstr:

; 191  : 	}
; 192  : 	case LDIQ:
; 193  : 	case JMPI:
; 194  : 	case JL:
; 195  : 	case JLE:
; 196  : 	case JG:
; 197  : 	case JGE:
; 198  : 	case JZ:
; 199  : 	case JNZ:
; 200  : 	case CALL:
; 201  : 	case LDSB:
; 202  : 	case LDSW:
; 203  : 	case LDSD:
; 204  : 	case LDSQ:
; 205  : 	case STSB:
; 206  : 	case STSW:
; 207  : 	case STSD:
; 208  : 	case STSQ:
; 209  : 	{
; 210  : 		return 9;

  00041	b8 09 00 00 00	 mov	 eax, 9

; 215  : }

  00046	c3		 ret	 0
$LN2@VmGetInstr:

; 211  : 	}
; 212  : 
; 213  : 	}
; 214  : 	return 0;

  00047	33 c0		 xor	 eax, eax

; 215  : }

  00049	c3		 ret	 0
  0004a	66 90		 npad	 2
$LN11@VmGetInstr:
  0004c	00 00 00 00	 DD	 $LN4@VmGetInstr
  00050	00 00 00 00	 DD	 $LN5@VmGetInstr
  00054	00 00 00 00	 DD	 $LN6@VmGetInstr
  00058	00 00 00 00	 DD	 $LN7@VmGetInstr
  0005c	00 00 00 00	 DD	 $LN8@VmGetInstr
$LN10@VmGetInstr:
  00060	00		 DB	 0
  00061	00		 DB	 0
  00062	01		 DB	 1
  00063	02		 DB	 2
  00064	03		 DB	 3
  00065	04		 DB	 4
  00066	01		 DB	 1
  00067	01		 DB	 1
  00068	01		 DB	 1
  00069	02		 DB	 2
  0006a	02		 DB	 2
  0006b	03		 DB	 3
  0006c	01		 DB	 1
  0006d	01		 DB	 1
  0006e	01		 DB	 1
  0006f	02		 DB	 2
  00070	02		 DB	 2
  00071	03		 DB	 3
  00072	00		 DB	 0
  00073	00		 DB	 0
  00074	00		 DB	 0
  00075	00		 DB	 0
  00076	00		 DB	 0
  00077	00		 DB	 0
  00078	00		 DB	 0
  00079	00		 DB	 0
  0007a	00		 DB	 0
  0007b	00		 DB	 0
  0007c	00		 DB	 0
  0007d	00		 DB	 0
  0007e	00		 DB	 0
  0007f	00		 DB	 0
  00080	00		 DB	 0
  00081	00		 DB	 0
  00082	00		 DB	 0
  00083	00		 DB	 0
  00084	00		 DB	 0
  00085	00		 DB	 0
  00086	01		 DB	 1
  00087	01		 DB	 1
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	01		 DB	 1
  0008b	01		 DB	 1
  0008c	01		 DB	 1
  0008d	01		 DB	 1
  0008e	00		 DB	 0
  0008f	00		 DB	 0
  00090	00		 DB	 0
  00091	00		 DB	 0
  00092	00		 DB	 0
  00093	00		 DB	 0
  00094	00		 DB	 0
  00095	00		 DB	 0
  00096	00		 DB	 0
  00097	00		 DB	 0
  00098	00		 DB	 0
  00099	00		 DB	 0
  0009a	00		 DB	 0
  0009b	00		 DB	 0
  0009c	00		 DB	 0
  0009d	00		 DB	 0
  0009e	00		 DB	 0
  0009f	00		 DB	 0
  000a0	00		 DB	 0
  000a1	00		 DB	 0
  000a2	00		 DB	 0
  000a3	00		 DB	 0
  000a4	00		 DB	 0
  000a5	00		 DB	 0
  000a6	00		 DB	 0
  000a7	00		 DB	 0
  000a8	00		 DB	 0
  000a9	00		 DB	 0
  000aa	00		 DB	 0
  000ab	00		 DB	 0
  000ac	00		 DB	 0
  000ad	00		 DB	 0
  000ae	00		 DB	 0
  000af	00		 DB	 0
  000b0	00		 DB	 0
  000b1	00		 DB	 0
  000b2	00		 DB	 0
  000b3	00		 DB	 0
  000b4	00		 DB	 0
  000b5	00		 DB	 0
  000b6	00		 DB	 0
  000b7	00		 DB	 0
  000b8	00		 DB	 0
  000b9	00		 DB	 0
  000ba	00		 DB	 0
  000bb	04		 DB	 4
  000bc	04		 DB	 4
  000bd	04		 DB	 4
  000be	04		 DB	 4
  000bf	04		 DB	 4
  000c0	04		 DB	 4
  000c1	04		 DB	 4
  000c2	04		 DB	 4
  000c3	00		 DB	 0
  000c4	00		 DB	 0
  000c5	02		 DB	 2
  000c6	01		 DB	 1
  000c7	01		 DB	 1
  000c8	01		 DB	 1
  000c9	01		 DB	 1
  000ca	00		 DB	 0
  000cb	00		 DB	 0
  000cc	00		 DB	 0
  000cd	00		 DB	 0
  000ce	00		 DB	 0
  000cf	00		 DB	 0
  000d0	00		 DB	 0
  000d1	00		 DB	 0
  000d2	00		 DB	 0
  000d3	00		 DB	 0
  000d4	00		 DB	 0
  000d5	00		 DB	 0
  000d6	00		 DB	 0
  000d7	00		 DB	 0
  000d8	00		 DB	 0
  000d9	04		 DB	 4
  000da	04		 DB	 4
  000db	04		 DB	 4
  000dc	04		 DB	 4
  000dd	04		 DB	 4
  000de	04		 DB	 4
  000df	04		 DB	 4
  000e0	04		 DB	 4
  000e1	02		 DB	 2
  000e2	02		 DB	 2
  000e3	02		 DB	 2
  000e4	02		 DB	 2
  000e5	02		 DB	 2
  000e6	02		 DB	 2
  000e7	02		 DB	 2
  000e8	02		 DB	 2
?VmGetInstructionLength@@YAHE@Z ENDP			; VmGetInstructionLength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z
_TEXT	SEGMENT
Register$ = 64
Id$ = 72
?VmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z PROC ; VmGetRegisterId, COMDAT

; 32   : {

$LN35:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00018	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]

; 4096 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  0001c	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:?RegisterBindings@@3PAPEBDA ; RegisterBindings
  00023	48 8b 71 10	 mov	 rsi, QWORD PTR [rcx+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 32   : {

  00027	4c 8b f2	 mov	 r14, rdx
  0002a	48 8b f9	 mov	 rdi, rcx

; 33   : 	for (INT i = 0; i < ARRAYSIZE(RegisterBindings); i++)

  0002d	33 db		 xor	 ebx, ebx
  0002f	90		 npad	 1
$LL4@VmGetRegis:

; 34   : 	{
; 35   : 		if (Register == RegisterBindings[i])

  00030	48 63 c3	 movsxd	 rax, ebx
  00033	49 8b 14 c7	 mov	 rdx, QWORD PTR [r15+rax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 318  :             return __builtin_strlen(_First);

  00037	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0003e	66 90		 npad	 2
$LL32@VmGetRegis:
  00040	48 ff c0	 inc	 rax
  00043	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00047	75 f7		 jne	 SHORT $LL32@VmGetRegis

; 2144 :         const value_type* _Result = _Bx._Buf;

  00049	48 8b cf	 mov	 rcx, rdi

; 2153 :         return _BUF_SIZE <= _Myres;

  0004c	48 83 fd 10	 cmp	 rbp, 16

; 2145 :         if (_Large_string_engaged()) {

  00050	72 03		 jb	 SHORT $LN14@VmGetRegis

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00052	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
$LN14@VmGetRegis:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00055	48 3b f0	 cmp	 rsi, rax
  00058	75 0c		 jne	 SHORT $LN20@VmGetRegis

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  0005a	4c 8b c6	 mov	 r8, rsi
  0005d	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00062	85 c0		 test	 eax, eax
  00064	74 22		 je	 SHORT $LN25@VmGetRegis
$LN20@VmGetRegis:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 33   : 	for (INT i = 0; i < ARRAYSIZE(RegisterBindings); i++)

  00066	ff c3		 inc	 ebx
  00068	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0006b	72 c3		 jb	 SHORT $LL4@VmGetRegis

; 39   : 		}
; 40   : 	}
; 41   : 	return FALSE;

  0006d	33 c0		 xor	 eax, eax
$LN1@VmGetRegis:

; 42   : }

  0006f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00074	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00079	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	41 5f		 pop	 r15
  00084	41 5e		 pop	 r14
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
$LN25@VmGetRegis:

; 36   : 		{
; 37   : 			*Id = i;

  00088	41 88 1e	 mov	 BYTE PTR [r14], bl

; 38   : 			return TRUE;

  0008b	b8 01 00 00 00	 mov	 eax, 1
  00090	eb dd		 jmp	 SHORT $LN1@VmGetRegis
?VmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ENDP ; VmGetRegisterId
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmGetInstructionId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z
_TEXT	SEGMENT
Instruction$ = 64
OpCode$ = 72
?VmGetInstructionId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z PROC ; VmGetInstructionId, COMDAT

; 20   : {

$LN35:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  00018	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]

; 4096 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  0001c	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:?InstructionBindings@@3PAPEBDA ; InstructionBindings
  00023	48 8b 71 10	 mov	 rsi, QWORD PTR [rcx+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 20   : {

  00027	4c 8b f2	 mov	 r14, rdx
  0002a	48 8b f9	 mov	 rdi, rcx

; 21   : 	for (INT i = 0; i < ARRAYSIZE(InstructionBindings); i++)

  0002d	33 db		 xor	 ebx, ebx
  0002f	90		 npad	 1
$LL4@VmGetInstr:

; 22   : 	{
; 23   : 		if (Instruction == InstructionBindings[i])

  00030	48 63 c3	 movsxd	 rax, ebx
  00033	49 8b 14 c7	 mov	 rdx, QWORD PTR [r15+rax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 318  :             return __builtin_strlen(_First);

  00037	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0003e	66 90		 npad	 2
$LL32@VmGetInstr:
  00040	48 ff c0	 inc	 rax
  00043	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00047	75 f7		 jne	 SHORT $LL32@VmGetInstr

; 2144 :         const value_type* _Result = _Bx._Buf;

  00049	48 8b cf	 mov	 rcx, rdi

; 2153 :         return _BUF_SIZE <= _Myres;

  0004c	48 83 fd 10	 cmp	 rbp, 16

; 2145 :         if (_Large_string_engaged()) {

  00050	72 03		 jb	 SHORT $LN14@VmGetInstr

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00052	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
$LN14@VmGetInstr:

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00055	48 3b f0	 cmp	 rsi, rax
  00058	75 0c		 jne	 SHORT $LN20@VmGetInstr

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  0005a	4c 8b c6	 mov	 r8, rsi
  0005d	e8 00 00 00 00	 call	 memcmp

; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00062	85 c0		 test	 eax, eax
  00064	74 25		 je	 SHORT $LN25@VmGetInstr
$LN20@VmGetInstr:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 21   : 	for (INT i = 0; i < ARRAYSIZE(InstructionBindings); i++)

  00066	ff c3		 inc	 ebx
  00068	81 fb 8a 00 00
	00		 cmp	 ebx, 138		; 0000008aH
  0006e	72 c0		 jb	 SHORT $LL4@VmGetInstr

; 27   : 		}
; 28   : 	}
; 29   : 	return FALSE;

  00070	33 c0		 xor	 eax, eax
$LN1@VmGetInstr:

; 30   : }

  00072	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00077	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0007c	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	41 5f		 pop	 r15
  00087	41 5e		 pop	 r14
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
$LN25@VmGetInstr:

; 24   : 		{
; 25   : 			*OpCode = i;

  0008b	41 88 1e	 mov	 BYTE PTR [r14], bl

; 26   : 			return TRUE;

  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	eb dd		 jmp	 SHORT $LN1@VmGetInstr
?VmGetInstructionId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ENDP ; VmGetInstructionId
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp
;	COMDAT ?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$1$ = 40
Div$GSCopy$1$ = 48
__$ReturnUdt$GSCopy$ = 56
token$2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
Str$ = 184
Div$ = 192
?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; VmTokenizeLine, COMDAT

; 4    : {

$LN134:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00023	4c 89 44 24 30	 mov	 QWORD PTR Div$GSCopy$1$[rsp], r8
  00028	4c 8b f2	 mov	 r14, rdx
  0002b	4c 8b f9	 mov	 r15, rcx
  0002e	48 89 4c 24 28	 mov	 QWORD PTR __$ReturnUdt$GSCopy$1$[rsp], rcx
  00033	48 89 4c 24 38	 mov	 QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
  00038	33 c9		 xor	 ecx, ecx
  0003a	89 4c 24 20	 mov	 DWORD PTR $T1[rsp], ecx
  0003e	0f 57 c0	 xorps	 xmm0, xmm0
  00041	41 0f 11 07	 movups	 XMMWORD PTR [r15], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00045	49 89 0f	 mov	 QWORD PTR [r15], rcx
  00048	49 89 4f 08	 mov	 QWORD PTR [r15+8], rcx
  0004c	49 89 4f 10	 mov	 QWORD PTR [r15+16], rcx
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 17   : 	return Values;

  00050	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 5    : 	VECTOR<STRING> Values;
; 6    : 	size_t PrevPos = 0, CurPos = 0;

  00058	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 702  :         auto& _My_data   = _Mypair._Myval2;

  0005a	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0005e	66 90		 npad	 2
$LL4@VmTokenize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 3867 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

  00060	49 8b 78 10	 mov	 rdi, QWORD PTR [r8+16]

; 2144 :         const value_type* _Result = _Bx._Buf;

  00064	49 8b e8	 mov	 rbp, r8

; 2145 :         if (_Large_string_engaged()) {

  00067	49 83 78 18 10	 cmp	 QWORD PTR [r8+24], 16
  0006c	72 03		 jb	 SHORT $LN23@VmTokenize

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  0006e	49 8b 28	 mov	 rbp, QWORD PTR [r8]
$LN23@VmTokenize:

; 2144 :         const value_type* _Result = _Bx._Buf;

  00071	4d 8b ee	 mov	 r13, r14

; 2145 :         if (_Large_string_engaged()) {

  00074	49 83 7e 18 10	 cmp	 QWORD PTR [r14+24], 16
  00079	72 03		 jb	 SHORT $LN128@VmTokenize

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  0007b	4d 8b 2e	 mov	 r13, QWORD PTR [r14]
$LN128@VmTokenize:

; 533  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  0007e	48 3b f8	 cmp	 rdi, rax
  00081	77 7b		 ja	 SHORT $LN126@VmTokenize
  00083	48 8b c8	 mov	 rcx, rax
  00086	48 2b cf	 sub	 rcx, rdi
  00089	48 3b f1	 cmp	 rsi, rcx
  0008c	77 70		 ja	 SHORT $LN126@VmTokenize

; 534  :         // xpos cannot exist, report failure
; 535  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 536  :         // 1. _Start_at <= xpos
; 537  :         // 2. xpos + _Needle_size <= _Hay_size;
; 538  :         // therefore:
; 539  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 540  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 541  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 542  :         return static_cast<size_t>(-1);
; 543  :     }
; 544  : 
; 545  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  0008e	48 85 ff	 test	 rdi, rdi
  00091	75 05		 jne	 SHORT $LN38@VmTokenize

; 546  :         return _Start_at;

  00093	48 8b de	 mov	 rbx, rsi
  00096	eb 60		 jmp	 SHORT $LN34@VmTokenize
$LN38@VmTokenize:

; 547  :     }
; 548  : 
; 549  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00098	4e 8d 3c 29	 lea	 r15, QWORD PTR [rcx+r13]

; 550  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  0009c	4a 8d 0c 2e	 lea	 rcx, QWORD PTR [rsi+r13]

; 353  :             return __builtin_char_memchr(_First, _Ch, _Count);

  000a0	44 0f be 65 00	 movsx	 r12d, BYTE PTR [rbp]

; 551  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  000a5	4d 8d 47 01	 lea	 r8, QWORD PTR [r15+1]
  000a9	4c 2b c1	 sub	 r8, rcx

; 353  :             return __builtin_char_memchr(_First, _Ch, _Count);

  000ac	41 8b d4	 mov	 edx, r12d
  000af	e8 00 00 00 00	 call	 memchr
  000b4	48 8b d8	 mov	 rbx, rax

; 552  :         if (!_Match_try) { // didn't find first character; report failure

  000b7	48 85 c0	 test	 rax, rax
  000ba	74 42		 je	 SHORT $LN126@VmTokenize
  000bc	0f 1f 40 00	 npad	 4
$LL35@VmTokenize:

; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  000c0	4c 8b c7	 mov	 r8, rdi
  000c3	48 8b d5	 mov	 rdx, rbp
  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	e8 00 00 00 00	 call	 memcmp

; 556  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  000ce	85 c0		 test	 eax, eax
  000d0	74 1f		 je	 SHORT $LN117@VmTokenize

; 550  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  000d2	48 ff c3	 inc	 rbx

; 551  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  000d5	4d 8d 47 01	 lea	 r8, QWORD PTR [r15+1]
  000d9	4c 2b c3	 sub	 r8, rbx

; 353  :             return __builtin_char_memchr(_First, _Ch, _Count);

  000dc	41 8b d4	 mov	 edx, r12d
  000df	48 8b cb	 mov	 rcx, rbx
  000e2	e8 00 00 00 00	 call	 memchr
  000e7	48 8b d8	 mov	 rbx, rax

; 552  :         if (!_Match_try) { // didn't find first character; report failure

  000ea	48 85 c0	 test	 rax, rax
  000ed	75 d1		 jne	 SHORT $LL35@VmTokenize

; 553  :             return static_cast<size_t>(-1);

  000ef	eb 0d		 jmp	 SHORT $LN126@VmTokenize
$LN117@VmTokenize:

; 557  :             return static_cast<size_t>(_Match_try - _Haystack);

  000f1	49 2b dd	 sub	 rbx, r13
  000f4	49 8b 46 10	 mov	 rax, QWORD PTR [r14+16]
$LN34@VmTokenize:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 10   : 		if (CurPos == std::string::npos)

  000f8	48 83 fb ff	 cmp	 rbx, -1
  000fc	75 07		 jne	 SHORT $LN129@VmTokenize
$LN126@VmTokenize:

; 11   : 			CurPos = Str.length();

  000fe	49 8b 5e 10	 mov	 rbx, QWORD PTR [r14+16]
  00102	48 8b c3	 mov	 rax, rbx
$LN129@VmTokenize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00105	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR token$2[rsp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0010e	48 c7 44 24 58
	0f 00 00 00	 mov	 QWORD PTR token$2[rsp+24], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00117	c6 44 24 40 00	 mov	 BYTE PTR token$2[rsp], 0

; 2157 :         if (_Mysize < _Off) {

  0011c	48 3b c6	 cmp	 rax, rsi
  0011f	0f 82 f6 00 00
	00		 jb	 $LN118@VmTokenize
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 12   : 		std::string token = Str.substr(PrevPos, CurPos - PrevPos);

  00125	4c 8b c3	 mov	 r8, rbx
  00128	4c 2b c6	 sub	 r8, rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2174 :         return (_STD min)(_Size, _Mysize - _Off);

  0012b	48 2b c6	 sub	 rax, rsi
  0012e	49 3b c0	 cmp	 rax, r8
  00131	4c 0f 42 c0	 cmovb	 r8, rax

; 2144 :         const value_type* _Result = _Bx._Buf;

  00135	49 8b c6	 mov	 rax, r14

; 2145 :         if (_Large_string_engaged()) {

  00138	49 83 7e 18 10	 cmp	 QWORD PTR [r14+24], 16
  0013d	72 03		 jb	 SHORT $LN127@VmTokenize

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  0013f	49 8b 06	 mov	 rax, QWORD PTR [r14]
$LN127@VmTokenize:

; 2946 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00142	48 8d 14 30	 lea	 rdx, QWORD PTR [rax+rsi]
  00146	48 8d 4c 24 40	 lea	 rcx, QWORD PTR token$2[rsp]
  0014b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 4087 :         return basic_string(*this, _Off, _Count, get_allocator());

  00150	83 4c 24 20 02	 or	 DWORD PTR $T1[rsp], 2
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 13   : 		if (!token.empty())

  00155	4c 8b 7c 24 28	 mov	 r15, QWORD PTR __$ReturnUdt$GSCopy$1$[rsp]
  0015a	48 83 7c 24 50
	00		 cmp	 QWORD PTR token$2[rsp+16], 0
  00160	74 2e		 je	 SHORT $LN80@VmTokenize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00162	49 8b 47 08	 mov	 rax, QWORD PTR [r15+8]
  00166	49 3b 47 10	 cmp	 rax, QWORD PTR [r15+16]
  0016a	74 14		 je	 SHORT $LN81@VmTokenize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0016c	48 8d 54 24 40	 lea	 rdx, QWORD PTR token$2[rsp]
  00171	48 8b c8	 mov	 rcx, rax
  00174	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 690  :         ++_Mylast;

  00179	49 83 47 08 20	 add	 QWORD PTR [r15+8], 32	; 00000020H

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0017e	eb 10		 jmp	 SHORT $LN80@VmTokenize
$LN81@VmTokenize:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00180	4c 8d 44 24 40	 lea	 r8, QWORD PTR token$2[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	49 8b cf	 mov	 rcx, r15
  0018b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN80@VmTokenize:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 15   : 		PrevPos = CurPos + Div.length();

  00190	4c 8b 44 24 30	 mov	 r8, QWORD PTR Div$GSCopy$1$[rsp]
  00195	49 8b 70 10	 mov	 rsi, QWORD PTR [r8+16]
  00199	48 03 f3	 add	 rsi, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  0019c	48 8b 54 24 58	 mov	 rdx, QWORD PTR token$2[rsp+24]
  001a1	48 83 fa 10	 cmp	 rdx, 16

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001a5	72 33		 jb	 SHORT $LN99@VmTokenize

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001a7	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$2[rsp]
  001af	48 8b c1	 mov	 rax, rcx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001b2	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  001b9	72 15		 jb	 SHORT $LN109@VmTokenize

; 134  :     _Bytes += _Non_user_size;

  001bb	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001bf	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  001c3	48 2b c1	 sub	 rax, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c6	48 83 c0 f8	 add	 rax, -8
  001ca	48 83 f8 1f	 cmp	 rax, 31
  001ce	77 44		 ja	 SHORT $LN106@VmTokenize
$LN109@VmTokenize:

; 221  :     ::operator delete(_Ptr, _Bytes);

  001d0	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  001d5	4c 8b 44 24 30	 mov	 r8, QWORD PTR Div$GSCopy$1$[rsp]
$LN99@VmTokenize:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmAssembler.cpp

; 16   : 	} while (CurPos < Str.length() && PrevPos < Str.length());

  001da	49 8b 46 10	 mov	 rax, QWORD PTR [r14+16]
  001de	48 3b d8	 cmp	 rbx, rax
  001e1	73 09		 jae	 SHORT $LN7@VmTokenize
  001e3	48 3b f0	 cmp	 rsi, rax
  001e6	0f 82 74 fe ff
	ff		 jb	 $LL4@VmTokenize
$LN7@VmTokenize:

; 17   : 	return Values;

  001ec	49 8b c7	 mov	 rax, r15

; 18   : }

  001ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001f4	48 33 cc	 xor	 rcx, rsp
  001f7	e8 00 00 00 00	 call	 __security_check_cookie
  001fc	48 8b 9c 24 c8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+200]
  00204	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00208	41 5f		 pop	 r15
  0020a	41 5e		 pop	 r14
  0020c	41 5d		 pop	 r13
  0020e	41 5c		 pop	 r12
  00210	5f		 pop	 rdi
  00211	5e		 pop	 rsi
  00212	5d		 pop	 rbp
  00213	c3		 ret	 0
$LN106@VmTokenize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00214	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0021a	cc		 int	 3
$LN118@VmTokenize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2158 :             _Xran();

  0021b	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00220	cc		 int	 3
$LN131@VmTokenize:
?VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; VmTokenizeLine
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$1$ = 40
Div$GSCopy$1$ = 48
__$ReturnUdt$GSCopy$ = 56
token$2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
Str$ = 184
Div$ = 192
?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA PROC ; `VmTokenizeLine'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN10@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 38	 mov	 rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN10@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA ENDP ; `VmTokenizeLine'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$1$ = 40
Div$GSCopy$1$ = 48
__$ReturnUdt$GSCopy$ = 56
token$2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
Str$ = 184
Div$ = 192
?dtor$1@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA PROC ; `VmTokenizeLine'::`1'::dtor$1
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR token$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA ENDP ; `VmTokenizeLine'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$1$ = 40
Div$GSCopy$1$ = 48
__$ReturnUdt$GSCopy$ = 56
token$2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
Str$ = 184
Div$ = 192
?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA PROC ; `VmTokenizeLine'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN10@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 38	 mov	 rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN10@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA ENDP ; `VmTokenizeLine'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$1$ = 40
Div$GSCopy$1$ = 48
__$ReturnUdt$GSCopy$ = 56
token$2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
Str$ = 184
Div$ = 192
?dtor$1@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA PROC ; `VmTokenizeLine'::`1'::dtor$1
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR token$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??VmTokenizeLine@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA ENDP ; `VmTokenizeLine'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@CAXXZ PROC ; std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1704 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlength:
?_Xlength@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@CAXXZ ENDP ; std::vector<_VM_INSTRUCTION *,std::allocator<_VM_INSTRUCTION *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z PROC ; std::allocator<_VM_INSTRUCTION *>::deallocate, COMDAT

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c2	 mov	 rax, rdx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	4a 8d 14 c5 00
	00 00 00	 lea	 rdx, QWORD PTR [r8*8]

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00016	72 18		 jb	 SHORT $LN15@deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00018	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  0001c	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00020	48 2b c1	 sub	 rax, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00023	48 83 c0 f8	 add	 rax, -8
  00027	48 83 f8 1f	 cmp	 rax, 31
  0002b	77 0f		 ja	 SHORT $LN12@deallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	48 8b c1	 mov	 rax, rcx
$LN15@deallocate:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	48 8b c8	 mov	 rcx, rax

; 804  :     }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 221  :     ::operator delete(_Ptr, _Bytes);

  00037	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@deallocate:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00042	cc		 int	 3
$LN18@deallocate:
?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z ENDP ; std::allocator<_VM_INSTRUCTION *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1704 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlength:
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z PROC	; std::allocator<unsigned char>::deallocate, COMDAT

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c2	 mov	 rax, rdx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00007	49 81 f8 00 10
	00 00		 cmp	 r8, 4096		; 00001000H
  0000e	72 18		 jb	 SHORT $LN15@deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00010	48 8b 4a f8	 mov	 rcx, QWORD PTR [rdx-8]
  00014	49 83 c0 27	 add	 r8, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00018	48 2b c1	 sub	 rax, rcx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001b	48 83 c0 f8	 add	 rax, -8
  0001f	48 83 f8 1f	 cmp	 rax, 31
  00023	77 12		 ja	 SHORT $LN12@deallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00025	48 8b c1	 mov	 rax, rcx
$LN15@deallocate:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00028	49 8b d0	 mov	 rdx, r8
  0002b	48 8b c8	 mov	 rcx, rax

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 804  :     }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 221  :     ::operator delete(_Ptr, _Bytes);

  00032	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@deallocate:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0003d	cc		 int	 3
$LN18@deallocate:
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ENDP	; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??_G_CODE_LINK@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_CODE_LINK@@QEAAPEAXI@Z PROC			; _CODE_LINK::`scalar deleting destructor', COMDAT
$LN39:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  0000f	48 8b 51 38	 mov	 rdx, QWORD PTR [rcx+56]
  00013	48 83 fa 10	 cmp	 rdx, 16

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00017	72 2d		 jb	 SHORT $LN19@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00019	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001d	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00020	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00027	72 18		 jb	 SHORT $LN29@scalar

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00029	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0002d	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00034	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00038	48 83 f8 1f	 cmp	 rax, 31
  0003c	77 3d		 ja	 SHORT $LN26@scalar

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003e	49 8b c8	 mov	 rcx, r8
$LN29@scalar:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00041	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN19@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  00046	48 c7 43 30 00
	00 00 00	 mov	 QWORD PTR [rbx+48], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0004e	48 c7 43 38 0f
	00 00 00	 mov	 QWORD PTR [rbx+56], 15

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00056	c6 43 20 00	 mov	 BYTE PTR [rbx+32], 0
  0005a	40 f6 c7 01	 test	 dil, 1
  0005e	74 0d		 je	 SHORT $LN2@scalar
  00060	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  0006d	48 8b c3	 mov	 rax, rbx
  00070	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
$LN26@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00081	cc		 int	 3
$LN36@scalar:
??_G_CODE_LINK@@QEAAPEAXI@Z ENDP			; _CODE_LINK::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 350  :     ~locale() noexcept {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 351  :         if (_Ptr) {

  00004	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00008	48 85 c9	 test	 rcx, rcx
  0000b	74 1d		 je	 SHORT $LN4@locale

; 352  :             delete _Ptr->_Decref();

  0000d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00010	ff 50 10	 call	 QWORD PTR [rax+16]
  00013	48 85 c0	 test	 rax, rax
  00016	74 12		 je	 SHORT $LN4@locale
  00018	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0001b	ba 01 00 00 00	 mov	 edx, 1
  00020	48 8b c8	 mov	 rcx, rax

; 353  :         }
; 354  :     }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 352  :             delete _Ptr->_Decref();

  00027	49 ff 20	 rex_jmp QWORD PTR [r8]
$LN4@locale:

; 353  :         }
; 354  :     }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 64   : [[noreturn]] inline void _Throw_bad_cast() {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 65   :     _THROW(bad_cast{});

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QEAA@XZ ; std::bad_cast::bad_cast
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
  0001f	cc		 int	 3
$LN3@Throw_bad_:
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN9@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN9@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_typeinfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h

; 67   :         _Data._What = _Message;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast@
  00007	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0
  0000f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_typeinfo.h

; 135  :     {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  0001a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 136  :     }

  0001d	48 8b c1	 mov	 rax, rcx
  00020	c3		 ret	 0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z
_TEXT	SEGMENT
_Eptr$ = 32
__$ArrayPad$ = 40
_Str$ = 80
_Idx$ = 88
_Base$ = 96
?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z PROC ; std::stoi, COMDAT

; 89   : inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {

$LN19:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001b	41 8b e8	 mov	 ebp, r8d
  0001e	48 8b fa	 mov	 rdi, rdx
  00021	48 8b d9	 mov	 rbx, rcx

; 91   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

  0002a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string

; 91   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  0002f	48 8b f0	 mov	 rsi, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2145 :         if (_Large_string_engaged()) {

  00032	72 03		 jb	 SHORT $LN10@stoi

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00034	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN10@stoi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string

; 95   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

  00037	44 8b c5	 mov	 r8d, ebp
  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00040	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Eptr$[rsp]
  00045	48 8b cb	 mov	 rcx, rbx
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol

; 96   : 
; 97   :     if (_Ptr == _Eptr) {

  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Eptr$[rsp]
  00053	48 3b d9	 cmp	 rbx, rcx
  00056	74 2a		 je	 SHORT $LN17@stoi

; 99   :     }
; 100  : 
; 101  :     if (_Errno_ref == ERANGE || _Ans < INT_MIN || INT_MAX < _Ans) {

  00058	83 3e 22	 cmp	 DWORD PTR [rsi], 34	; 00000022H
  0005b	74 32		 je	 SHORT $LN4@stoi

; 103  :     }
; 104  : 
; 105  :     if (_Idx) {

  0005d	48 85 ff	 test	 rdi, rdi
  00060	74 06		 je	 SHORT $LN6@stoi

; 106  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);

  00062	48 2b cb	 sub	 rcx, rbx
  00065	48 89 0f	 mov	 QWORD PTR [rdi], rcx
$LN6@stoi:

; 107  :     }
; 108  : 
; 109  :     return static_cast<int>(_Ans);
; 110  : }

  00068	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006d	48 33 cc	 xor	 rcx, rsp
  00070	e8 00 00 00 00	 call	 __security_check_cookie
  00075	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5f		 pop	 rdi
  0007f	5e		 pop	 rsi
  00080	5d		 pop	 rbp
  00081	c3		 ret	 0
$LN17@stoi:

; 98   :         _Xinvalid_argument("invalid stoi argument");

  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
  00089	e8 00 00 00 00	 call	 ?_Xinvalid_argument@std@@YAXPEBD@Z ; std::_Xinvalid_argument
  0008e	cc		 int	 3
$LN4@stoi:

; 102  :         _Xout_of_range("stoi argument out of range");

  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
  00096	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  0009b	cc		 int	 3
$LN15@stoi:
?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ENDP ; std::stoi
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2964 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN77:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2965 :         // assign [_Ptr, _Ptr + _Count)
; 2966 :         if (_Count <= _Mypair._Myval2._Myres) {

  0000c	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00010	4d 8b f0	 mov	 r14, r8
  00013	4c 8b fa	 mov	 r15, rdx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	4c 3b c5	 cmp	 r8, rbp
  0001c	77 2c		 ja	 SHORT $LN2@assign

; 2135 :         value_type* _Result = _Bx._Buf;

  0001e	48 8b f9	 mov	 rdi, rcx

; 2153 :         return _BUF_SIZE <= _Myres;

  00021	48 83 fd 10	 cmp	 rbp, 16

; 2136 :         if (_Large_string_engaged()) {

  00025	72 03		 jb	 SHORT $LN5@assign

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00027	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
$LN5@assign:

; 2967 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2968 :             _Mypair._Myval2._Mysize = _Count;

  0002a	4c 89 71 10	 mov	 QWORD PTR [rcx+16], r14

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	e8 00 00 00 00	 call	 memmove

; 2979 :             },
; 2980 :             _Ptr);
; 2981 :     }

  00036	48 8b c3	 mov	 rax, rbx
  00039	41 c6 04 3e 00	 mov	 BYTE PTR [r14+rdi], 0
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	41 5f		 pop	 r15
  00044	41 5e		 pop	 r14
  00046	5f		 pop	 rdi
  00047	5d		 pop	 rbp
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
$LN2@assign:

; 4221 :         if (_New_size > max_size()) {

  0004a	48 bf ff ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775807 ; 7fffffffffffffffH
  00054	4c 3b f7	 cmp	 r14, rdi
  00057	0f 87 fa 00 00
	00		 ja	 $LN74@assign

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0005d	49 8b ce	 mov	 rcx, r14
  00060	48 83 c9 0f	 or	 rcx, 15
  00064	48 3b cf	 cmp	 rcx, rdi

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00067	77 1f		 ja	 SHORT $LN18@assign

; 4203 :             return _Max;
; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00069	48 8b d5	 mov	 rdx, rbp
  0006c	48 8b c7	 mov	 rax, rdi
  0006f	48 d1 ea	 shr	 rdx, 1
  00072	48 2b c2	 sub	 rax, rdx
  00075	48 3b e8	 cmp	 rbp, rax
  00078	77 0e		 ja	 SHORT $LN18@assign

; 4207 :             return _Max;
; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	48 8d 04 2a	 lea	 rax, QWORD PTR [rdx+rbp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0007e	48 8b f9	 mov	 rdi, rcx
  00081	48 3b c8	 cmp	 rcx, rax
  00084	48 0f 42 f8	 cmovb	 rdi, rax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00088	48 8b cf	 mov	 rcx, rdi
  0008b	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00090	48 83 c1 01	 add	 rcx, 1
  00094	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0009b	48 0f 42 c8	 cmovb	 rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009f	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000a6	72 2c		 jb	 SHORT $LN27@assign

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000a8	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 116  :     if (_Block_size <= _Bytes) {

  000ac	48 3b c1	 cmp	 rax, rcx
  000af	0f 86 9c 00 00
	00		 jbe	 $LN75@assign

; 77   :         return ::operator new(_Bytes);

  000b5	48 8b c8	 mov	 rcx, rax
  000b8	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000bd	48 85 c0	 test	 rax, rax
  000c0	0f 84 84 00 00
	00		 je	 $LN63@assign

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000c6	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  000ca	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000ce	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000d2	eb 11		 jmp	 SHORT $LN26@assign
$LN27@assign:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  000d4	48 85 c9	 test	 rcx, rcx
  000d7	74 0a		 je	 SHORT $LN28@assign

; 77   :         return ::operator new(_Bytes);

  000d9	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000de	48 8b f0	 mov	 rsi, rax

; 206  :         return _Traits::_Allocate(_Bytes);

  000e1	eb 02		 jmp	 SHORT $LN26@assign
$LN28@assign:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  000e3	33 f6		 xor	 esi, esi
$LN26@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000e5	4d 8b c6	 mov	 r8, r14

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  000e8	4c 89 73 10	 mov	 QWORD PTR [rbx+16], r14

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000ec	49 8b d7	 mov	 rdx, r15

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  000ef	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000f3	48 8b ce	 mov	 rcx, rsi
  000f6	e8 00 00 00 00	 call	 memcpy

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000fb	41 c6 04 36 00	 mov	 BYTE PTR [r14+rsi], 0

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  00100	48 83 fd 10	 cmp	 rbp, 16
  00104	72 2d		 jb	 SHORT $LN13@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00106	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4234 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00109	48 8d 55 01	 lea	 rdx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0010d	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00114	72 18		 jb	 SHORT $LN66@assign

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00116	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0011a	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0011e	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00121	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00125	48 83 f8 1f	 cmp	 rax, 31
  00129	77 1f		 ja	 SHORT $LN63@assign

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0012b	49 8b c8	 mov	 rcx, r8
$LN66@assign:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0012e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2974 :         return _Reallocate_for(

  00133	48 89 33	 mov	 QWORD PTR [rbx], rsi

; 2979 :             },
; 2980 :             _Ptr);
; 2981 :     }

  00136	48 8b c3	 mov	 rax, rbx
  00139	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0013e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00142	41 5f		 pop	 r15
  00144	41 5e		 pop	 r14
  00146	5f		 pop	 rdi
  00147	5d		 pop	 rbp
  00148	5b		 pop	 rbx
  00149	c3		 ret	 0
$LN63@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00150	cc		 int	 3
$LN75@assign:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00151	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00156	cc		 int	 3
$LN74@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4222 :             _Xlen_string(); // result too long

  00157	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0015c	cc		 int	 3
$LN71@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2722 :     ~basic_string() noexcept {

$LN30:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2153 :         return _BUF_SIZE <= _Myres;

  00006	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]

; 2722 :     ~basic_string() noexcept {

  0000a	48 8b d9	 mov	 rbx, rcx

; 2153 :         return _BUF_SIZE <= _Myres;

  0000d	48 83 fa 10	 cmp	 rdx, 16

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00011	72 2c		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00016	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00019	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00020	72 18		 jb	 SHORT $LN22@basic_stri

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00022	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00026	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002a	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002d	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00031	48 83 f8 1f	 cmp	 rax, 31
  00035	77 21		 ja	 SHORT $LN19@basic_stri

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00037	49 8b c8	 mov	 rcx, r8
$LN22@basic_stri:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  0003f	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00047	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004f	c6 03 00	 mov	 BYTE PTR [rbx], 0

; 2730 :     }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0005e	cc		 int	 3
$LN27@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2273 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN50:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  0000f	33 c0		 xor	 eax, eax

; 2273 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00011	48 8b fa	 mov	 rdi, rdx

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00014	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2273 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00018	48 8b d9	 mov	 rbx, rcx

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  0001b	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2153 :         return _BUF_SIZE <= _Myres;

  0001f	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 2656 :         const size_type _Right_size   = _Right_data._Mysize;

  00024	48 8b 6a 10	 mov	 rbp, QWORD PTR [rdx+16]

; 2145 :         if (_Large_string_engaged()) {

  00028	72 03		 jb	 SHORT $LN11@basic_stri

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  0002a	48 8b 3a	 mov	 rdi, QWORD PTR [rdx]
$LN11@basic_stri:
  0002d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 2659 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00032	48 83 fd 10	 cmp	 rbp, 16
  00036	73 0d		 jae	 SHORT $LN8@basic_stri

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00038	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]

; 2662 :             _My_data._Myres  = _BUF_SIZE - 1;

  0003b	be 0f 00 00 00	 mov	 esi, 15

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00040	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2663 :             return;

  00043	eb 6f		 jmp	 SHORT $LN7@basic_stri
$LN8@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 69   :     return _Right < _Left ? _Right : _Left;

  00045	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2667 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0004f	48 8b f5	 mov	 rsi, rbp
  00052	48 83 ce 0f	 or	 rsi, 15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 69   :     return _Right < _Left ? _Right : _Left;

  00056	48 3b f1	 cmp	 rsi, rcx
  00059	48 0f 47 f1	 cmova	 rsi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2668 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  0005d	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00061	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00068	72 2e		 jb	 SHORT $LN22@basic_stri

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0006a	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 116  :     if (_Block_size <= _Bytes) {

  0006e	48 3b c1	 cmp	 rax, rcx
  00071	76 61		 jbe	 SHORT $LN48@basic_stri

; 77   :         return ::operator new(_Bytes);

  00073	48 8b c8	 mov	 rcx, rax
  00076	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0007b	48 8b c8	 mov	 rcx, rax

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0007e	48 85 c0	 test	 rax, rax
  00081	74 0e		 je	 SHORT $LN31@basic_stri

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00083	48 83 c0 27	 add	 rax, 39			; 00000027H
  00087	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0008b	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0008f	eb 11		 jmp	 SHORT $LN23@basic_stri
$LN31@basic_stri:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00097	cc		 int	 3
$LN22@basic_stri:

; 205  :     if (_Bytes != 0) {

  00098	48 85 c9	 test	 rcx, rcx
  0009b	74 05		 je	 SHORT $LN23@basic_stri

; 77   :         return ::operator new(_Bytes);

  0009d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
$LN23@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2670 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000a2	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  000a6	48 89 03	 mov	 QWORD PTR [rbx], rax

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000a9	48 8b d7	 mov	 rdx, rdi
  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 memcpy
$LN7@basic_stri:

; 2278 :     }

  000b4	48 89 6b 10	 mov	 QWORD PTR [rbx+16], rbp
  000b8	48 8b c3	 mov	 rax, rbx
  000bb	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi
  000bf	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000c4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c9	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
$LN48@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 117  :         _Throw_bad_array_new_length(); // add overflow

  000d4	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  000d9	cc		 int	 3
$LN46@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2168 :     [[noreturn]] static void _Xran() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2169 :         _Xout_of_range("invalid string position");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  0000b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  00010	cc		 int	 3
$LN3@Xran:
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2200 : [[noreturn]] inline void _Xlen_string() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2201 :     _Xlength_error("string too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen_strin:
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 321  :     _THROW(bad_array_new_length{});

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
  0001f	cc		 int	 3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN12@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 67   :         _Data._What = _Message;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00007	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0
  0000f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 141  :     {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  0001a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 142  :     }

  0001d	48 8b c1	 mov	 rax, rcx
  00020	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN9@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN9@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN6@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN6@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	48 0f 45 c2	 cmovne	 rax, rdx

; 96   :     }

  00012	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy

; 74   :     }

  00029	48 8b c3	 mov	 rax, rbx
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 956  :     {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	53		 push	 rbx
  00015	57		 push	 rdi
  00016	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);
; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	48 8d 7c 24 58	 lea	 rdi, QWORD PTR _Format$[rsp+8]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002a	48 8b d8	 mov	 rbx, rax

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Format$[rsp]
  00037	45 33 c9	 xor	 r9d, r9d
  0003a	48 8b d3	 mov	 rdx, rbx
  0003d	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 961  :         __crt_va_end(_ArgList);
; 962  :         return _Result;
; 963  :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	5f		 pop	 rdi
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
