; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	printf
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0_VM_INSTRUCTION@@QEAA@XZ			; _VM_INSTRUCTION::_VM_INSTRUCTION
PUBLIC	??1_VM_INSTRUCTION@@QEAA@XZ			; _VM_INSTRUCTION::~_VM_INSTRUCTION
PUBLIC	??1_VM_ASSEMBLER@@QEAA@XZ			; _VM_ASSEMBLER::~_VM_ASSEMBLER
PUBLIC	?AddSection@@YAHPEBD_KKKPEAX@Z			; AddSection
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	main
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_range@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAXPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z ; std::_Destroy_range<std::allocator<_VM_INSTRUCTION *> >
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0L@MIPPAPCL@Finished?4?6@			; `string'
PUBLIC	??_C@_0DL@CFOHLOED@C?3?2Users?2Iizerd?2source?2repos?2St@ ; `string'
PUBLIC	??_C@_0BC@KOBOFFFF@Stack?5change?5is?5?3@	; `string'
PUBLIC	??_C@_0P@ICEAJHEC@?6?5VmEnter?5is?3?6@		; `string'
PUBLIC	??_C@_0CO@PHIBJIAF@C?3?2$Fanta?2VirtualMachine?2x64?2Re@ ; `string'
PUBLIC	??_C@_05PDJBBECF@pause@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YAXPEAX_K1P6AX0@Z2@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__std_terminate:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSize:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_MapViewOfFile:PROC
EXTRN	__imp_UnmapViewOfFile:PROC
EXTRN	__imp_CreateFileMappingA:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_system:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@K@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z:PROC ; VmLoadDefaultInstructions
EXTRN	?VmGetInverseStackChangeForRange@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@H@Z:PROC ; VmGetInverseStackChangeForRange
EXTRN	?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; VmLoadFile
EXTRN	?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z:PROC ; VmAppendJumpsToUsed
EXTRN	?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z:PROC ; VmShuffleUsedHandlerOder
EXTRN	?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z:PROC ; VmGenerateRandomOpCodes
EXTRN	?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z:PROC ; VmAssembleCodeToBuffer
EXTRN	?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z:PROC ; VmAssembleVmToBuffer
EXTRN	?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z:PROC ; VmBuildHandlerTable
EXTRN	?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z:PROC ; VmBuildSymbolTable
EXTRN	?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z:PROC ; VmGetVmEnterOpCode
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+82
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+66
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+60
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+60
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+66
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+43
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN27
	DD	imagerel $LN27+89
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+23
	DD	imagerel $unwind$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN16
	DD	imagerel $LN16+59
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN30
	DD	imagerel $LN30+95
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77
	DD	imagerel $LN77+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77+139
	DD	imagerel $LN77+330
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77+330
	DD	imagerel $LN77+343
	DD	imagerel $chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77+343
	DD	imagerel $LN77+349
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN27
	DD	imagerel $LN27+95
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+88
	DD	imagerel $unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+88
	DD	imagerel $unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_VM_INSTRUCTION@@QEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+88
	DD	imagerel $unwind$??1_VM_INSTRUCTION@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+92
	DD	imagerel $unwind$??1?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+92
	DD	imagerel $unwind$?_Tidy@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_VM_ASSEMBLER@@QEAA@XZ DD imagerel $LN11
	DD	imagerel $LN11+80
	DD	imagerel $unwind$??0_VM_ASSEMBLER@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_VM_ASSEMBLER@@QEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+137
	DD	imagerel $unwind$??1_VM_ASSEMBLER@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MapFile@@YAXPEAXPEAPEAX1K@Z DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$?MapFile@@YAXPEAXPEAPEAX1K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UnMapFile@@YAXPEAX0@Z DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$?UnMapFile@@YAXPEAX0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddSection@@YAHPEBD_KKKPEAX@Z DD imagerel $LN23
	DD	imagerel $LN23+154
	DD	imagerel $unwind$?AddSection@@YAHPEBD_KKKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?AddSection@@YAHPEBD_KKKPEAX@Z DD imagerel $LN23+154
	DD	imagerel $LN23+225
	DD	imagerel $chain$0$?AddSection@@YAHPEBD_KKKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?AddSection@@YAHPEBD_KKKPEAX@Z DD imagerel $LN23+225
	DD	imagerel $LN23+628
	DD	imagerel $chain$1$?AddSection@@YAHPEBD_KKKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?AddSection@@YAHPEBD_KKKPEAX@Z DD imagerel $LN23+628
	DD	imagerel $LN23+633
	DD	imagerel $chain$2$?AddSection@@YAHPEBD_KKKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?AddSection@@YAHPEBD_KKKPEAX@Z DD imagerel $LN23+633
	DD	imagerel $LN23+661
	DD	imagerel $chain$3$?AddSection@@YAHPEBD_KKKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?AddSection@@YAHPEBD_KKKPEAX@Z DD imagerel $LN23+661
	DD	imagerel $LN23+683
	DD	imagerel $chain$4$?AddSection@@YAHPEBD_KKKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?AddSection@@YAHPEBD_KKKPEAX@Z DD imagerel $LN23+683
	DD	imagerel $LN23+687
	DD	imagerel $chain$5$?AddSection@@YAHPEBD_KKKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN99
	DD	imagerel $LN99+457
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD imagerel $LN96
	DD	imagerel $LN96+435
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA DD imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA+59
	DD	imagerel $unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN97
	DD	imagerel $LN97+1121
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN24
	DD	imagerel $LN24+122
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+61
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD imagerel $LN7
	DD	imagerel $LN7+42
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN66
	DD	imagerel $LN66+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN66+39
	DD	imagerel $LN66+289
	DD	imagerel $chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN66+289
	DD	imagerel $LN66+302
	DD	imagerel $chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN66+302
	DD	imagerel $LN66+308
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN18
	DD	imagerel $LN18+53
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+89
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause@
CONST	SEGMENT
??_C@_05PDJBBECF@pause@ DB 'pause', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PHIBJIAF@C?3?2$Fanta?2VirtualMachine?2x64?2Re@
CONST	SEGMENT
??_C@_0CO@PHIBJIAF@C?3?2$Fanta?2VirtualMachine?2x64?2Re@ DB 'C:\$Fanta\Vi'
	DB	'rtualMachine\x64\Release\Test.exe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ICEAJHEC@?6?5VmEnter?5is?3?6@
CONST	SEGMENT
??_C@_0P@ICEAJHEC@?6?5VmEnter?5is?3?6@ DB 0aH, ' VmEnter is:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KOBOFFFF@Stack?5change?5is?5?3@
CONST	SEGMENT
??_C@_0BC@KOBOFFFF@Stack?5change?5is?5?3@ DB 'Stack change is :', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CFOHLOED@C?3?2Users?2Iizerd?2source?2repos?2St@
CONST	SEGMENT
??_C@_0DL@CFOHLOED@C?3?2Users?2Iizerd?2source?2repos?2St@ DB 'C:\Users\Ii'
	DB	'zerd\source\repos\StackMachine\Code\Example.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MIPPAPCL@Finished?4?6@
CONST	SEGMENT
??_C@_0L@MIPPAPCL@Finished?4?6@ DB 'Finished.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 040021H
	DD	045400H
	DD	0c3400H
	DD	imagerel $LN66
	DD	imagerel $LN66+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 043c21H
	DD	0c343cH
	DD	045405H
	DD	imagerel $LN66
	DD	imagerel $LN66+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 050b01H
	DD	0f007420bH
	DD	07003e005H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 04H
	DB	'*'
	DB	00H
	DB	'<'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DB 0eH
	DB	'J'
	DB	00H
	DB	'x'
	DB	02H
	DB	'|'
	DB	04H
	DB	' '
	DB	06H
	DB	0caH
	DB	04H
	DB	'y', 0aH
	DB	02H
	DB	0f4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DB 06H
	DB	0eH
	DD	imagerel __std_terminate
	DB	032H
	DD	imagerel ??1_VM_ASSEMBLER@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$main DB 028H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $ip2state$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0d3e19H
	DD	05a0742dH
	DD	059f642dH
	DD	059e342dH
	DD	0598012dH
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$main
	DD	02cb2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 0eH
	DB	'~'
	DB	00H
	DB	'H'
	DB	02H
	DB	0eeH
	DB	06H
	DB	0c6H
	DB	04H
	DB	'l'
	DB	0aH
	DB	'&'
	DB	0cH
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DB	0fdH, 04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 0cH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __std_terminate
	DB	02eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0eH
	DB	0e2H
	DB	00H
	DB	'T'
	DB	02H
	DB	0b6H
	DB	06H
	DB	0d8H
	DB	04H
	DB	'L'
	DB	0aH
	DB	'&'
	DB	0cH
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	091H, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __std_terminate
	DB	02eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?AddSection@@YAHPEBD_KKKPEAX@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+154
	DD	imagerel $unwind$?AddSection@@YAHPEBD_KKKPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?AddSection@@YAHPEBD_KKKPEAX@Z DD 020021H
	DD	0c7400H
	DD	imagerel $LN23
	DD	imagerel $LN23+154
	DD	imagerel $unwind$?AddSection@@YAHPEBD_KKKPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?AddSection@@YAHPEBD_KKKPEAX@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+154
	DD	imagerel $unwind$?AddSection@@YAHPEBD_KKKPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?AddSection@@YAHPEBD_KKKPEAX@Z DD 021H
	DD	imagerel $LN23+154
	DD	imagerel $LN23+225
	DD	imagerel $chain$0$?AddSection@@YAHPEBD_KKKPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?AddSection@@YAHPEBD_KKKPEAX@Z DD 020821H
	DD	0153408H
	DD	imagerel $LN23+154
	DD	imagerel $LN23+225
	DD	imagerel $chain$0$?AddSection@@YAHPEBD_KKKPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?AddSection@@YAHPEBD_KKKPEAX@Z DD 020521H
	DD	0c7405H
	DD	imagerel $LN23
	DD	imagerel $LN23+154
	DD	imagerel $unwind$?AddSection@@YAHPEBD_KKKPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddSection@@YAHPEBD_KKKPEAX@Z DD 071e19H
	DD	0f00bc20fH
	DD	0d007e009H
	DD	06003c005H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UnMapFile@@YAXPEAX0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MapFile@@YAXPEAXPEAPEAX1K@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_VM_ASSEMBLER@@QEAA@XZ DB 02H
	DB	0ecH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_VM_ASSEMBLER@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_VM_ASSEMBLER@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_VM_ASSEMBLER@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_VM_ASSEMBLER@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_VM_ASSEMBLER@@QEAA@XZ DB 02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_VM_ASSEMBLER@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0_VM_ASSEMBLER@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_VM_ASSEMBLER@@QEAA@XZ DD 020619H
	DD	030025206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_VM_ASSEMBLER@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAU_VM_INSTRUCTION@@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAU_VM_INSTRUCTION@@@std@@QEAAXQEAPEAU_VM_INSTRUCTION@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_VM_INSTRUCTION@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020021H
	DD	0d6400H
	DD	imagerel $LN77
	DD	imagerel $LN77+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	0d6405H
	DD	imagerel $LN77
	DD	imagerel $LN77+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 031a01H
	DD	07016621aH
	DD	03015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00004	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 116  :     if (_Block_size <= _Bytes) {

  00008	48 3b c1	 cmp	 rax, rcx
  0000b	76 28		 jbe	 SHORT $LN16@Allocate_m

; 77   :         return ::operator new(_Bytes);

  0000d	48 8b c8	 mov	 rcx, rax
  00010	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00015	48 8b c8	 mov	 rcx, rax

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00018	48 85 c0	 test	 rax, rax
  0001b	74 11		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0001d	48 83 c0 27	 add	 rax, 39			; 00000027H
  00021	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00025	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
$LN7@Allocate_m:

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00034	cc		 int	 3
$LN16@Allocate_m:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00035	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0003a	cc		 int	 3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

$LN24:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00004	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0000b	72 31		 jb	 SHORT $LN2@Allocate

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0000d	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 116  :     if (_Block_size <= _Bytes) {

  00011	48 3b c1	 cmp	 rax, rcx
  00014	76 3d		 jbe	 SHORT $LN23@Allocate

; 77   :         return ::operator new(_Bytes);

  00016	48 8b c8	 mov	 rcx, rax
  00019	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001e	48 8b c8	 mov	 rcx, rax

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00021	48 85 c0	 test	 rax, rax
  00024	74 11		 je	 SHORT $LN11@Allocate

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00026	48 83 c0 27	 add	 rax, 39			; 00000027H
  0002a	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0002e	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 210  : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
$LN11@Allocate:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0003d	cc		 int	 3
$LN2@Allocate:

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  0003e	48 85 c9	 test	 rcx, rcx
  00041	74 09		 je	 SHORT $LN3@Allocate

; 210  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 77   :         return ::operator new(_Bytes);

  00047	e9 00 00 00 00	 jmp	 ??2@YAPEAX_K@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  0004c	33 c0		 xor	 eax, eax

; 210  : }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
$LN23@Allocate:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00053	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00058	cc		 int	 3
$LN21@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN18:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00004	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0000b	72 18		 jb	 SHORT $LN13@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000d	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00011	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00015	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00018	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0001c	48 83 f8 1f	 cmp	 rax, 31
  00020	77 0c		 ja	 SHORT $LN10@Deallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00022	49 8b c8	 mov	 rcx, r8
$LN13@Deallocate:

; 222  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$LN10@Deallocate:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00034	cc		 int	 3
$LN15@Deallocate:
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAXPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAXPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z PROC ; std::_Destroy_range<std::allocator<_VM_INSTRUCTION *> >, COMDAT

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@PEAU_VM_INSTRUCTION@@@std@@@std@@YAXPEAPEAU_VM_INSTRUCTION@@QEAPEAU1@AEAV?$allocator@PEAU_VM_INSTRUCTION@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<_VM_INSTRUCTION *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00006	c3		 ret	 0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 268  :     _Obj.~_Ty();
; 269  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 110  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 111  : #if !_HAS_EXCEPTIONS
; 112  :             const bool _Zero_uncaught_exceptions = true;
; 113  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 114  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00009	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 115  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 116  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 117  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 118  : 
; 119  :             if (_Zero_uncaught_exceptions) {

  0000e	84 c0		 test	 al, al
  00010	75 0a		 jne	 SHORT $LN2@sentry

; 120  :                 this->_Myostr._Osfx();

  00012	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	90		 npad	 1
$LN2@sentry:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0001c	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0001f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  00026	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 80   :             if (_Rdbuf) {

  0002b	48 85 c9	 test	 rcx, rcx
  0002e	74 07		 je	 SHORT $LN10@sentry

; 81   :                 _Rdbuf->_Unlock();

  00030	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00033	ff 50 10	 call	 QWORD PTR [rax+16]
  00036	90		 npad	 1
$LN10@sentry:

; 121  :             }
; 122  :         }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00004	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00007	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  0000e	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 80   :             if (_Rdbuf) {

  00013	48 85 c9	 test	 rcx, rcx
  00016	74 07		 je	 SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00018	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001b	ff 50 10	 call	 QWORD PTR [rax+16]
  0001e	90		 npad	 1
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp
;	COMDAT main
_TEXT	SEGMENT
Name$ = 48
$T1 = 56
SymbolTableSize$ = 88
Asm$ = 96
CodeSize$ = 10384
VmSize$ = 10388
VmHeader$ = 10400
__$ArrayPad$ = 11440
main	PROC						; COMDAT

; 12   : {

$LN97:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d ac 24 40
	d4 ff ff	 lea	 rbp, QWORD PTR [rsp-11200]
  00020	b8 c0 2c 00 00	 mov	 eax, 11456		; 00002cc0H
  00025	e8 00 00 00 00	 call	 __chkstk
  0002a	48 2b e0	 sub	 rsp, rax
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 85 b0 2b
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0003e	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??1_VM_INSTRUCTION@@QEAA@XZ
  00045	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0_VM_INSTRUCTION@@QEAA@XZ
  00051	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00056	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR Asm$[rsp+16]
  00061	e8 00 00 00 00	 call	 ??_L@YAXPEAX_K1P6AX0@Z2@Z
  00066	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00069	66 0f 7f 85 70
	27 00 00	 movdqa	 XMMWORD PTR Asm$[rbp+10000], xmm0
  00071	45 33 e4	 xor	 r12d, r12d
  00074	4c 89 a5 80 27
	00 00		 mov	 QWORD PTR Asm$[rbp+10016], r12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4293 :         _Mypair._Myval2._Mysize = 0;

  0007b	4c 89 64 24 48	 mov	 QWORD PTR $T1[rsp+16], r12

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00080	48 c7 44 24 50
	0f 00 00 00	 mov	 QWORD PTR $T1[rsp+24], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00089	44 88 64 24 38	 mov	 BYTE PTR $T1[rsp], r12b

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0008e	45 8d 44 24 3a	 lea	 r8d, QWORD PTR [r12+58]
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@CFOHLOED@C?3?2Users?2Iizerd?2source?2repos?2St@
  0009a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T1[rsp]
  0009f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000a4	90		 npad	 1
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp

; 14   : 	VmLoadFile(&Asm, "C:\\Users\\Iizerd\\source\\repos\\StackMachine\\Code\\Example.txt");

  000a5	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T1[rsp]
  000aa	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  000af	e8 00 00 00 00	 call	 ?VmLoadFile@@YAHPEAU_VM_ASSEMBLER@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; VmLoadFile
  000b4	90		 npad	 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000b5	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T1[rsp+24]
  000ba	48 83 fa 10	 cmp	 rdx, 16
  000be	72 35		 jb	 SHORT $LN41@main

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4303 :             auto& _Al          = _Getal();
; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000c0	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T1[rsp]
  000c8	48 8b c1	 mov	 rax, rcx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000cb	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  000d2	72 1c		 jb	 SHORT $LN51@main

; 134  :     _Bytes += _Non_user_size;

  000d4	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000d8	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  000dc	48 2b c1	 sub	 rax, rcx

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000df	48 83 c0 f8	 add	 rax, -8
  000e3	48 83 f8 1f	 cmp	 rax, 31
  000e7	76 07		 jbe	 SHORT $LN51@main
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000ef	cc		 int	 3
$LN51@main:

; 221  :     ::operator delete(_Ptr, _Bytes);

  000f0	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN41@main:
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp

; 26   : 	VmHeader.Magic = 'kctS';

  000f5	c7 85 a0 27 00
	00 53 74 63 6b	 mov	 DWORD PTR VmHeader$[rbp-256], 1801679955 ; 6b637453H

; 27   : 	VmHeader.UnpackerSize = 0;

  000ff	44 89 a5 a8 27
	00 00		 mov	 DWORD PTR VmHeader$[rbp-248], r12d

; 28   : 
; 29   : 	std::cout << "Stack change is :" << VmGetInverseStackChangeForRange(&Asm, Asm.CodeStart->Next, 17) << '\n';

  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@KOBOFFFF@Stack?5change?5is?5?3@
  0010d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00114	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00119	48 8b d8	 mov	 rbx, rax
  0011c	41 b8 11 00 00
	00		 mov	 r8d, 17
  00122	48 8b 54 24 60	 mov	 rdx, QWORD PTR Asm$[rsp]
  00127	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0012a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  0012f	e8 00 00 00 00	 call	 ?VmGetInverseStackChangeForRange@@YAHPEAU_VM_ASSEMBLER@@PEAU_CODE_LINK@@H@Z ; VmGetInverseStackChangeForRange
  00134	8b d0		 mov	 edx, eax
  00136	48 8b cb	 mov	 rcx, rbx
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0013f	48 8b c8	 mov	 rcx, rax
  00142	b2 0a		 mov	 dl, 10
  00144	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 30   : 
; 31   : 	VmLoadDefaultInstructions(&Asm);

  00149	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  0014e	e8 00 00 00 00	 call	 ?VmLoadDefaultInstructions@@YAXPEAU_VM_ASSEMBLER@@@Z ; VmLoadDefaultInstructions

; 32   : 	VmGenerateRandomOpCodes(&Asm);

  00153	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  00158	e8 00 00 00 00	 call	 ?VmGenerateRandomOpCodes@@YAXPEAU_VM_ASSEMBLER@@@Z ; VmGenerateRandomOpCodes

; 33   : 	VmAppendJumpsToUsed(&Asm);

  0015d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  00162	e8 00 00 00 00	 call	 ?VmAppendJumpsToUsed@@YAXPEAU_VM_ASSEMBLER@@@Z ; VmAppendJumpsToUsed

; 34   : 	VmShuffleUsedHandlerOder(&Asm);

  00167	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  0016c	e8 00 00 00 00	 call	 ?VmShuffleUsedHandlerOder@@YAXPEAU_VM_ASSEMBLER@@@Z ; VmShuffleUsedHandlerOder

; 35   : 
; 36   : 	VmBlock = VmAssembleVmToBuffer(&Asm, &VmSize);

  00171	48 8d 95 94 27
	00 00		 lea	 rdx, QWORD PTR VmSize$[rbp-256]
  00178	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  0017d	e8 00 00 00 00	 call	 ?VmAssembleVmToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ; VmAssembleVmToBuffer
  00182	48 8b f0	 mov	 rsi, rax

; 37   : 	CodeBlock = VmAssembleCodeToBuffer(&Asm, &CodeSize);

  00185	48 8d 95 90 27
	00 00		 lea	 rdx, QWORD PTR CodeSize$[rbp-256]
  0018c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  00191	e8 00 00 00 00	 call	 ?VmAssembleCodeToBuffer@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ; VmAssembleCodeToBuffer
  00196	4c 8b f0	 mov	 r14, rax

; 38   : 
; 39   : 	VmBuildHandlerTable(&Asm, VmHeader.HandlerTable);

  00199	48 8d 95 ac 27
	00 00		 lea	 rdx, QWORD PTR VmHeader$[rbp-244]
  001a0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  001a5	e8 00 00 00 00	 call	 ?VmBuildHandlerTable@@YAXPEAU_VM_ASSEMBLER@@PEAK@Z ; VmBuildHandlerTable

; 40   : 	SymbolTable = (PVM_SYMBOL)VmBuildSymbolTable(&Asm, &SymbolTableSize);

  001aa	48 8d 54 24 58	 lea	 rdx, QWORD PTR SymbolTableSize$[rsp]
  001af	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  001b4	e8 00 00 00 00	 call	 ?VmBuildSymbolTable@@YAPEAXPEAU_VM_ASSEMBLER@@PEAK@Z ; VmBuildSymbolTable
  001b9	4c 8b f8	 mov	 r15, rax

; 41   : 
; 42   : 	VmHeader.SymbolTableSize = SymbolTableSize / sizeof(VM_SYMBOL);

  001bc	8b 4c 24 58	 mov	 ecx, DWORD PTR SymbolTableSize$[rsp]
  001c0	48 b8 8f e3 38
	8e e3 38 8e e3	 mov	 rax, -2049638230412172401 ; e38e38e38e38e38fH
  001ca	48 f7 e1	 mul	 rcx
  001cd	48 c1 ea 05	 shr	 rdx, 5
  001d1	89 95 a4 27 00
	00		 mov	 DWORD PTR VmHeader$[rbp-252], edx

; 43   : 	VmHeader.VmEnterOpCode = VmGetVmEnterOpCode(&Asm);

  001d7	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Asm$[rsp]
  001dc	e8 00 00 00 00	 call	 ?VmGetVmEnterOpCode@@YAEPEAU_VM_ASSEMBLER@@@Z ; VmGetVmEnterOpCode
  001e1	88 85 ac 2b 00
	00		 mov	 BYTE PTR VmHeader$[rbp+780], al

; 44   : 
; 45   : 	std::cout << "\n VmEnter is:\n";

  001e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@ICEAJHEC@?6?5VmEnter?5is?3?6@
  001ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001f5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 46   : 	for (INT i = 0; i < Asm.Instructions[0].OpCodes.size(); i++)

  001fa	41 8b dc	 mov	 ebx, r12d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001fd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Asm$[rsp+24]
  00202	48 3b 4c 24 70	 cmp	 rcx, QWORD PTR Asm$[rsp+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp

; 46   : 	for (INT i = 0; i < Asm.Instructions[0].OpCodes.size(); i++)

  00207	74 54		 je	 SHORT $LN3@main
  00209	49 8b fc	 mov	 rdi, r12
  0020c	0f 1f 40 00	 npad	 4
$LL4@main:

; 47   : 	{
; 48   : 		std::cout << i << ' ' << (INT)Asm.Instructions[0].OpCodes[i] << '\n';

  00210	8b d3		 mov	 edx, ebx
  00212	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0021f	48 8b c8	 mov	 rcx, rax
  00222	b2 20		 mov	 dl, 32			; 00000020H
  00224	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
  00229	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Asm$[rsp+16]
  0022e	0f b6 14 39	 movzx	 edx, BYTE PTR [rcx+rdi]
  00232	48 8b c8	 mov	 rcx, rax
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0023b	48 8b c8	 mov	 rcx, rax
  0023e	b2 0a		 mov	 dl, 10
  00240	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 46   : 	for (INT i = 0; i < Asm.Instructions[0].OpCodes.size(); i++)

  00245	ff c3		 inc	 ebx
  00247	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0024b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Asm$[rsp+24]
  00250	48 2b 4c 24 70	 sub	 rcx, QWORD PTR Asm$[rsp+16]
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp

; 46   : 	for (INT i = 0; i < Asm.Instructions[0].OpCodes.size(); i++)

  00255	48 63 c3	 movsxd	 rax, ebx
  00258	48 3b c1	 cmp	 rax, rcx
  0025b	72 b3		 jb	 SHORT $LL4@main
$LN3@main:

; 49   : 	}
; 50   : 	std::cout << '\n';

  0025d	b2 0a		 mov	 dl, 10
  0025f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00266	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 51   : 
; 52   : 
; 53   : 	PVOID meme = malloc(sizeof(VM_HEADER) + SymbolTableSize);

  0026b	8b 4c 24 58	 mov	 ecx, DWORD PTR SymbolTableSize$[rsp]
  0026f	48 81 c1 0d 04
	00 00		 add	 rcx, 1037		; 0000040dH
  00276	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0027d	48 0f 42 c8	 cmovb	 rcx, rax
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00287	48 8b d8	 mov	 rbx, rax

; 54   : 	memcpy(meme, &VmHeader, sizeof(VM_HEADER));

  0028a	48 8b d0	 mov	 rdx, rax
  0028d	48 8d 8d a0 27
	00 00		 lea	 rcx, QWORD PTR VmHeader$[rbp-256]
  00294	41 b8 08 00 00
	00		 mov	 r8d, 8
  0029a	66 0f 1f 44 00
	00		 npad	 6
$LL93@main:
  002a0	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  002a3	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  002a6	0f 10 49 10	 movups	 xmm1, XMMWORD PTR [rcx+16]
  002aa	0f 11 4a 10	 movups	 XMMWORD PTR [rdx+16], xmm1
  002ae	0f 10 41 20	 movups	 xmm0, XMMWORD PTR [rcx+32]
  002b2	0f 11 42 20	 movups	 XMMWORD PTR [rdx+32], xmm0
  002b6	0f 10 49 30	 movups	 xmm1, XMMWORD PTR [rcx+48]
  002ba	0f 11 4a 30	 movups	 XMMWORD PTR [rdx+48], xmm1
  002be	0f 10 41 40	 movups	 xmm0, XMMWORD PTR [rcx+64]
  002c2	0f 11 42 40	 movups	 XMMWORD PTR [rdx+64], xmm0
  002c6	0f 10 49 50	 movups	 xmm1, XMMWORD PTR [rcx+80]
  002ca	0f 11 4a 50	 movups	 XMMWORD PTR [rdx+80], xmm1
  002ce	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]
  002d2	0f 11 42 60	 movups	 XMMWORD PTR [rdx+96], xmm0
  002d6	48 8d 92 80 00
	00 00		 lea	 rdx, QWORD PTR [rdx+128]
  002dd	0f 10 49 70	 movups	 xmm1, XMMWORD PTR [rcx+112]
  002e1	0f 11 4a f0	 movups	 XMMWORD PTR [rdx-16], xmm1
  002e5	48 8d 89 80 00
	00 00		 lea	 rcx, QWORD PTR [rcx+128]
  002ec	49 83 e8 01	 sub	 r8, 1
  002f0	75 ae		 jne	 SHORT $LL93@main
  002f2	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002f5	48 89 02	 mov	 QWORD PTR [rdx], rax
  002f8	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  002fb	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  002fe	0f b6 41 0c	 movzx	 eax, BYTE PTR [rcx+12]
  00302	88 42 0c	 mov	 BYTE PTR [rdx+12], al

; 55   : 	memcpy((PVOID)((ULONG64)meme + sizeof(VM_HEADER)), SymbolTable, SymbolTableSize);

  00305	44 8b 44 24 58	 mov	 r8d, DWORD PTR SymbolTableSize$[rsp]
  0030a	48 8d 8b 0d 04
	00 00		 lea	 rcx, QWORD PTR [rbx+1037]
  00311	49 8b d7	 mov	 rdx, r15
  00314	e8 00 00 00 00	 call	 memcpy

; 56   : 	ULONG64 Name = 0;

  00319	4c 89 64 24 30	 mov	 QWORD PTR Name$[rsp], r12

; 57   : 	CONST CHAR* VMD = ".vmd";
; 58   : 	memcpy(&Name, VMD, 4);

  0031e	c7 44 24 30 2e
	76 6d 64	 mov	 DWORD PTR Name$[rsp], 1684895278 ; 646d762eH

; 59   : 	AddSection("C:\\$Fanta\\VirtualMachine\\x64\\Release\\Test.exe", Name, sizeof(VM_HEADER) + SymbolTableSize, IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE, meme);

  00326	44 8b 44 24 58	 mov	 r8d, DWORD PTR SymbolTableSize$[rsp]
  0032b	41 81 c0 0d 04
	00 00		 add	 r8d, 1037		; 0000040dH
  00332	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00337	41 b9 00 00 00
	c0		 mov	 r9d, -1073741824	; c0000000H
  0033d	48 8b 54 24 30	 mov	 rdx, QWORD PTR Name$[rsp]
  00342	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@PHIBJIAF@C?3?2$Fanta?2VirtualMachine?2x64?2Re@
  00349	e8 00 00 00 00	 call	 ?AddSection@@YAHPEBD_KKKPEAX@Z ; AddSection

; 60   : 	CONST CHAR* VMC = ".vmc";
; 61   : 	memcpy(&Name, VMC, 4);

  0034e	c7 44 24 30 2e
	76 6d 63	 mov	 DWORD PTR Name$[rsp], 1668118062 ; 636d762eH

; 62   : 	AddSection("C:\\$Fanta\\VirtualMachine\\x64\\Release\\Test.exe", Name, CodeSize, IMAGE_SCN_MEM_READ, CodeBlock);

  00356	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0035b	41 b9 00 00 00
	40		 mov	 r9d, 1073741824		; 40000000H
  00361	44 8b 85 90 27
	00 00		 mov	 r8d, DWORD PTR CodeSize$[rbp-256]
  00368	48 8b 54 24 30	 mov	 rdx, QWORD PTR Name$[rsp]
  0036d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@PHIBJIAF@C?3?2$Fanta?2VirtualMachine?2x64?2Re@
  00374	e8 00 00 00 00	 call	 ?AddSection@@YAHPEBD_KKKPEAX@Z ; AddSection

; 63   : 	CONST CHAR* VMH = ".vmh";
; 64   : 	memcpy(&Name, VMH, 4);

  00379	c7 44 24 30 2e
	76 6d 68	 mov	 DWORD PTR Name$[rsp], 1752004142 ; 686d762eH

; 65   : 	AddSection("C:\\$Fanta\\VirtualMachine\\x64\\Release\\Test.exe", Name, VmSize, IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE, VmBlock);

  00381	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00386	41 b9 00 00 00
	60		 mov	 r9d, 1610612736		; 60000000H
  0038c	44 8b 85 94 27
	00 00		 mov	 r8d, DWORD PTR VmSize$[rbp-256]
  00393	48 8b 54 24 30	 mov	 rdx, QWORD PTR Name$[rsp]
  00398	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@PHIBJIAF@C?3?2$Fanta?2VirtualMachine?2x64?2Re@
  0039f	e8 00 00 00 00	 call	 ?AddSection@@YAHPEBD_KKKPEAX@Z ; AddSection

; 66   : 
; 67   : 	system("pause");

  003a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05PDJBBECF@pause@
  003ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_system
  003b1	90		 npad	 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  003b2	48 8b 8d 70 27
	00 00		 mov	 rcx, QWORD PTR Asm$[rbp+10000]
  003b9	48 85 c9	 test	 rcx, rcx
  003bc	74 55		 je	 SHORT $LN67@main

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  003be	48 8b 85 80 27
	00 00		 mov	 rax, QWORD PTR Asm$[rbp+10016]
  003c5	48 2b c1	 sub	 rax, rcx
  003c8	48 c1 f8 03	 sar	 rax, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003cc	48 8d 14 c5 00
	00 00 00	 lea	 rdx, QWORD PTR [rax*8]
  003d4	48 8b c1	 mov	 rax, rcx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003d7	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  003de	72 1c		 jb	 SHORT $LN83@main

; 134  :     _Bytes += _Non_user_size;

  003e0	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003e4	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  003e8	48 2b c1	 sub	 rax, rcx

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003eb	48 83 c0 f8	 add	 rax, -8
  003ef	48 83 f8 1f	 cmp	 rax, 31
  003f3	76 07		 jbe	 SHORT $LN83@main
  003f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  003fb	cc		 int	 3
$LN83@main:

; 221  :     ::operator delete(_Ptr, _Bytes);

  003fc	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00401	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00404	66 0f 7f 85 70
	27 00 00	 movdqa	 XMMWORD PTR Asm$[rbp+10000], xmm0

; 1698 :             _Mylast  = pointer();
; 1699 :             _Myend   = pointer();

  0040c	4c 89 a5 80 27
	00 00		 mov	 QWORD PTR Asm$[rbp+10016], r12
$LN67@main:
  00413	4d 8b cd	 mov	 r9, r13
  00416	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0041b	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00421	48 8d 4c 24 70	 lea	 rcx, QWORD PTR Asm$[rsp+16]
  00426	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  0042b	90		 npad	 1
; File C:\$Fanta\VirtualMachine\DynamicGenerator\main.cpp

; 68   : 	return 1;

  0042c	b8 01 00 00 00	 mov	 eax, 1

; 69   : }

  00431	48 8b 8d b0 2b
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00438	48 33 cc	 xor	 rcx, rsp
  0043b	e8 00 00 00 00	 call	 __security_check_cookie
  00440	4c 8d 9c 24 c0
	2c 00 00	 lea	 r11, QWORD PTR [rsp+11456]
  00448	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0044c	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  00450	49 8b 7b 40	 mov	 rdi, QWORD PTR [r11+64]
  00454	49 8b e3	 mov	 rsp, r11
  00457	41 5f		 pop	 r15
  00459	41 5e		 pop	 r14
  0045b	41 5d		 pop	 r13
  0045d	41 5c		 pop	 r12
  0045f	5d		 pop	 rbp
  00460	c3		 ret	 0
$LN94@main:
main	ENDP
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
Name$ = 48
$T1 = 56
SymbolTableSize$ = 88
Asm$ = 96
CodeSize$ = 10384
VmSize$ = 10388
VmHeader$ = 10400
__$ArrayPad$ = 11440
main$dtor$0 PROC
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR Asm$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_VM_ASSEMBLER@@QEAA@XZ
main$dtor$0 ENDP
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
Name$ = 48
$T1 = 56
SymbolTableSize$ = 88
Asm$ = 96
CodeSize$ = 10384
VmSize$ = 10388
VmHeader$ = 10400
__$ArrayPad$ = 11440
main$dtor$1 PROC
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Name$ = 48
$T1 = 56
SymbolTableSize$ = 88
Asm$ = 96
CodeSize$ = 10384
VmSize$ = 10388
VmHeader$ = 10400
__$ArrayPad$ = 11440
main$dtor$0 PROC
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR Asm$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_VM_ASSEMBLER@@QEAA@XZ
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Name$ = 48
$T1 = 56
SymbolTableSize$ = 88
Asm$ = 96
CodeSize$ = 10384
VmSize$ = 10388
VmHeader$ = 10400
__$ArrayPad$ = 11440
main$dtor$1 PROC
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Ch$ = 104
_State$ = 112
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 780  :     basic_ostream<char, _Traits>& _Ostr, char _Ch) { // insert a char into char stream

$LN96:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	44 0f b6 e2	 movzx	 r12d, dl
  0001a	48 8b f1	 mov	 rsi, rcx

; 781  :     using _Elem = char;
; 782  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 783  : 
; 784  :     ios_base::iostate _State = ios_base::goodbit;

  0001d	33 db		 xor	 ebx, ebx
  0001f	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00023	4c 8b f9	 mov	 r15, rcx
  00026	48 89 4c 24 20	 mov	 QWORD PTR _Ok$[rsp], rcx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

  0002b	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  0002e	49 63 40 04	 movsxd	 rax, DWORD PTR [r8+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  00032	48 8b 4c 08 48	 mov	 rcx, QWORD PTR [rax+rcx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 73   :             if (_Rdbuf) {

  00037	48 85 c9	 test	 rcx, rcx
  0003a	74 09		 je	 SHORT $LN29@operator

; 74   :                 _Rdbuf->_Lock();

  0003c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003f	ff 50 08	 call	 QWORD PTR [rax+8]
  00042	4d 8b 07	 mov	 r8, QWORD PTR [r15]
$LN29@operator:

; 93   :             if (!_Ostr.good()) {

  00045	49 63 48 04	 movsxd	 rcx, DWORD PTR [r8+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  00049	83 7c 31 10 00	 cmp	 DWORD PTR [rcx+rsi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 93   :             if (!_Ostr.good()) {

  0004e	74 04		 je	 SHORT $LN23@operator

; 94   :                 _Ok = false;

  00050	32 c0		 xor	 al, al

; 95   :                 return;

  00052	eb 2b		 jmp	 SHORT $LN91@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 70   :         return _Tiestr;

  00054	48 8b 4c 31 50	 mov	 rcx, QWORD PTR [rcx+rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  00059	48 85 c9	 test	 rcx, rcx
  0005c	74 1f		 je	 SHORT $LN25@operator
  0005e	48 3b ce	 cmp	 rcx, rsi
  00061	74 1a		 je	 SHORT $LN25@operator

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

  00069	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0006c	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  00070	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
  00075	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

  00078	4c 8b c1	 mov	 r8, rcx
  0007b	eb 05		 jmp	 SHORT $LN92@operator
$LN25@operator:

; 100  :                 _Ok = true;

  0007d	b0 01		 mov	 al, 1
$LN91@operator:

; 107  :         }

  0007f	49 8b c8	 mov	 rcx, r8
$LN92@operator:
  00082	88 44 24 28	 mov	 BYTE PTR _Ok$[rsp+8], al

; 785  :     const typename _Myos::sentry _Ok(_Ostr);
; 786  : 
; 787  :     if (_Ok) { // state okay, insert

  00086	84 c0		 test	 al, al
  00088	0f 84 bf 00 00
	00		 je	 $LN20@operator

; 788  :         streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  0008e	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 363  :         return _Wide;

  00092	48 8b 54 30 28	 mov	 rdx, QWORD PTR [rax+rsi+40]

; 326  :         return _Fmtfl;

  00097	8b 4c 30 18	 mov	 ecx, DWORD PTR [rax+rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 790  :         _TRY_IO_BEGIN

  0009b	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  0009f	33 ff		 xor	 edi, edi
  000a1	48 83 fa 01	 cmp	 rdx, 1
  000a5	48 0f 4f f8	 cmovg	 rdi, rax

; 791  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000a9	81 e1 c0 01 00
	00		 and	 ecx, 448		; 000001c0H
  000af	41 be 04 00 00
	00		 mov	 r14d, 4
  000b5	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000b8	74 39		 je	 SHORT $LN86@operator
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL4@operator:

; 792  :             for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left

  000c0	85 db		 test	 ebx, ebx
  000c2	75 79		 jne	 SHORT $LN6@operator
  000c4	48 85 ff	 test	 rdi, rdi
  000c7	7e 27		 jle	 SHORT $LN88@operator

; 793  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000c9	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000cc	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000d0	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000d5	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 393  :         return _Left == _Right;

  000e0	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 793  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000e3	41 0f 44 de	 cmove	 ebx, r14d
  000e7	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx

; 792  :             for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left

  000eb	48 ff cf	 dec	 rdi
  000ee	eb d0		 jmp	 SHORT $LL4@operator
$LN88@operator:
  000f0	4c 8b 06	 mov	 r8, QWORD PTR [rsi]
$LN86@operator:

; 794  :                     _State |= ios_base::badbit;
; 795  :                 }
; 796  :             }
; 797  :         }
; 798  : 
; 799  :         if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {

  000f3	49 63 40 04	 movsxd	 rax, DWORD PTR [r8+4]
  000f7	41 0f b6 d4	 movzx	 edx, r12b
  000fb	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  00106	83 f8 ff	 cmp	 eax, -1
  00109	41 0f 44 de	 cmove	 ebx, r14d
$LN93@operator:

; 800  :             _State |= ios_base::badbit;
; 801  :         }
; 802  : 
; 803  :         for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right

  0010d	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
  00111	85 db		 test	 ebx, ebx
  00113	75 28		 jne	 SHORT $LN6@operator
  00115	48 85 ff	 test	 rdi, rdi
  00118	7e 23		 jle	 SHORT $LN6@operator

; 804  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0011a	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0011d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00121	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00126	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 393  :         return _Left == _Right;

  00131	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 804  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00134	41 0f 44 de	 cmove	 ebx, r14d

; 800  :             _State |= ios_base::badbit;
; 801  :         }
; 802  : 
; 803  :         for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right

  00138	48 ff cf	 dec	 rdi
  0013b	eb d0		 jmp	 SHORT $LN93@operator
$LN6@operator:
  0013d	eb 0e		 jmp	 SHORT $LN20@operator
$LN21@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
  0013f	48 8b 74 24 60	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00144	8b 5c 24 70	 mov	 ebx, DWORD PTR _State$[rsp]
  00148	4c 8b 7c 24 20	 mov	 r15, QWORD PTR _Ok$[rsp]
$LN20@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 805  :                 _State |= ios_base::badbit;
; 806  :             }
; 807  :         }
; 808  :         _CATCH_IO_(ios_base, _Ostr)
; 809  :     }
; 810  : 
; 811  :     _Ostr.width(0);

  0014d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00150	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00154	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 812  :     _Ostr.setstate(_State);

  0015d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00160	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00164	48 03 ce	 add	 rcx, rsi
  00167	45 33 c0	 xor	 r8d, r8d
  0016a	8b d3		 mov	 edx, ebx
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00172	90		 npad	 1

; 114  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00173	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 115  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 116  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 117  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 118  : 
; 119  :             if (_Zero_uncaught_exceptions) {

  00178	84 c0		 test	 al, al
  0017a	75 0a		 jne	 SHORT $LN68@operator

; 120  :                 this->_Myostr._Osfx();

  0017c	49 8b cf	 mov	 rcx, r15
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00185	90		 npad	 1
$LN68@operator:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00186	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00189	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  0018d	4a 8b 4c 39 48	 mov	 rcx, QWORD PTR [rcx+r15+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 80   :             if (_Rdbuf) {

  00192	48 85 c9	 test	 rcx, rcx
  00195	74 07		 je	 SHORT $LN72@operator

; 81   :                 _Rdbuf->_Unlock();

  00197	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0019a	ff 50 10	 call	 QWORD PTR [rax+16]
  0019d	90		 npad	 1
$LN72@operator:

; 813  :     return _Ostr;

  0019e	48 8b c6	 mov	 rax, rsi

; 814  : }

  001a1	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001aa	41 5f		 pop	 r15
  001ac	41 5e		 pop	 r14
  001ae	41 5c		 pop	 r12
  001b0	5f		 pop	 rdi
  001b1	5e		 pop	 rsi
  001b2	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Ch$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Ch$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Ch$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 805  :                 _State |= ios_base::badbit;
; 806  :             }
; 807  :         }
; 808  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Ch$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Ch$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Ch$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 808  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 735  :     const char* _Val) { // insert NTBS into char stream

$LN99:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	4c 8b fa	 mov	 r15, rdx
  00019	48 8b f1	 mov	 rsi, rcx

; 736  :     using _Elem = char;
; 737  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 738  : 
; 739  :     ios_base::iostate _State = ios_base::goodbit;

  0001c	33 db		 xor	 ebx, ebx
  0001e	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 318  :             return __builtin_strlen(_First);

  00022	49 c7 c6 ff ff
	ff ff		 mov	 r14, -1
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL92@operator:
  00030	49 ff c6	 inc	 r14
  00033	42 38 1c 32	 cmp	 BYTE PTR [rdx+r14], bl
  00037	75 f7		 jne	 SHORT $LL92@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 741  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 363  :         return _Wide;

  00040	48 8b 7c 30 28	 mov	 rdi, QWORD PTR [rax+rsi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 741  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00045	48 85 ff	 test	 rdi, rdi
  00048	7e 0a		 jle	 SHORT $LN17@operator
  0004a	49 3b fe	 cmp	 rdi, r14
  0004d	7e 05		 jle	 SHORT $LN17@operator
  0004f	49 2b fe	 sub	 rdi, r14
  00052	eb 02		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00054	33 ff		 xor	 edi, edi
$LN18@operator:

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00056	4c 8b e6	 mov	 r12, rsi
  00059	48 89 74 24 20	 mov	 QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  0005e	4c 8b 44 30 48	 mov	 r8, QWORD PTR [rax+rsi+72]
  00063	48 8b d1	 mov	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 73   :             if (_Rdbuf) {

  00066	4d 85 c0	 test	 r8, r8
  00069	74 0f		 je	 SHORT $LN39@operator

; 74   :                 _Rdbuf->_Lock();

  0006b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0006e	49 8b c8	 mov	 rcx, r8
  00071	ff 50 08	 call	 QWORD PTR [rax+8]
  00074	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00077	48 8b d1	 mov	 rdx, rcx
$LN39@operator:

; 93   :             if (!_Ostr.good()) {

  0007a	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  0007e	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 93   :             if (!_Ostr.good()) {

  00083	74 04		 je	 SHORT $LN33@operator

; 94   :                 _Ok = false;

  00085	32 c0		 xor	 al, al

; 95   :                 return;

  00087	eb 2e		 jmp	 SHORT $LN95@operator
$LN33@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 70   :         return _Tiestr;

  00089	48 8b 44 30 50	 mov	 rax, QWORD PTR [rax+rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  0008e	48 85 c0	 test	 rax, rax
  00091	74 22		 je	 SHORT $LN35@operator
  00093	48 3b c6	 cmp	 rax, rsi
  00096	74 1d		 je	 SHORT $LN35@operator

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

  00098	48 8b c8	 mov	 rcx, rax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000a1	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000a4	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  000a8	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
  000ad	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000b0	48 8b d1	 mov	 rdx, rcx
  000b3	eb 02		 jmp	 SHORT $LN95@operator
$LN35@operator:

; 100  :                 _Ok = true;

  000b5	b0 01		 mov	 al, 1
$LN95@operator:

; 107  :         }

  000b7	88 44 24 28	 mov	 BYTE PTR _Ok$[rsp+8], al

; 742  :     const typename _Myos::sentry _Ok(_Ostr);
; 743  : 
; 744  :     if (!_Ok) {

  000bb	84 c0		 test	 al, al
  000bd	75 0a		 jne	 SHORT $LN8@operator

; 745  :         _State |= ios_base::badbit;

  000bf	bb 04 00 00 00	 mov	 ebx, 4

; 746  :     } else { // state okay, insert

  000c4	e9 a9 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 748  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000c9	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 326  :         return _Fmtfl;

  000cd	8b 4c 30 18	 mov	 ecx, DWORD PTR [rax+rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 748  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000d1	81 e1 c0 01 00
	00		 and	 ecx, 448		; 000001c0H
  000d7	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000da	74 2d		 je	 SHORT $LN87@operator
  000dc	0f 1f 40 00	 npad	 4
$LL4@operator:

; 749  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000e0	48 85 ff	 test	 rdi, rdi
  000e3	7e 21		 jle	 SHORT $LN89@operator

; 750  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000e5	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000e8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000ec	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000f1	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000fc	83 f8 ff	 cmp	 eax, -1
  000ff	74 48		 je	 SHORT $LN96@operator

; 749  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00101	48 ff cf	 dec	 rdi
  00104	eb da		 jmp	 SHORT $LL4@operator
$LN89@operator:

; 751  :                     _State |= ios_base::badbit; // insertion failed, quit
; 752  :                     break;
; 753  :                 }
; 754  :             }
; 755  :         }
; 756  : 
; 757  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00106	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN87@operator:
  00109	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  0010d	4d 8b c6	 mov	 r8, r14
  00110	49 8b d7	 mov	 rdx, r15
  00113	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  0011e	49 3b c6	 cmp	 rax, r14
  00121	75 26		 jne	 SHORT $LN96@operator
$LL93@operator:

; 758  :             _State |= ios_base::badbit;
; 759  :         }
; 760  : 
; 761  :         if (_State == ios_base::goodbit) {
; 762  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00123	48 85 ff	 test	 rdi, rdi
  00126	7e 2a		 jle	 SHORT $LN6@operator

; 763  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00128	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0012b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012f	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00134	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	74 05		 je	 SHORT $LN96@operator

; 758  :             _State |= ios_base::badbit;
; 759  :         }
; 760  : 
; 761  :         if (_State == ios_base::goodbit) {
; 762  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00144	48 ff cf	 dec	 rdi
  00147	eb da		 jmp	 SHORT $LL93@operator
$LN96@operator:

; 764  :                     _State |= ios_base::badbit; // insertion failed, quit
; 765  :                     break;
; 766  :                 }
; 767  :             }
; 768  :         }
; 769  : 
; 770  :         _Ostr.width(0);

  00149	bb 04 00 00 00	 mov	 ebx, 4
  0014e	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
$LN6@operator:
  00152	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00155	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00159	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
  00162	eb 0e		 jmp	 SHORT $LN22@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
  00164	48 8b 74 24 60	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00169	8b 5c 24 70	 mov	 ebx, DWORD PTR _State$[rsp]
  0016d	4c 8b 64 24 20	 mov	 r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 774  :     _Ostr.setstate(_State);

  00172	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00175	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00179	48 03 ce	 add	 rcx, rsi
  0017c	45 33 c0	 xor	 r8d, r8d
  0017f	8b d3		 mov	 edx, ebx
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00187	90		 npad	 1

; 114  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00188	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 115  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 116  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 117  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 118  : 
; 119  :             if (_Zero_uncaught_exceptions) {

  0018d	84 c0		 test	 al, al
  0018f	75 0a		 jne	 SHORT $LN72@operator

; 120  :                 this->_Myostr._Osfx();

  00191	49 8b cc	 mov	 rcx, r12
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0019a	90		 npad	 1
$LN72@operator:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0019b	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0019f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios

; 80   :         return _Mystrbuf;

  001a3	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream

; 80   :             if (_Rdbuf) {

  001a8	48 85 c9	 test	 rcx, rcx
  001ab	74 07		 je	 SHORT $LN76@operator

; 81   :                 _Rdbuf->_Unlock();

  001ad	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001b0	ff 50 10	 call	 QWORD PTR [rax+16]
  001b3	90		 npad	 1
$LN76@operator:

; 775  :     return _Ostr;

  001b4	48 8b c6	 mov	 rax, rsi

; 776  : }

  001b7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001bc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c0	41 5f		 pop	 r15
  001c2	41 5e		 pop	 r14
  001c4	41 5c		 pop	 r12
  001c6	5f		 pop	 rdi
  001c7	5e		 pop	 rsi
  001c8	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 771  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 771  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\$Fanta\VirtualMachine\DynamicGenerator\VmSectionAppender.h
;	COMDAT ?AddSection@@YAHPEBD_KKKPEAX@Z
_TEXT	SEGMENT
DataToCopyIn$GSCopy$1$ = 64
FileSizeHi$ = 72
__$ArrayPad$ = 80
Filename$ = 160
Name$ = 168
SectionSize$ = 176
Characteristics$ = 184
DataToCopyIn$ = 192
?AddSection@@YAHPEBD_KKKPEAX@Z PROC			; AddSection, COMDAT

; 24   : {

$LN23:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR DataToCopyIn$[rsp]

; 25   : 	HANDLE FileHandle;
; 26   : 	HANDLE FileMapping;
; 27   : 	PUCHAR FileView;
; 28   : 	ULONG FileSizeLo, FileSizeHi = 0;

  00026	33 f6		 xor	 esi, esi

; 29   : 	PIMAGE_DOS_HEADER DosHeader;
; 30   : 	PIMAGE_NT_HEADERS NtHeaders;
; 31   : 	ULONG FileAlignment;
; 32   : 
; 33   : 	FileHandle = CreateFileA(Filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  00028	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0002d	45 8b e1	 mov	 r12d, r9d
  00030	45 8b f8	 mov	 r15d, r8d
  00033	4c 8b ea	 mov	 r13, rdx
  00036	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  0003e	45 33 c9	 xor	 r9d, r9d
  00041	45 33 c0	 xor	 r8d, r8d
  00044	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  0004c	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  00051	48 89 44 24 40	 mov	 QWORD PTR DataToCopyIn$GSCopy$1$[rsp], rax
  00056	89 74 24 48	 mov	 DWORD PTR FileSizeHi$[rsp], esi
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00060	48 8b e8	 mov	 rbp, rax

; 34   : 	if (FileHandle == INVALID_HANDLE_VALUE)

  00063	48 83 f8 ff	 cmp	 rax, -1
  00067	0f 84 3e 02 00
	00		 je	 $LN20@AddSection

; 35   : 		return FALSE;
; 36   : 
; 37   : 	FileSizeLo = GetFileSize(FileHandle, &FileSizeHi);

  0006d	48 8d 54 24 48	 lea	 rdx, QWORD PTR FileSizeHi$[rsp]
  00072	48 8b c8	 mov	 rcx, rax
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSize
  0007b	44 8b f0	 mov	 r14d, eax

; 38   : 	if (FileSizeHi != NULL)

  0007e	39 74 24 48	 cmp	 DWORD PTR FileSizeHi$[rsp], esi
  00082	0f 85 23 02 00
	00		 jne	 $LN20@AddSection

; 15   : 	*FileMapping = CreateFileMappingA(FileHandle, NULL, PAGE_READWRITE, 0, Size, NULL);

  00088	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  0008d	44 8d 46 04	 lea	 r8d, QWORD PTR [rsi+4]
  00091	45 33 c9	 xor	 r9d, r9d
  00094	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00098	33 d2		 xor	 edx, edx
  0009a	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  0009f	48 8b cd	 mov	 rcx, rbp
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileMappingA

; 16   : 	*FileView = MapViewOfFile(*FileMapping, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

  000a8	45 33 c9	 xor	 r9d, r9d
  000ab	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	8d 56 06	 lea	 edx, QWORD PTR [rsi+6]
  000b6	45 33 c0	 xor	 r8d, r8d
  000b9	48 8b f8	 mov	 rdi, rax
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MapViewOfFile

; 40   : 
; 41   : 	MapFile(FileHandle, &FileMapping, (PVOID*)&FileView, FileSizeLo);
; 42   : 
; 43   : 	DosHeader = (PIMAGE_DOS_HEADER)FileView;
; 44   : 	if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE)

  000c2	b9 4d 5a 00 00	 mov	 ecx, 23117		; 00005a4dH
  000c7	66 39 08	 cmp	 WORD PTR [rax], cx
  000ca	0f 85 c5 01 00
	00		 jne	 $LN19@AddSection

; 45   : 	{
; 46   : 		UnMapFile(FileMapping, FileView);
; 47   : 		return FALSE;
; 48   : 	}
; 49   : 
; 50   : 	NtHeaders = (PIMAGE_NT_HEADERS64)(FileView + DosHeader->e_lfanew);

  000d0	48 63 48 3c	 movsxd	 rcx, DWORD PTR [rax+60]

; 51   : 	if (NtHeaders->Signature != IMAGE_NT_SIGNATURE)

  000d4	81 3c 01 50 45
	00 00		 cmp	 DWORD PTR [rcx+rax], 17744 ; 00004550H
  000db	0f 85 b4 01 00
	00		 jne	 $LN19@AddSection

; 55   : 	}
; 56   : 
; 57   : 	FileAlignment = NtHeaders->OptionalHeader.FileAlignment;

  000e1	48 89 9c 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbx
  000e9	8b 5c 01 3c	 mov	 ebx, DWORD PTR [rcx+rax+60]

; 20   : 	UnmapViewOfFile(FileView);

  000ed	48 8b c8	 mov	 rcx, rax
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnmapViewOfFile

; 21   : 	CloseHandle(FileMapping);

  000f6	48 8b cf	 mov	 rcx, rdi
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 58   : 
; 59   : 	UnMapFile(FileMapping, FileView);
; 60   : 	MapFile(FileHandle, &FileMapping, (PVOID*)&FileView, P2ALIGNUP(FileSizeLo + SectionSize, FileAlignment));

  000ff	43 8d 04 37	 lea	 eax, DWORD PTR [r15+r14]

; 15   : 	*FileMapping = CreateFileMappingA(FileHandle, NULL, PAGE_READWRITE, 0, Size, NULL);

  00103	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi

; 58   : 
; 59   : 	UnMapFile(FileMapping, FileView);
; 60   : 	MapFile(FileHandle, &FileMapping, (PVOID*)&FileView, P2ALIGNUP(FileSizeLo + SectionSize, FileAlignment));

  00108	f7 d8		 neg	 eax

; 15   : 	*FileMapping = CreateFileMappingA(FileHandle, NULL, PAGE_READWRITE, 0, Size, NULL);

  0010a	44 8d 46 04	 lea	 r8d, QWORD PTR [rsi+4]

; 58   : 
; 59   : 	UnMapFile(FileMapping, FileView);
; 60   : 	MapFile(FileHandle, &FileMapping, (PVOID*)&FileView, P2ALIGNUP(FileSizeLo + SectionSize, FileAlignment));

  0010e	f7 db		 neg	 ebx

; 15   : 	*FileMapping = CreateFileMappingA(FileHandle, NULL, PAGE_READWRITE, 0, Size, NULL);

  00110	45 33 c9	 xor	 r9d, r9d

; 58   : 
; 59   : 	UnMapFile(FileMapping, FileView);
; 60   : 	MapFile(FileHandle, &FileMapping, (PVOID*)&FileView, P2ALIGNUP(FileSizeLo + SectionSize, FileAlignment));

  00113	23 c3		 and	 eax, ebx

; 15   : 	*FileMapping = CreateFileMappingA(FileHandle, NULL, PAGE_READWRITE, 0, Size, NULL);

  00115	33 d2		 xor	 edx, edx

; 58   : 
; 59   : 	UnMapFile(FileMapping, FileView);
; 60   : 	MapFile(FileHandle, &FileMapping, (PVOID*)&FileView, P2ALIGNUP(FileSizeLo + SectionSize, FileAlignment));

  00117	f7 d8		 neg	 eax

; 15   : 	*FileMapping = CreateFileMappingA(FileHandle, NULL, PAGE_READWRITE, 0, Size, NULL);

  00119	48 8b cd	 mov	 rcx, rbp
  0011c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileMappingA

; 16   : 	*FileView = MapViewOfFile(*FileMapping, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

  00126	45 33 c9	 xor	 r9d, r9d
  00129	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00132	45 33 c0	 xor	 r8d, r8d
  00135	48 8b c8	 mov	 rcx, rax
  00138	48 8b f0	 mov	 rsi, rax
  0013b	41 8d 51 06	 lea	 edx, QWORD PTR [r9+6]
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MapViewOfFile
  00145	48 8b f8	 mov	 rdi, rax

; 61   : 
; 62   : 	//good paste
; 63   : 	DosHeader = (PIMAGE_DOS_HEADER)FileView;
; 64   : 	NtHeaders = (PIMAGE_NT_HEADERS)((UINT_PTR)FileView + DosHeader->e_lfanew);

  00148	4c 63 48 3c	 movsxd	 r9, DWORD PTR [rax+60]
  0014c	4c 03 c8	 add	 r9, rax

; 65   : 	PIMAGE_FILE_HEADER FileHeader = &(NtHeaders->FileHeader);
; 66   : 	PIMAGE_SECTION_HEADER FirstSectionHeader = (PIMAGE_SECTION_HEADER)(((UINT_PTR)FileHeader) + sizeof(IMAGE_FILE_HEADER) + NtHeaders->FileHeader.SizeOfOptionalHeader);
; 67   : 
; 68   : 	PIMAGE_SECTION_HEADER NewSectionHeader = &FirstSectionHeader[NtHeaders->FileHeader.NumberOfSections]; // Right after last section header.
; 69   : 
; 70   : 	PIMAGE_SECTION_HEADER LastSectionHeader = &FirstSectionHeader[NtHeaders->FileHeader.NumberOfSections - 1];
; 71   : 
; 72   : 	memset(NewSectionHeader, 0, sizeof(IMAGE_SECTION_HEADER));

  0014f	33 c0		 xor	 eax, eax
  00151	41 0f b7 51 06	 movzx	 edx, WORD PTR [r9+6]
  00156	45 0f b7 41 14	 movzx	 r8d, WORD PTR [r9+20]
  0015b	49 83 c0 18	 add	 r8, 24
  0015f	4d 03 c1	 add	 r8, r9
  00162	48 8d 0c 92	 lea	 rcx, QWORD PTR [rdx+rdx*4]
  00166	49 8d 1c c8	 lea	 rbx, QWORD PTR [r8+rcx*8]
  0016a	48 89 43 0c	 mov	 QWORD PTR [rbx+12], rax
  0016e	48 8d 0c 92	 lea	 rcx, QWORD PTR [rdx+rdx*4]
  00172	48 89 43 14	 mov	 QWORD PTR [rbx+20], rax
  00176	49 8d 14 c8	 lea	 rdx, QWORD PTR [r8+rcx*8]
  0017a	48 89 43 1c	 mov	 QWORD PTR [rbx+28], rax
  0017e	89 43 24	 mov	 DWORD PTR [rbx+36], eax

; 73   : 	memcpy(NewSectionHeader->Name, &Name, 8);
; 74   : 	NewSectionHeader->Misc.VirtualSize = SectionSize;

  00181	44 89 7b 08	 mov	 DWORD PTR [rbx+8], r15d
  00185	4c 89 2b	 mov	 QWORD PTR [rbx], r13

; 75   : 	NewSectionHeader->VirtualAddress = P2ALIGNUP(LastSectionHeader->VirtualAddress + LastSectionHeader->Misc.VirtualSize, NtHeaders->OptionalHeader.SectionAlignment);

  00188	8b 4a e4	 mov	 ecx, DWORD PTR [rdx-28]
  0018b	03 4a e0	 add	 ecx, DWORD PTR [rdx-32]
  0018e	41 8b 41 38	 mov	 eax, DWORD PTR [r9+56]
  00192	f7 d9		 neg	 ecx
  00194	f7 d8		 neg	 eax
  00196	23 c8		 and	 ecx, eax

; 76   : 	NewSectionHeader->SizeOfRawData = P2ALIGNUP(SectionSize, NtHeaders->OptionalHeader.FileAlignment);

  00198	41 8b c7	 mov	 eax, r15d
  0019b	f7 d9		 neg	 ecx
  0019d	f7 d8		 neg	 eax
  0019f	89 4b 0c	 mov	 DWORD PTR [rbx+12], ecx
  001a2	41 8b 49 3c	 mov	 ecx, DWORD PTR [r9+60]
  001a6	f7 d9		 neg	 ecx

; 77   : 	NewSectionHeader->PointerToRawData = FileSizeLo;

  001a8	44 89 73 14	 mov	 DWORD PTR [rbx+20], r14d
  001ac	23 c8		 and	 ecx, eax

; 78   : 	NewSectionHeader->Characteristics = Characteristics;

  001ae	44 89 63 24	 mov	 DWORD PTR [rbx+36], r12d
  001b2	f7 d9		 neg	 ecx
  001b4	89 4b 10	 mov	 DWORD PTR [rbx+16], ecx

; 79   : 
; 80   : 	NtHeaders->FileHeader.NumberOfSections++;

  001b7	66 41 ff 41 06	 inc	 WORD PTR [r9+6]

; 81   : 	NtHeaders->OptionalHeader.SizeOfImage = P2ALIGNUP(NewSectionHeader->VirtualAddress + NewSectionHeader->Misc.VirtualSize, NtHeaders->OptionalHeader.SectionAlignment);

  001bc	8b 4b 0c	 mov	 ecx, DWORD PTR [rbx+12]
  001bf	03 4b 08	 add	 ecx, DWORD PTR [rbx+8]
  001c2	41 8b 41 38	 mov	 eax, DWORD PTR [r9+56]
  001c6	f7 d9		 neg	 ecx
  001c8	f7 d8		 neg	 eax
  001ca	23 c8		 and	 ecx, eax
  001cc	f7 d9		 neg	 ecx
  001ce	41 89 49 50	 mov	 DWORD PTR [r9+80], ecx

; 82   : 
; 83   : 
; 84   : 	std::cout << NewSectionHeader->VirtualAddress << ' ' << NewSectionHeader->Misc.VirtualSize << '\n';

  001d2	8b 53 0c	 mov	 edx, DWORD PTR [rbx+12]
  001d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@K@Z
  001e2	48 8b c8	 mov	 rcx, rax
  001e5	b2 20		 mov	 dl, 32			; 00000020H
  001e7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
  001ec	8b 53 08	 mov	 edx, DWORD PTR [rbx+8]
  001ef	48 8b c8	 mov	 rcx, rax
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@K@Z
  001f8	48 8b c8	 mov	 rcx, rax
  001fb	b2 0a		 mov	 dl, 10
  001fd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 85   : 	std::cout << NewSectionHeader->PointerToRawData << ' ' << NewSectionHeader->SizeOfRawData << '\n';

  00202	8b 53 14	 mov	 edx, DWORD PTR [rbx+20]
  00205	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@K@Z
  00212	48 8b c8	 mov	 rcx, rax
  00215	b2 20		 mov	 dl, 32			; 00000020H
  00217	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
  0021c	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  0021f	48 8b c8	 mov	 rcx, rax
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@K@Z
  00228	48 8b c8	 mov	 rcx, rax
  0022b	b2 0a		 mov	 dl, 10
  0022d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 86   : 	//SOMETHING IS BREAKING HERE
; 87   : 	memcpy(FileView + NewSectionHeader->PointerToRawData, DataToCopyIn, SectionSize);

  00232	8b 4b 14	 mov	 ecx, DWORD PTR [rbx+20]
  00235	45 8b c7	 mov	 r8d, r15d
  00238	48 8b 54 24 40	 mov	 rdx, QWORD PTR DataToCopyIn$GSCopy$1$[rsp]
  0023d	48 03 cf	 add	 rcx, rdi
  00240	e8 00 00 00 00	 call	 memcpy

; 20   : 	UnmapViewOfFile(FileView);

  00245	48 8b cf	 mov	 rcx, rdi
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnmapViewOfFile

; 21   : 	CloseHandle(FileMapping);

  0024e	48 8b ce	 mov	 rcx, rsi
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 88   : 
; 89   : 	UnMapFile(FileMapping, FileView);
; 90   : 	printf("Finished.\n");

  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@MIPPAPCL@Finished?4?6@
  0025e	e8 00 00 00 00	 call	 printf

; 91   : 
; 92   : 	CloseHandle(FileHandle);

  00263	48 8b cd	 mov	 rcx, rbp
  00266	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0026c	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+168]
$LN21@AddSection:
  00274	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
$LN1@AddSection:

; 93   : }

  00279	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0027e	48 33 cc	 xor	 rcx, rsp
  00281	e8 00 00 00 00	 call	 __security_check_cookie
  00286	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0028a	41 5f		 pop	 r15
  0028c	41 5e		 pop	 r14
  0028e	41 5d		 pop	 r13
  00290	41 5c		 pop	 r12
  00292	5e		 pop	 rsi
  00293	5d		 pop	 rbp
  00294	c3		 ret	 0
$LN19@AddSection:

; 20   : 	UnmapViewOfFile(FileView);

  00295	48 8b c8	 mov	 rcx, rax
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnmapViewOfFile

; 21   : 	CloseHandle(FileMapping);

  0029e	48 8b cf	 mov	 rcx, rdi
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 52   : 	{
; 53   : 		UnMapFile(FileMapping, FileView);
; 54   : 		return FALSE;

  002a7	33 c0		 xor	 eax, eax
  002a9	eb c9		 jmp	 SHORT $LN21@AddSection
$LN20@AddSection:

; 39   : 		return FALSE;

  002ab	33 c0		 xor	 eax, eax
  002ad	eb ca		 jmp	 SHORT $LN1@AddSection
?AddSection@@YAHPEBD_KKKPEAX@Z ENDP			; AddSection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1_VM_ASSEMBLER@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_VM_ASSEMBLER@@QEAA@XZ PROC				; _VM_ASSEMBLER::~_VM_ASSEMBLER, COMDAT
$LN31:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00009	48 8b 89 10 28
	00 00		 mov	 rcx, QWORD PTR [rcx+10256]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 4b		 je	 SHORT $LN6@VM_ASSEMBL

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00015	48 8b 93 20 28
	00 00		 mov	 rdx, QWORD PTR [rbx+10272]
  0001c	48 2b d1	 sub	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001f	48 83 e2 f8	 and	 rdx, -8

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00023	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0002a	72 18		 jb	 SHORT $LN22@VM_ASSEMBL

; 134  :     _Bytes += _Non_user_size;

  0002c	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00030	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00034	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00037	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0003b	48 83 f8 1f	 cmp	 rax, 31
  0003f	77 41		 ja	 SHORT $LN19@VM_ASSEMBL

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00041	49 8b c8	 mov	 rcx, r8
$LN22@VM_ASSEMBL:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00044	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  00049	33 c0		 xor	 eax, eax
  0004b	48 89 83 10 28
	00 00		 mov	 QWORD PTR [rbx+10256], rax

; 1698 :             _Mylast  = pointer();

  00052	48 89 83 18 28
	00 00		 mov	 QWORD PTR [rbx+10264], rax

; 1699 :             _Myend   = pointer();

  00059	48 89 83 20 28
	00 00		 mov	 QWORD PTR [rbx+10272], rax
$LN6@VM_ASSEMBL:
  00060	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00064	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1_VM_INSTRUCTION@@QEAA@XZ
  0006b	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00070	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00076	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  0007b	90		 npad	 1
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
$LN19@VM_ASSEMBL:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00088	cc		 int	 3
$LN28@VM_ASSEMBL:
??1_VM_ASSEMBLER@@QEAA@XZ ENDP				; _VM_ASSEMBLER::~_VM_ASSEMBLER
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1_VM_INSTRUCTION@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_VM_INSTRUCTION@@QEAA@XZ PROC			; _VM_INSTRUCTION::~_VM_INSTRUCTION, COMDAT
$LN31:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 3a		 je	 SHORT $LN6@VM_INSTRUC

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00011	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00015	48 2b d1	 sub	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00018	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0001f	72 18		 jb	 SHORT $LN22@VM_INSTRUC

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00021	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00025	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00029	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002c	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00030	48 83 f8 1f	 cmp	 rax, 31
  00034	77 1b		 ja	 SHORT $LN19@VM_INSTRUC

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00036	49 8b c8	 mov	 rcx, r8
$LN22@VM_INSTRUC:

; 221  :     ::operator delete(_Ptr, _Bytes);

  00039	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector

; 1697 :             _Myfirst = pointer();

  0003e	33 c0		 xor	 eax, eax
  00040	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1698 :             _Mylast  = pointer();

  00043	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1699 :             _Myend   = pointer();

  00047	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN6@VM_INSTRUC:
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN19@VM_INSTRUC:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00057	cc		 int	 3
$LN28@VM_INSTRUC:
??1_VM_INSTRUCTION@@QEAA@XZ ENDP			; _VM_INSTRUCTION::~_VM_INSTRUCTION
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0_VM_INSTRUCTION@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_VM_INSTRUCTION@@QEAA@XZ PROC			; _VM_INSTRUCTION::_VM_INSTRUCTION, COMDAT

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0_VM_INSTRUCTION@@QEAA@XZ ENDP			; _VM_INSTRUCTION::_VM_INSTRUCTION
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2964 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN77:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2965 :         // assign [_Ptr, _Ptr + _Count)
; 2966 :         if (_Count <= _Mypair._Myval2._Myres) {

  0000c	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00010	4d 8b f0	 mov	 r14, r8
  00013	4c 8b fa	 mov	 r15, rdx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	4c 3b c5	 cmp	 r8, rbp
  0001c	77 2c		 ja	 SHORT $LN2@assign

; 2135 :         value_type* _Result = _Bx._Buf;

  0001e	48 8b f9	 mov	 rdi, rcx

; 2153 :         return _BUF_SIZE <= _Myres;

  00021	48 83 fd 10	 cmp	 rbp, 16

; 2136 :         if (_Large_string_engaged()) {

  00025	72 03		 jb	 SHORT $LN5@assign

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00027	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
$LN5@assign:

; 2967 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2968 :             _Mypair._Myval2._Mysize = _Count;

  0002a	4c 89 71 10	 mov	 QWORD PTR [rcx+16], r14

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	e8 00 00 00 00	 call	 memmove

; 2979 :             },
; 2980 :             _Ptr);
; 2981 :     }

  00036	48 8b c3	 mov	 rax, rbx
  00039	41 c6 04 3e 00	 mov	 BYTE PTR [r14+rdi], 0
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	41 5f		 pop	 r15
  00044	41 5e		 pop	 r14
  00046	5f		 pop	 rdi
  00047	5d		 pop	 rbp
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
$LN2@assign:

; 4221 :         if (_New_size > max_size()) {

  0004a	48 bf ff ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775807 ; 7fffffffffffffffH
  00054	4c 3b f7	 cmp	 r14, rdi
  00057	0f 87 fa 00 00
	00		 ja	 $LN74@assign

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0005d	49 8b ce	 mov	 rcx, r14
  00060	48 83 c9 0f	 or	 rcx, 15
  00064	48 3b cf	 cmp	 rcx, rdi

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00067	77 1f		 ja	 SHORT $LN18@assign

; 4203 :             return _Max;
; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00069	48 8b d5	 mov	 rdx, rbp
  0006c	48 8b c7	 mov	 rax, rdi
  0006f	48 d1 ea	 shr	 rdx, 1
  00072	48 2b c2	 sub	 rax, rdx
  00075	48 3b e8	 cmp	 rbp, rax
  00078	77 0e		 ja	 SHORT $LN18@assign

; 4207 :             return _Max;
; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	48 8d 04 2a	 lea	 rax, QWORD PTR [rdx+rbp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0007e	48 8b f9	 mov	 rdi, rcx
  00081	48 3b c8	 cmp	 rcx, rax
  00084	48 0f 42 f8	 cmovb	 rdi, rax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00088	48 8b cf	 mov	 rcx, rdi
  0008b	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00090	48 83 c1 01	 add	 rcx, 1
  00094	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0009b	48 0f 42 c8	 cmovb	 rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009f	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000a6	72 2c		 jb	 SHORT $LN27@assign

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000a8	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 116  :     if (_Block_size <= _Bytes) {

  000ac	48 3b c1	 cmp	 rax, rcx
  000af	0f 86 9c 00 00
	00		 jbe	 $LN75@assign

; 77   :         return ::operator new(_Bytes);

  000b5	48 8b c8	 mov	 rcx, rax
  000b8	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000bd	48 85 c0	 test	 rax, rax
  000c0	0f 84 84 00 00
	00		 je	 $LN63@assign

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000c6	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  000ca	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000ce	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000d2	eb 11		 jmp	 SHORT $LN26@assign
$LN27@assign:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  000d4	48 85 c9	 test	 rcx, rcx
  000d7	74 0a		 je	 SHORT $LN28@assign

; 77   :         return ::operator new(_Bytes);

  000d9	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000de	48 8b f0	 mov	 rsi, rax

; 206  :         return _Traits::_Allocate(_Bytes);

  000e1	eb 02		 jmp	 SHORT $LN26@assign
$LN28@assign:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  000e3	33 f6		 xor	 esi, esi
$LN26@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000e5	4d 8b c6	 mov	 r8, r14

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  000e8	4c 89 73 10	 mov	 QWORD PTR [rbx+16], r14

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000ec	49 8b d7	 mov	 rdx, r15

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  000ef	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000f3	48 8b ce	 mov	 rcx, rsi
  000f6	e8 00 00 00 00	 call	 memcpy

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000fb	41 c6 04 36 00	 mov	 BYTE PTR [r14+rsi], 0

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  00100	48 83 fd 10	 cmp	 rbp, 16
  00104	72 2d		 jb	 SHORT $LN13@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00106	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4234 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00109	48 8d 55 01	 lea	 rdx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0010d	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00114	72 18		 jb	 SHORT $LN66@assign

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00116	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0011a	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0011e	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00121	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00125	48 83 f8 1f	 cmp	 rax, 31
  00129	77 1f		 ja	 SHORT $LN63@assign

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0012b	49 8b c8	 mov	 rcx, r8
$LN66@assign:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0012e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2974 :         return _Reallocate_for(

  00133	48 89 33	 mov	 QWORD PTR [rbx], rsi

; 2979 :             },
; 2980 :             _Ptr);
; 2981 :     }

  00136	48 8b c3	 mov	 rax, rbx
  00139	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0013e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00142	41 5f		 pop	 r15
  00144	41 5e		 pop	 r14
  00146	5f		 pop	 rdi
  00147	5d		 pop	 rbp
  00148	5b		 pop	 rbx
  00149	c3		 ret	 0
$LN63@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00150	cc		 int	 3
$LN75@assign:

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00151	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00156	cc		 int	 3
$LN74@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4222 :             _Xlen_string(); // result too long

  00157	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0015c	cc		 int	 3
$LN71@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2722 :     ~basic_string() noexcept {

$LN30:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2153 :         return _BUF_SIZE <= _Myres;

  00006	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]

; 2722 :     ~basic_string() noexcept {

  0000a	48 8b d9	 mov	 rbx, rcx

; 2153 :         return _BUF_SIZE <= _Myres;

  0000d	48 83 fa 10	 cmp	 rdx, 16

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00011	72 2c		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00016	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00019	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00020	72 18		 jb	 SHORT $LN22@basic_stri

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00022	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00026	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002a	49 2b c8	 sub	 rcx, r8

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002d	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00031	48 83 f8 1f	 cmp	 rax, 31
  00035	77 21		 ja	 SHORT $LN19@basic_stri

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00037	49 8b c8	 mov	 rcx, r8
$LN22@basic_stri:

; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

  0003f	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00047	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004f	c6 03 00	 mov	 BYTE PTR [rbx], 0

; 2730 :     }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0005e	cc		 int	 3
$LN27@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2200 : [[noreturn]] inline void _Xlen_string() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2201 :     _Xlength_error("string too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen_strin:
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 321  :     _THROW(bad_array_new_length{});

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
  0001f	cc		 int	 3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN12@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 67   :         _Data._What = _Message;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00007	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0
  0000f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 141  :     {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  0001a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 142  :     }

  0001d	48 8b c1	 mov	 rax, rcx
  00020	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN9@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN9@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN6@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN6@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	48 0f 45 c2	 cmovne	 rax, rdx

; 96   :     }

  00012	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy

; 74   :     }

  00029	48 8b c3	 mov	 rax, rbx
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 956  :     {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	53		 push	 rbx
  00015	57		 push	 rdi
  00016	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);
; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	48 8d 7c 24 58	 lea	 rdi, QWORD PTR _Format$[rsp+8]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002a	48 8b d8	 mov	 rbx, rax

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Format$[rsp]
  00037	45 33 c9	 xor	 r9d, r9d
  0003a	48 8b d3	 mov	 rdx, rbx
  0003d	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 961  :         __crt_va_end(_ArgList);
; 962  :         return _Result;
; 963  :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	5f		 pop	 rdi
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
