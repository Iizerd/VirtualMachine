; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?InstructionBindings@@3PAPEBDA			; InstructionBindings
PUBLIC	?RegisterBindings@@3PAPEBDA			; RegisterBindings
CONST	SEGMENT
$SG133003 DB	'VMENTER', 00H
$SG133004 DB	'VMEXIT', 00H
$SG134242 DB	00H
$SG133005 DB	'NOP', 00H
$SG133006 DB	'LDIB', 00H
	ORG $+3
$SG133007 DB	'LDIW', 00H
	ORG $+3
$SG133008 DB	'LDID', 00H
	ORG $+3
$SG133009 DB	'LDIQ', 00H
	ORG $+3
$SG133042 DB	'PUSHB', 00H
	ORG $+2
$SG133074 DB	'ORB', 00H
$SG133010 DB	'LDIBSXW', 00H
$SG133011 DB	'LDIBSXD', 00H
$SG133012 DB	'LDIBSXQ', 00H
$SG133013 DB	'LDIWSXD', 00H
$SG133014 DB	'LDIWSXQ', 00H
$SG133015 DB	'LDIDSXQ', 00H
$SG133016 DB	'LDIBZXW', 00H
$SG133017 DB	'LDIBZXD', 00H
$SG133018 DB	'LDIBZXQ', 00H
$SG133019 DB	'LDIWZXD', 00H
$SG133020 DB	'LDIWZXQ', 00H
$SG133021 DB	'LDIDZXQ', 00H
$SG133022 DB	'LDAB', 00H
	ORG $+3
$SG133023 DB	'LDAW', 00H
	ORG $+3
$SG133024 DB	'LDAD', 00H
	ORG $+3
$SG133025 DB	'LDAQ', 00H
	ORG $+3
$SG133026 DB	'STAB', 00H
	ORG $+3
$SG133027 DB	'STAW', 00H
	ORG $+3
$SG133028 DB	'STAD', 00H
	ORG $+3
$SG133029 DB	'STAQ', 00H
	ORG $+3
$SG133030 DB	'SXBW', 00H
	ORG $+3
$SG133031 DB	'SXBD', 00H
	ORG $+3
$SG133032 DB	'SXBQ', 00H
	ORG $+3
$SG133033 DB	'SXWD', 00H
	ORG $+3
$SG133034 DB	'SXWQ', 00H
	ORG $+3
$SG133035 DB	'SXDQ', 00H
	ORG $+3
$SG133036 DB	'ZXBW', 00H
	ORG $+3
$SG133037 DB	'ZXBD', 00H
	ORG $+3
$SG133038 DB	'ZXBQ', 00H
	ORG $+3
$SG133039 DB	'ZXWD', 00H
	ORG $+3
$SG133040 DB	'ZXWQ', 00H
	ORG $+3
$SG133041 DB	'ZXDQ', 00H
	ORG $+3
$SG133043 DB	'PUSHW', 00H
	ORG $+2
$SG133044 DB	'PUSHD', 00H
	ORG $+2
$SG133045 DB	'PUSHQ', 00H
	ORG $+2
$SG133046 DB	'POPB', 00H
	ORG $+3
$SG133047 DB	'POPW', 00H
	ORG $+3
$SG133048 DB	'POPD', 00H
	ORG $+3
$SG133049 DB	'POPQ', 00H
	ORG $+3
$SG133050 DB	'NPOPB', 00H
	ORG $+2
$SG133051 DB	'NPOPW', 00H
	ORG $+2
$SG133052 DB	'NPOPD', 00H
	ORG $+2
$SG133053 DB	'NPOPQ', 00H
	ORG $+2
$SG133054 DB	'ADDB', 00H
	ORG $+3
$SG133055 DB	'ADDW', 00H
	ORG $+3
$SG133056 DB	'ADDD', 00H
	ORG $+3
$SG133057 DB	'ADDQ', 00H
	ORG $+3
$SG133058 DB	'SUBB', 00H
	ORG $+3
$SG133059 DB	'SUBW', 00H
	ORG $+3
$SG133060 DB	'SUBD', 00H
	ORG $+3
$SG133061 DB	'SUBQ', 00H
	ORG $+3
$SG133062 DB	'MULB', 00H
	ORG $+3
$SG133063 DB	'MULW', 00H
	ORG $+3
$SG133064 DB	'MULD', 00H
	ORG $+3
$SG133065 DB	'MULQ', 00H
	ORG $+3
$SG133066 DB	'DIVB', 00H
	ORG $+3
$SG133067 DB	'DIVW', 00H
	ORG $+3
$SG133068 DB	'DIVD', 00H
	ORG $+3
$SG133069 DB	'DIVQ', 00H
	ORG $+3
$SG133070 DB	'ANDB', 00H
	ORG $+3
$SG133071 DB	'ANDW', 00H
	ORG $+3
$SG133072 DB	'ANDD', 00H
	ORG $+3
$SG133073 DB	'ANDQ', 00H
	ORG $+3
$SG133075 DB	'ORW', 00H
$SG133076 DB	'ORD', 00H
$SG133077 DB	'ORQ', 00H
$SG133078 DB	'XORB', 00H
	ORG $+3
$SG133079 DB	'XORW', 00H
	ORG $+3
$SG133080 DB	'XORD', 00H
	ORG $+3
$SG133081 DB	'XORQ', 00H
	ORG $+3
$SG133082 DB	'SHLB', 00H
	ORG $+3
$SG133083 DB	'SHLW', 00H
	ORG $+3
$SG133084 DB	'SHLD', 00H
	ORG $+3
$SG133085 DB	'SHLQ', 00H
	ORG $+3
$SG133086 DB	'SHRB', 00H
	ORG $+3
$SG133087 DB	'SHRW', 00H
	ORG $+3
$SG133088 DB	'SHRD', 00H
	ORG $+3
$SG133089 DB	'SHRQ', 00H
	ORG $+3
$SG133090 DB	'CMPB', 00H
	ORG $+3
$SG133091 DB	'CMPW', 00H
	ORG $+3
$SG133092 DB	'CMPD', 00H
	ORG $+3
$SG133093 DB	'CMPQ', 00H
	ORG $+3
$SG133094 DB	'JMP', 00H
$SG133095 DB	'JMPI', 00H
	ORG $+3
$SG133096 DB	'JL', 00H
	ORG $+1
$SG133097 DB	'JLE', 00H
$SG133098 DB	'JG', 00H
	ORG $+1
$SG133099 DB	'JGE', 00H
$SG133100 DB	'JZ', 00H
	ORG $+1
$SG133101 DB	'JNZ', 00H
$SG133102 DB	'CALL', 00H
	ORG $+3
$SG133103 DB	'RET', 00H
$SG133142 DB	'BP', 00H
	ORG $+1
$SG133104 DB	'X86CALL', 00H
$SG133105 DB	'EDITSP', 00H
	ORG $+1
$SG133106 DB	'STSP', 00H
	ORG $+3
$SG133107 DB	'LDSP', 00H
	ORG $+3
$SG133108 DB	'STIP', 00H
	ORG $+3
$SG133109 DB	'LDIP', 00H
	ORG $+3
$SG133110 DB	'SWAPB', 00H
	ORG $+2
$SG133111 DB	'SWAPW', 00H
	ORG $+2
$SG133112 DB	'SWAPD', 00H
	ORG $+2
$SG133113 DB	'SWAPQ', 00H
	ORG $+2
$SG133114 DB	'DECB', 00H
	ORG $+3
$SG133115 DB	'DECW', 00H
	ORG $+3
$SG133116 DB	'DECD', 00H
	ORG $+3
$SG133117 DB	'DECQ', 00H
	ORG $+3
$SG133118 DB	'INCB', 00H
	ORG $+3
$SG133119 DB	'INCW', 00H
	ORG $+3
$SG133120 DB	'INCD', 00H
	ORG $+3
$SG133121 DB	'INCQ', 00H
	ORG $+3
$SG133122 DB	'SWAPBQ', 00H
	ORG $+1
$SG133123 DB	'SWAPWQ', 00H
	ORG $+1
$SG133124 DB	'SWAPDQ', 00H
	ORG $+1
$SG133125 DB	'LDSB', 00H
	ORG $+3
$SG133126 DB	'LDSW', 00H
	ORG $+3
$SG133127 DB	'LDSD', 00H
	ORG $+3
$SG133128 DB	'LDSQ', 00H
	ORG $+3
$SG133129 DB	'STSB', 00H
	ORG $+3
$SG133130 DB	'STSW', 00H
	ORG $+3
$SG133131 DB	'STSD', 00H
	ORG $+3
$SG133132 DB	'STSQ', 00H
	ORG $+3
$SG133133 DB	'LDBPB', 00H
	ORG $+2
$SG133134 DB	'LDBPW', 00H
	ORG $+2
$SG133135 DB	'LDBPD', 00H
	ORG $+2
$SG133136 DB	'LDBPQ', 00H
	ORG $+2
$SG133137 DB	'STBPB', 00H
	ORG $+2
$SG133138 DB	'STBPW', 00H
	ORG $+2
$SG133139 DB	'STBPD', 00H
	ORG $+2
$SG133140 DB	'STBPQ', 00H
	ORG $+2
$SG133143 DB	'R1', 00H
	ORG $+1
$SG133144 DB	'R2', 00H
	ORG $+1
$SG133145 DB	'R3', 00H
	ORG $+1
$SG133146 DB	'R4', 00H
	ORG $+1
$SG133147 DB	'R5', 00H
	ORG $+1
$SG133148 DB	'R6', 00H
	ORG $+1
$SG133149 DB	'R7', 00H
	ORG $+1
$SG133150 DB	'R8', 00H
	ORG $+1
$SG133151 DB	'R9', 00H
	ORG $+1
$SG133152 DB	'R10', 00H
$SG133153 DB	'R11', 00H
$SG133154 DB	'R12', 00H
$SG133155 DB	'R13', 00H
$SG133156 DB	'R14', 00H
$SG133157 DB	'R15', 00H
$SG133158 DB	'R16', 00H
$SG133159 DB	'R17', 00H
$SG133160 DB	'R18', 00H
$SG133161 DB	'R19', 00H
$SG133162 DB	'R20', 00H
$SG133163 DB	'R21', 00H
$SG133164 DB	'R22', 00H
$SG133165 DB	'R23', 00H
$SG133166 DB	'R24', 00H
$SG133167 DB	'R25', 00H
$SG133168 DB	'R26', 00H
$SG133169 DB	'R27', 00H
$SG133170 DB	'R28', 00H
$SG133171 DB	'R29', 00H
$SG133172 DB	'R30', 00H
$SG133173 DB	'R31', 00H
$SG134123 DB	'"', 0aH, 00H
	ORG $+1
$SG133928 DB	'Bad File.', 0aH, 00H
	ORG $+1
$SG134243 DB	'   ', 00H
$SG133954 DB	'Failed to get opcode for line %s.', 0aH, 00H
	ORG $+5
$SG134124 DB	'bad register "', 00H
	ORG $+1
$SG139027 DB	'Got here. %i', 0aH, 00H
	ORG $+2
$SG139129 DB	'C:\Users\Iizerd\source\repos\StackMachine\Code\Example.t'
	DB	'xt', 00H
	ORG $+1
$SG139130 DB	'pause', 00H
	ORG $+2
$SG139131 DB	'pause', 00H
	ORG $+6
$SG139133 DB	' microseconds.', 0aH, 00H
$SG139134 DB	'My Machine took ', 00H
	ORG $+7
$SG139132 DB	'Hello this is a test string. It is really long because I'
	DB	' want to really get a good idea for how long this is actually'
	DB	' going to take for both methods. Did you know that while my u'
	DB	'sername looks like lizerd, it is actually Iizerd with a capit'
	DB	'ol i at the start instead of an L. I think this is cool and u'
	DB	'nique and separates me from other people :D. Now im making th'
	DB	'is string even longer and talking more about lizards. Did you'
	DB	' know there are some lizards that can shoot blood from their '
	DB	'eyes? when I found this out I thought it was super cool. A si'
	DB	'ck defense mechanism that allows them to scare off predators.'
	DB	00H
	ORG $+2
$SG139135 DB	' microseconds.', 0aH, 00H
$SG139136 DB	'The C One took  ', 00H
CONST	ENDS
_DATA	SEGMENT
?InstructionBindings@@3PAPEBDA DQ FLAT:$SG133003	; InstructionBindings
	DQ	FLAT:$SG133004
	DQ	FLAT:$SG133005
	DQ	FLAT:$SG133006
	DQ	FLAT:$SG133007
	DQ	FLAT:$SG133008
	DQ	FLAT:$SG133009
	DQ	FLAT:$SG133010
	DQ	FLAT:$SG133011
	DQ	FLAT:$SG133012
	DQ	FLAT:$SG133013
	DQ	FLAT:$SG133014
	DQ	FLAT:$SG133015
	DQ	FLAT:$SG133016
	DQ	FLAT:$SG133017
	DQ	FLAT:$SG133018
	DQ	FLAT:$SG133019
	DQ	FLAT:$SG133020
	DQ	FLAT:$SG133021
	DQ	FLAT:$SG133022
	DQ	FLAT:$SG133023
	DQ	FLAT:$SG133024
	DQ	FLAT:$SG133025
	DQ	FLAT:$SG133026
	DQ	FLAT:$SG133027
	DQ	FLAT:$SG133028
	DQ	FLAT:$SG133029
	DQ	FLAT:$SG133030
	DQ	FLAT:$SG133031
	DQ	FLAT:$SG133032
	DQ	FLAT:$SG133033
	DQ	FLAT:$SG133034
	DQ	FLAT:$SG133035
	DQ	FLAT:$SG133036
	DQ	FLAT:$SG133037
	DQ	FLAT:$SG133038
	DQ	FLAT:$SG133039
	DQ	FLAT:$SG133040
	DQ	FLAT:$SG133041
	DQ	FLAT:$SG133042
	DQ	FLAT:$SG133043
	DQ	FLAT:$SG133044
	DQ	FLAT:$SG133045
	DQ	FLAT:$SG133046
	DQ	FLAT:$SG133047
	DQ	FLAT:$SG133048
	DQ	FLAT:$SG133049
	DQ	FLAT:$SG133050
	DQ	FLAT:$SG133051
	DQ	FLAT:$SG133052
	DQ	FLAT:$SG133053
	DQ	FLAT:$SG133054
	DQ	FLAT:$SG133055
	DQ	FLAT:$SG133056
	DQ	FLAT:$SG133057
	DQ	FLAT:$SG133058
	DQ	FLAT:$SG133059
	DQ	FLAT:$SG133060
	DQ	FLAT:$SG133061
	DQ	FLAT:$SG133062
	DQ	FLAT:$SG133063
	DQ	FLAT:$SG133064
	DQ	FLAT:$SG133065
	DQ	FLAT:$SG133066
	DQ	FLAT:$SG133067
	DQ	FLAT:$SG133068
	DQ	FLAT:$SG133069
	DQ	FLAT:$SG133070
	DQ	FLAT:$SG133071
	DQ	FLAT:$SG133072
	DQ	FLAT:$SG133073
	DQ	FLAT:$SG133074
	DQ	FLAT:$SG133075
	DQ	FLAT:$SG133076
	DQ	FLAT:$SG133077
	DQ	FLAT:$SG133078
	DQ	FLAT:$SG133079
	DQ	FLAT:$SG133080
	DQ	FLAT:$SG133081
	DQ	FLAT:$SG133082
	DQ	FLAT:$SG133083
	DQ	FLAT:$SG133084
	DQ	FLAT:$SG133085
	DQ	FLAT:$SG133086
	DQ	FLAT:$SG133087
	DQ	FLAT:$SG133088
	DQ	FLAT:$SG133089
	DQ	FLAT:$SG133090
	DQ	FLAT:$SG133091
	DQ	FLAT:$SG133092
	DQ	FLAT:$SG133093
	DQ	FLAT:$SG133094
	DQ	FLAT:$SG133095
	DQ	FLAT:$SG133096
	DQ	FLAT:$SG133097
	DQ	FLAT:$SG133098
	DQ	FLAT:$SG133099
	DQ	FLAT:$SG133100
	DQ	FLAT:$SG133101
	DQ	FLAT:$SG133102
	DQ	FLAT:$SG133103
	DQ	FLAT:$SG133104
	DQ	FLAT:$SG133105
	DQ	FLAT:$SG133106
	DQ	FLAT:$SG133107
	DQ	FLAT:$SG133108
	DQ	FLAT:$SG133109
	DQ	FLAT:$SG133110
	DQ	FLAT:$SG133111
	DQ	FLAT:$SG133112
	DQ	FLAT:$SG133113
	DQ	FLAT:$SG133114
	DQ	FLAT:$SG133115
	DQ	FLAT:$SG133116
	DQ	FLAT:$SG133117
	DQ	FLAT:$SG133118
	DQ	FLAT:$SG133119
	DQ	FLAT:$SG133120
	DQ	FLAT:$SG133121
	DQ	FLAT:$SG133122
	DQ	FLAT:$SG133123
	DQ	FLAT:$SG133124
	DQ	FLAT:$SG133125
	DQ	FLAT:$SG133126
	DQ	FLAT:$SG133127
	DQ	FLAT:$SG133128
	DQ	FLAT:$SG133129
	DQ	FLAT:$SG133130
	DQ	FLAT:$SG133131
	DQ	FLAT:$SG133132
	DQ	FLAT:$SG133133
	DQ	FLAT:$SG133134
	DQ	FLAT:$SG133135
	DQ	FLAT:$SG133136
	DQ	FLAT:$SG133137
	DQ	FLAT:$SG133138
	DQ	FLAT:$SG133139
	DQ	FLAT:$SG133140
?RegisterBindings@@3PAPEBDA DQ FLAT:$SG133142		; RegisterBindings
	DQ	FLAT:$SG133143
	DQ	FLAT:$SG133144
	DQ	FLAT:$SG133145
	DQ	FLAT:$SG133146
	DQ	FLAT:$SG133147
	DQ	FLAT:$SG133148
	DQ	FLAT:$SG133149
	DQ	FLAT:$SG133150
	DQ	FLAT:$SG133151
	DQ	FLAT:$SG133152
	DQ	FLAT:$SG133153
	DQ	FLAT:$SG133154
	DQ	FLAT:$SG133155
	DQ	FLAT:$SG133156
	DQ	FLAT:$SG133157
	DQ	FLAT:$SG133158
	DQ	FLAT:$SG133159
	DQ	FLAT:$SG133160
	DQ	FLAT:$SG133161
	DQ	FLAT:$SG133162
	DQ	FLAT:$SG133163
	DQ	FLAT:$SG133164
	DQ	FLAT:$SG133165
	DQ	FLAT:$SG133166
	DQ	FLAT:$SG133167
	DQ	FLAT:$SG133168
	DQ	FLAT:$SG133169
	DQ	FLAT:$SG133170
	DQ	FLAT:$SG133171
	DQ	FLAT:$SG133172
	DQ	FLAT:$SG133173
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	wmemcpy
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64>
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z	; std::_Narrow_char_traits<char,int>::eq
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ; std::_Narrow_char_traits<char,int>::not_eof
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back
PUBLIC	?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QEAA@XZ			; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z	; std::locale::_Getfacet
PUBLIC	??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?_Maklocwcs@std@@YAPEA_WPEB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
PUBLIC	?hex@std@@YAAEAVios_base@1@AEAV21@@Z		; std::hex
PUBLIC	?InitHandlerTable@@YAXPEAU_VM_HANDLER_TABLE@@@Z	; InitHandlerTable
PUBLIC	?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
PUBLIC	?stoll@std@@YA_JAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoll
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
PUBLIC	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ; std::to_string
PUBLIC	??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z ; std::_Integral_to_string<char,__int64>
PUBLIC	??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z	; std::_Ungetc<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; SplitString
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Move_construct@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_construct
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Move_assign@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_assign
PUBLIC	??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator=
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
PUBLIC	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Take_contents
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2
PUBLIC	??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; _SYMBOL::_SYMBOL
PUBLIC	??1_SYMBOL@@QEAA@XZ				; _SYMBOL::~_SYMBOL
PUBLIC	??0_SYMBOL@@QEAA@$$QEAU0@@Z			; _SYMBOL::_SYMBOL
PUBLIC	??_G_SYMBOL@@QEAAPEAXI@Z			; _SYMBOL::`scalar deleting destructor'
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Verify_offset
PUBLIC	??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator+=
PUBLIC	?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Seek_to
PUBLIC	??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator+=
PUBLIC	??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator+
PUBLIC	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
PUBLIC	?__autoclassinit2@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAX_K@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::__autoclassinit2
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
PUBLIC	?SmAllocCodeBlock@@YAXPEAU_SMCB@@K@Z		; SmAllocCodeBlock
PUBLIC	?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z		; SmPushBackBlock
PUBLIC	??0?$allocator@U_SYMBOL@@@std@@QEAA@XZ		; std::allocator<_SYMBOL>::allocator<_SYMBOL>
PUBLIC	?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL>::deallocate
PUBLIC	?allocate@?$allocator@U_SYMBOL@@@std@@QEAAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@U_SYMBOL@@@2@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::max_size
PUBLIC	??0?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::vector<_SYMBOL,std::allocator<_SYMBOL> >
PUBLIC	??1?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::~vector<_SYMBOL,std::allocator<_SYMBOL> >
PUBLIC	?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::clear
PUBLIC	?size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::size
PUBLIC	?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::max_size
PUBLIC	?capacity@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::capacity
PUBLIC	??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
PUBLIC	?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBA_K_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXQEAU_SYMBOL@@_K1@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Change_array
PUBLIC	?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Tidy
PUBLIC	?_Xlength@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@CAXXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAXPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Orphan_range
PUBLIC	?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
PUBLIC	?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<_SYMBOL> >::_Vector_val<std::_Simple_types<_SYMBOL> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_SYMBOL@@@2@XZ ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::__autoclassinit2
PUBLIC	??0?$allocator@PEAU_SYMBOL@@@std@@QEAA@XZ	; std::allocator<_SYMBOL *>::allocator<_SYMBOL *>
PUBLIC	?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL *>::deallocate
PUBLIC	?allocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAPEAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL *>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@PEAU_SYMBOL@@@2@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::max_size
PUBLIC	??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::vector<_SYMBOL *,std::allocator<_SYMBOL *> >
PUBLIC	??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::~vector<_SYMBOL *,std::allocator<_SYMBOL *> >
PUBLIC	?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::push_back
PUBLIC	?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::clear
PUBLIC	?_Unchecked_begin@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_end
PUBLIC	?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::max_size
PUBLIC	?capacity@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::capacity
PUBLIC	?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBA_K_K@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXQEAPEAU_SYMBOL@@_K1@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@CAXXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAXPEAPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
PUBLIC	?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<_SYMBOL *> >::_Vector_val<std::_Simple_types<_SYMBOL *> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::__autoclassinit2
PUBLIC	?SmGetInstructionSize@@YAHE@Z			; SmGetInstructionSize
PUBLIC	?SmGetOpCode@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ; SmGetOpCode
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?SmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ; SmGetRegisterId
PUBLIC	?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; SmPrintByteAsHex
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z ; std::operator<<<char,std::char_traits<char>,__int64>
PUBLIC	??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z	; std::setfill<char>
PUBLIC	??0?$_Fillobj@D@std@@QEAA@D@Z			; std::_Fillobj<char>::_Fillobj<char>
PUBLIC	??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z ; std::operator<<<char,std::char_traits<char>,char>
PUBLIC	?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SmLoadFromFile
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::emplace_back<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$forward@H@std@@YA$$QEAHAEAH@Z		; std::forward<int>
PUBLIC	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Emplace_back_with_unused_capacity@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_back_with_unused_capacity<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Unfancy@U_SYMBOL@@@std@@YAPEAU_SYMBOL@@PEAU1@@Z ; std::_Unfancy<_SYMBOL>
PUBLIC	??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_reallocate<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	?SmParseLoadedFile@@YAXXZ			; SmParseLoadedFile
PUBLIC	?SmAssembleToBlock@@YAXPEAU_SMCB@@@Z		; SmAssembleToBlock
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?SmAssembleToFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SmAssembleToFile
PUBLIC	?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z ; SmDecodeInstruction
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
PUBLIC	?CXorStr@@YAXPEAXDK@Z				; CXorStr
PUBLIC	?TestFunc@@YA_J_J00000@Z			; TestFunc
PUBLIC	main
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z		; std::max<char *>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$move@AEAPEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ; std::move<_SYMBOL * &>
PUBLIC	??$emplace_back@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::emplace_back<_SYMBOL *>
PUBLIC	??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ; std::forward<_SYMBOL *>
PUBLIC	??$_Emplace_back_with_unused_capacity@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_back_with_unused_capacity<_SYMBOL *>
PUBLIC	??$_Unfancy@PEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@@Z ; std::_Unfancy<_SYMBOL *>
PUBLIC	??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::construct<_SYMBOL *,_SYMBOL *>
PUBLIC	??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_reallocate<_SYMBOL *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1><>
PUBLIC	??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$addressof@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AEAV10@@Z ; std::addressof<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Unfancy@$$CBD@std@@YAPEBDPEBD@Z		; std::_Unfancy<char const >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
PUBLIC	??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
PUBLIC	??$_Destroy_range@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAXPEAPEAU_SYMBOL@@QEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z ; std::_Destroy_range<std::allocator<_SYMBOL *> >
PUBLIC	??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z ; std::_Destroy_range<std::allocator<_SYMBOL> >
PUBLIC	??$_Pocma@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@0@Z ; std::_Pocma<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
PUBLIC	??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
PUBLIC	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z		; std::end<char,21>
PUBLIC	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z	; std::_UIntegral_to_buff<char,unsigned int>
PUBLIC	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
PUBLIC	??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z	; std::_UIntegral_to_buff<char,unsigned __int64>
PUBLIC	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>
PUBLIC	??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA_JAEBQEAD0@Z ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char *>
PUBLIC	??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YAPEADAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &,__int64>
PUBLIC	??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char * &>
PUBLIC	??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$destroy@U_SYMBOL@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::destroy<_SYMBOL>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$exchange@PEAV_Facet_base@std@@PEAV12@@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEAPEAV10@@Z ; std::exchange<std::_Facet_base *,std::_Facet_base *>
PUBLIC	??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z ; std::_Uninitialized_move<_SYMBOL * *,std::allocator<_SYMBOL *> >
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z ; std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >
PUBLIC	??$_Get_size_of_n@$0EI@@std@@YA_K_K@Z		; std::_Get_size_of_n<72>
PUBLIC	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z		; std::_Get_size_of_n<32>
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Get_unwrapped@AEBQEAPEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@AEBQEAPEAU1@@Z ; std::_Get_unwrapped<_SYMBOL * * const &>
PUBLIC	??$_Copy_memmove@PEAPEAU_SYMBOL@@PEAPEAU1@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@00@Z ; std::_Copy_memmove<_SYMBOL * *,_SYMBOL * *>
PUBLIC	??$_Get_unwrapped@AEBQEAU_SYMBOL@@@std@@YAPEAU_SYMBOL@@AEBQEAU1@@Z ; std::_Get_unwrapped<_SYMBOL * const &>
PUBLIC	??$move@AEAU_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z ; std::move<_SYMBOL &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@PEAU_SYMBOL@@AEAV?$allocator@U_SYMBOL@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Uninitialized_backout_al<std::allocator<_SYMBOL> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::~_Uninitialized_backout_al<std::allocator<_SYMBOL> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@XZ ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::__autoclassinit2
PUBLIC	??$_Emplace_back@U_SYMBOL@@@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX$$QEAU_SYMBOL@@@Z ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Emplace_back<_SYMBOL>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBQEAV10@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2
PUBLIC	??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z		; std::_Refancy<char const *,0>
PUBLIC	??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$forward@U_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z ; std::forward<_SYMBOL>
PUBLIC	??$construct@U_SYMBOL@@U1@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAU3@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,_SYMBOL>
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@	; `string'
PUBLIC	??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0BH@KOGMOJCH@invalid?5stoll?5argument@	; `string'
PUBLIC	??_C@_0BM@BPCBEBLO@stoll?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
PUBLIC	?Labels@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Labels
PUBLIC	?Instructions@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Instructions
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp_strtoll:PROC
EXTRN	__imp_system:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp__get_stream_buffer_pointers:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_fgetpos:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_fsetpos:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp__lock_file:PROC
EXTRN	__imp__unlock_file:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xinvalid_argument@std@@YAXPEBD@Z:PROC		; std::_Xinvalid_argument
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	_Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_??Bid@locale@std@@QEAA_KXZ:PROC
EXTRN	?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	__imp_?always_noconv@codecvt_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_??Bios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?bad@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?setf@ios_base@std@@QEAAHHH@Z:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAPEAD0PEAH001@Z:PROC
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@K@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_J@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	VmEnter:PROC
EXTRN	ViVmExit:PROC
EXTRN	ViNop:PROC
EXTRN	ViLdib:PROC
EXTRN	ViLdiw:PROC
EXTRN	ViLdid:PROC
EXTRN	ViLdiq:PROC
EXTRN	ViLdibsxw:PROC
EXTRN	ViLdibsxd:PROC
EXTRN	ViLdibsxq:PROC
EXTRN	ViLdiwsxd:PROC
EXTRN	ViLdiwsxq:PROC
EXTRN	ViLdidsxq:PROC
EXTRN	ViLdibzxw:PROC
EXTRN	ViLdibzxd:PROC
EXTRN	ViLdibzxq:PROC
EXTRN	ViLdiwzxd:PROC
EXTRN	ViLdiwzxq:PROC
EXTRN	ViLdidzxq:PROC
EXTRN	ViLdab:PROC
EXTRN	ViLdaw:PROC
EXTRN	ViLdad:PROC
EXTRN	ViLdaq:PROC
EXTRN	ViStab:PROC
EXTRN	ViStaw:PROC
EXTRN	ViStad:PROC
EXTRN	ViStaq:PROC
EXTRN	ViSxbw:PROC
EXTRN	ViSxbd:PROC
EXTRN	ViSxbq:PROC
EXTRN	ViSxwd:PROC
EXTRN	ViSxwq:PROC
EXTRN	ViSxdq:PROC
EXTRN	ViZxbw:PROC
EXTRN	ViZxbd:PROC
EXTRN	ViZxbq:PROC
EXTRN	ViZxwd:PROC
EXTRN	ViZxwq:PROC
EXTRN	ViZxdq:PROC
EXTRN	ViPushb:PROC
EXTRN	ViPushw:PROC
EXTRN	ViPushd:PROC
EXTRN	ViPushq:PROC
EXTRN	ViPopb:PROC
EXTRN	ViPopw:PROC
EXTRN	ViPopd:PROC
EXTRN	ViPopq:PROC
EXTRN	ViNpopb:PROC
EXTRN	ViNpopw:PROC
EXTRN	ViNpopd:PROC
EXTRN	ViNpopq:PROC
EXTRN	ViAddb:PROC
EXTRN	ViAddw:PROC
EXTRN	ViAddd:PROC
EXTRN	ViAddq:PROC
EXTRN	ViSubb:PROC
EXTRN	ViSubw:PROC
EXTRN	ViSubd:PROC
EXTRN	ViSubq:PROC
EXTRN	ViMulb:PROC
EXTRN	ViMulw:PROC
EXTRN	ViMuld:PROC
EXTRN	ViMulq:PROC
EXTRN	ViDivb:PROC
EXTRN	ViDivw:PROC
EXTRN	ViDivd:PROC
EXTRN	ViDivq:PROC
EXTRN	ViAndb:PROC
EXTRN	ViAndw:PROC
EXTRN	ViAndd:PROC
EXTRN	ViAndq:PROC
EXTRN	ViOrb:PROC
EXTRN	ViOrw:PROC
EXTRN	ViOrd:PROC
EXTRN	ViOrq:PROC
EXTRN	ViXorb:PROC
EXTRN	ViXorw:PROC
EXTRN	ViXord:PROC
EXTRN	ViXorq:PROC
EXTRN	ViShlb:PROC
EXTRN	ViShlw:PROC
EXTRN	ViShld:PROC
EXTRN	ViShlq:PROC
EXTRN	ViShrb:PROC
EXTRN	ViShrw:PROC
EXTRN	ViShrd:PROC
EXTRN	ViShrq:PROC
EXTRN	ViCmpb:PROC
EXTRN	ViCmpw:PROC
EXTRN	ViCmpd:PROC
EXTRN	ViCmpq:PROC
EXTRN	ViJmp:PROC
EXTRN	ViJmpi:PROC
EXTRN	ViJl:PROC
EXTRN	ViJle:PROC
EXTRN	ViJg:PROC
EXTRN	ViJge:PROC
EXTRN	ViJz:PROC
EXTRN	ViJnz:PROC
EXTRN	ViCall:PROC
EXTRN	ViRet:PROC
EXTRN	ViX86Call:PROC
EXTRN	ViEditsp:PROC
EXTRN	ViStsp:PROC
EXTRN	ViLdsp:PROC
EXTRN	ViStip:PROC
EXTRN	ViLdip:PROC
EXTRN	ViSwapb:PROC
EXTRN	ViSwapw:PROC
EXTRN	ViSwapd:PROC
EXTRN	ViSwapq:PROC
EXTRN	ViDecb:PROC
EXTRN	ViDecw:PROC
EXTRN	ViDecd:PROC
EXTRN	ViDecq:PROC
EXTRN	ViIncb:PROC
EXTRN	ViIncw:PROC
EXTRN	ViIncd:PROC
EXTRN	ViIncq:PROC
EXTRN	ViSwapbq:PROC
EXTRN	ViSwapwq:PROC
EXTRN	ViSwapdq:PROC
EXTRN	ViLdsb:PROC
EXTRN	ViLdsw:PROC
EXTRN	ViLdsd:PROC
EXTRN	ViLdsq:PROC
EXTRN	ViStsb:PROC
EXTRN	ViStsw:PROC
EXTRN	ViStsd:PROC
EXTRN	ViStsq:PROC
EXTRN	ViLdbpb:PROC
EXTRN	ViLdbpw:PROC
EXTRN	ViLdbpd:PROC
EXTRN	ViLdbpq:PROC
EXTRN	ViStbpb:PROC
EXTRN	ViStbpw:PROC
EXTRN	ViStbpd:PROC
EXTRN	ViStbpq:PROC
EXTRN	?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z:PROC	; std::_Fiopen
EXTRN	?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z:PROC	; std::setw
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	_Query_perf_counter:PROC
EXTRN	_Query_perf_frequency:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	memmove:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:QWORD
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A DB 018H DUP (?) ; Symbols
?Labels@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A DB 018H DUP (?) ; Labels
?Instructions@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A DB 018H DUP (?) ; Instructions
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wmemcpy DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$wmemcpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z DD imagerel $LN7
	DD	imagerel $LN7+80
	DD	imagerel $unwind$?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+179
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+175
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+147
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+361
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+250
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+178
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+228
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+131
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z DD imagerel $LN4
	DD	imagerel $LN4+193
	DD	imagerel $unwind$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+138
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+123
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+98
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+174
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+183
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_cast@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1bad_cast@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_cast@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?_Throw_bad_cast@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+109
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN8
	DD	imagerel $LN8+167
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z DD imagerel $LN13
	DD	imagerel $LN13+534
	DD	imagerel $unwind$??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Maklocwcs@std@@YAPEA_WPEB_W@Z DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$?_Maklocwcs@std@@YAPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z DD imagerel $LN8
	DD	imagerel $LN8+192
	DD	imagerel $unwind$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hex@std@@YAAEAVios_base@1@AEAV21@@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?hex@std@@YAAEAVios_base@1@AEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z DD imagerel $LN7
	DD	imagerel $LN7+216
	DD	imagerel $unwind$?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stoll@std@@YA_JAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z DD imagerel $LN6
	DD	imagerel $LN6+198
	DD	imagerel $unwind$?stoll@std@@YA_JAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD imagerel $LN7
	DD	imagerel $LN7+208
	DD	imagerel $unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z DD imagerel $LN7
	DD	imagerel $LN7+215
	DD	imagerel $unwind$??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD imagerel $LN5
	DD	imagerel $LN5+68
	DD	imagerel $unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+336
	DD	imagerel $unwind$??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+336
	DD	imagerel $unwind$??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD imagerel $LN13
	DD	imagerel $LN13+372
	DD	imagerel $unwind$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA DD imagerel ?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
	DD	imagerel ?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA DD imagerel ?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
	DD	imagerel ?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Move_construct@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?_Move_construct@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Move_assign@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$?_Move_assign@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+269
	DD	imagerel $unwind$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+225
	DD	imagerel $unwind$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN7
	DD	imagerel $LN7+446
	DD	imagerel $unwind$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_SYMBOL@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??1_SYMBOL@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_SYMBOL@@QEAA@$$QEAU0@@Z DD imagerel $LN3
	DD	imagerel $LN3+159
	DD	imagerel $unwind$??0_SYMBOL@@QEAA@$$QEAU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_SYMBOL@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G_SYMBOL@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z DD imagerel $LN6
	DD	imagerel $LN6+244
	DD	imagerel $unwind$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmAllocCodeBlock@@YAXPEAU_SMCB@@K@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?SmAllocCodeBlock@@YAXPEAU_SMCB@@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_SYMBOL@@@std@@QEAAPEAU_SYMBOL@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U_SYMBOL@@@std@@QEAAPEAU_SYMBOL@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??0?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?capacity@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept1@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Umove_if_noexcept1@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?_Umove_if_noexcept@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXQEAU_SYMBOL@@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+275
	DD	imagerel $unwind$?_Change_array@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXQEAU_SYMBOL@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+231
	DD	imagerel $unwind$?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xlength@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@U_SYMBOL@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@U_SYMBOL@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ESymbols@@YAXXZ DD imagerel ??__ESymbols@@YAXXZ
	DD	imagerel ??__ESymbols@@YAXXZ+50
	DD	imagerel $unwind$??__ESymbols@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FSymbols@@YAXXZ DD imagerel ??__FSymbols@@YAXXZ
	DD	imagerel ??__FSymbols@@YAXXZ+21
	DD	imagerel $unwind$??__FSymbols@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAPEAPEAU_SYMBOL@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAPEAPEAU_SYMBOL@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?capacity@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept1@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?_Umove_if_noexcept1@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?_Umove_if_noexcept@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXQEAPEAU_SYMBOL@@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+263
	DD	imagerel $unwind$?_Change_array@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXQEAPEAU_SYMBOL@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+225
	DD	imagerel $unwind$?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xlength@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ELabels@@YAXXZ DD imagerel ??__ELabels@@YAXXZ
	DD	imagerel ??__ELabels@@YAXXZ+50
	DD	imagerel $unwind$??__ELabels@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FLabels@@YAXXZ DD imagerel ??__FLabels@@YAXXZ
	DD	imagerel ??__FLabels@@YAXXZ+21
	DD	imagerel $unwind$??__FLabels@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EInstructions@@YAXXZ DD imagerel ??__EInstructions@@YAXXZ
	DD	imagerel ??__EInstructions@@YAXXZ+50
	DD	imagerel $unwind$??__EInstructions@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FInstructions@@YAXXZ DD imagerel ??__FInstructions@@YAXXZ
	DD	imagerel ??__FInstructions@@YAXXZ+21
	DD	imagerel $unwind$??__FInstructions@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmGetInstructionSize@@YAHE@Z DD imagerel $LN12
	DD	imagerel $LN12+265
	DD	imagerel $unwind$?SmGetInstructionSize@@YAHE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmGetOpCode@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z DD imagerel $LN7
	DD	imagerel $LN7+108
	DD	imagerel $unwind$?SmGetOpCode@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z DD imagerel $LN7
	DD	imagerel $LN7+102
	DD	imagerel $unwind$?SmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z DD imagerel $LN6
	DD	imagerel $LN6+271
	DD	imagerel $unwind$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA DD imagerel ?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA
	DD	imagerel ?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+233
	DD	imagerel $unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+137
	DD	imagerel $unwind$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+72
	DD	imagerel $unwind$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN9
	DD	imagerel $LN9+352
	DD	imagerel $unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA DD imagerel ?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
	DD	imagerel ?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN16
	DD	imagerel $LN16+782
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN6
	DD	imagerel $LN6+256
	DD	imagerel $unwind$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ DD imagerel $LN8
	DD	imagerel $LN8+298
	DD	imagerel $unwind$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN23
	DD	imagerel $LN23+679
	DD	imagerel $unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN10
	DD	imagerel $LN10+408
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+235
	DD	imagerel $unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN25
	DD	imagerel $LN25+1068
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+83
	DD	imagerel $unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN24
	DD	imagerel $LN24+789
	DD	imagerel $unwind$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD imagerel $LN9
	DD	imagerel $LN9+316
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD imagerel $LN4
	DD	imagerel $LN4+142
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+89
	DD	imagerel $unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+175
	DD	imagerel $unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA DD imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
	DD	imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN7
	DD	imagerel $LN7+130
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN18
	DD	imagerel $LN18+748
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN13
	DD	imagerel $LN13+394
	DD	imagerel $unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN7
	DD	imagerel $LN7+211
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN21
	DD	imagerel $LN21+909
	DD	imagerel $unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA DD imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN11
	DD	imagerel $LN11+578
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD imagerel $LN7
	DD	imagerel $LN7+300
	DD	imagerel $unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN8
	DD	imagerel $LN8+283
	DD	imagerel $unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN5
	DD	imagerel $LN5+221
	DD	imagerel $unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN7
	DD	imagerel $LN7+157
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN5
	DD	imagerel $LN5+134
	DD	imagerel $unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD imagerel $LN6
	DD	imagerel $LN6+327
	DD	imagerel $unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN15
	DD	imagerel $LN15+438
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+129
	DD	imagerel $unwind$?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+203
	DD	imagerel $unwind$??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+203
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN13
	DD	imagerel $LN13+592
	DD	imagerel $unwind$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+74
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmParseLoadedFile@@YAXXZ DD imagerel $LN10
	DD	imagerel $LN10+522
	DD	imagerel $unwind$?SmParseLoadedFile@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmAssembleToBlock@@YAXPEAU_SMCB@@@Z DD imagerel $LN24
	DD	imagerel $LN24+1283
	DD	imagerel $unwind$?SmAssembleToBlock@@YAXPEAU_SMCB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z DD imagerel $LN31
	DD	imagerel $LN31+1135
	DD	imagerel $unwind$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD imagerel ?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DD	imagerel ?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD imagerel ?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DD	imagerel ?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD imagerel ?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DD	imagerel ?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD imagerel ?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DD	imagerel ?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD imagerel ?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DD	imagerel ?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD imagerel ?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DD	imagerel ?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA+27
	DD	imagerel $unwind$?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD imagerel ?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DD	imagerel ?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA+27
	DD	imagerel $unwind$?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD imagerel $LN3
	DD	imagerel $LN3+146
	DD	imagerel $unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CXorStr@@YAXPEAXDK@Z DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$?CXorStr@@YAXPEAXDK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TestFunc@@YA_J_J00000@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?TestFunc@@YA_J_J00000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN11
	DD	imagerel $LN11+1200
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$0 DD imagerel main$dtor$0
	DD	imagerel main$dtor$0+27
	DD	imagerel $unwind$main$dtor$0
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$1 DD imagerel main$dtor$1
	DD	imagerel main$dtor$1+27
	DD	imagerel $unwind$main$dtor$1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$2 DD imagerel main$dtor$2
	DD	imagerel main$dtor$2+27
	DD	imagerel $unwind$main$dtor$2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$3 DD imagerel main$dtor$3
	DD	imagerel main$dtor$3+27
	DD	imagerel $unwind$main$dtor$3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z DD imagerel $LN9
	DD	imagerel $LN9+202
	DD	imagerel $unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel $LN11
	DD	imagerel $LN11+307
	DD	imagerel $unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??$emplace_back@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z DD imagerel $LN3
	DD	imagerel $LN3+175
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z DD imagerel $LN13
	DD	imagerel $LN13+535
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA+74
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD imagerel $LN3
	DD	imagerel $LN3+175
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DD imagerel $LN13
	DD	imagerel $LN13+546
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA+74
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+111
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+209
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+81
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN11
	DD	imagerel $LN11+261
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+77
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocma@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??$_Pocma@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel $LN6
	DD	imagerel $LN6+472
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+315
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+500
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+77
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+245
	DD	imagerel $unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YAPEADAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YAPEADAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD imagerel $LN21
	DD	imagerel $LN21+617
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD imagerel ?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	imagerel ?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD imagerel ?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	imagerel ?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+77
	DD	imagerel $unwind$?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN26
	DD	imagerel $LN26+1039
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+83
	DD	imagerel $unwind$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U_SYMBOL@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@@Z DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$??$destroy@U_SYMBOL@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+134
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAV_Facet_base@std@@PEAV12@@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEAPEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAV_Facet_base@std@@PEAV12@@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+212
	DD	imagerel $unwind$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0EI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Get_size_of_n@$0EI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+212
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+111
	DD	imagerel $unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAU_SYMBOL@@PEAPEAU1@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@00@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAU_SYMBOL@@PEAPEAU1@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@U_SYMBOL@@@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX$$QEAU_SYMBOL@@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@U_SYMBOL@@@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX$$QEAU_SYMBOL@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U_SYMBOL@@U1@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAU3@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct@U_SYMBOL@@U1@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAU3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?Symbols$initializer$@@3P6AXXZEA DQ FLAT:??__ESymbols@@YAXXZ ; Symbols$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b0H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	imagerel ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	098H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	0b0H
CONST	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	088H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	098H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BPCBEBLO@stoll?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BM@BPCBEBLO@stoll?5argument?5out?5of?5range@ DB 'stoll argument ou'
	DB	't of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KOGMOJCH@invalid?5stoll?5argument@
CONST	SEGMENT
??_C@_0BH@KOGMOJCH@invalid?5stoll?5argument@ DB 'invalid stoll argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ DB 'stoi argument out '
	DB	'of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
CONST	SEGMENT
??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@ DB 'invalid stoi argument', 00H ; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U_SYMBOL@@U1@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAU3@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@U_SYMBOL@@@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX$$QEAU_SYMBOL@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAU_SYMBOL@@PEAPEAU1@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@00@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	imagerel $ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 06H
	DB	00H
	DB	00H
	DB	0deH
	DB	02H
	DB	088H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0EI@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DB 06H
	DB	00H
	DB	00H
	DB	0deH
	DB	02H
	DB	088H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAV_Facet_base@std@@PEAV12@@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEAPEAV10@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U_SYMBOL@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	'}', 03H
	DB	02H
	DB	'H'
	DB	04H
	DB	'M', 0aH
	DB	02H
	DB	098H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	0bbH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 0aH
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	'*'
	DB	04H
	DB	'-', 06H
	DB	02H
	DB	0aeH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 038H
	DD	imagerel $stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	imagerel $tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	imagerel $ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 022819H
	DD	0130116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	08bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YAPEADAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	092H
	DB	02H
	DB	'U', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 022a19H
	DD	011011bH
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 012719H
	DD	0a218H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 022a19H
	DD	011011bH
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocma@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	0a5H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 06H
	DB	00H
	DB	00H
	DB	0e1H, 03H
	DB	02H
	DB	0cdH, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z DD 021619H
	DD	0130116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z DB 06H
	DB	00H
	DB	00H
	DB	0ddH, 03H
	DB	02H
	DB	0b1H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z DD 021619H
	DD	0130116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'L'
	DB	02H
	DB	'q', 02H
	DB	04H
	DB	'v'
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$3 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$2 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$1 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$0 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DB 012H
	DB	00H
	DB	00H
	DB	080H
	DB	02H
	DB	01cH
	DB	00H
	DB	'a', 02H
	DB	04H
	DB	'4'
	DB	00H
	DB	0e2H
	DB	06H
	DB	'L'
	DB	00H
	DB	08eH
	DB	08H
	DB	0a1H, 0aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DB 08H
	DB	0eH
	DD	imagerel main$dtor$0
	DB	036H
	DD	imagerel main$dtor$1
	DB	05eH
	DD	imagerel main$dtor$2
	DB	086H
	DD	imagerel main$dtor$3
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$main DB 028H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $ip2state$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	021919H
	DD	01750107H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$main
	DD	0b92H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TestFunc@@YA_J_J00000@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CXorStr@@YAXPEAXDK@Z DD 011201H
	DD	02212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z DB ' '
	DB	00H
	DB	00H
	DB	0b2H
	DB	02H
	DB	096H
	DB	04H
	DB	'&'
	DB	02H
	DB	'U', 04H
	DB	06H
	DB	'&'
	DB	02H
	DB	'x'
	DB	08H
	DB	'&'
	DB	02H
	DB	'r'
	DB	0aH
	DB	'&'
	DB	02H
	DB	'z'
	DB	0cH
	DB	','
	DB	02H
	DB	0ccH
	DB	0eH
	DB	','
	DB	02H
	DB	0aaH
	DB	00H
	DB	'\'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DB	056H
	DD	imagerel ?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DB	07eH
	DD	imagerel ?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DB	0a6H
	DD	imagerel ?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DB	0ceH
	DD	imagerel ?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
	DB	0f6H
	DD	imagerel ?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z DB 028H
	DD	imagerel $stateUnwindMap$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z
	DD	imagerel $ip2state$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z DD 022819H
	DD	0310116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z
	DD	017aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmAssembleToBlock@@YAXPEAU_SMCB@@@Z DD 021e19H
	DD	01f010cH
	DD	imagerel __GSHandlerCheck
	DD	0e8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmParseLoadedFile@@YAXXZ DD 010401H
	DD	0c204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'%', 04H
	DB	02H
	DB	'A', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 021b19H
	DD	013011bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 021e19H
	DD	015010cH
	DD	imagerel __GSHandlerCheck
	DD	098H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD 012219H
	DD	0e213H
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 012719H
	DD	06218H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 012219H
	DD	0e213H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 016H
	DB	00H
	DB	00H
	DB	015H, 04H
	DB	02H
	DB	'R'
	DB	00H
	DB	','
	DB	02H
	DB	'Y', 06H
	DB	00H
	DB	','
	DB	02H
	DB	086H
	DB	00H
	DB	'&'
	DB	02H
	DB	012H
	DB	00H
	DB	'&'
	DB	02H
	DB	'&'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 028H
	DD	imagerel $stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	imagerel $ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 021e19H
	DD	01d010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	0d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 022219H
	DD	01b0110H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 06H
	DB	00H
	DB	00H
	DB	0dH, 02H
	DB	02H
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 028H
	DD	imagerel $stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	imagerel $ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'*'
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 0aH
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	'b'
	DB	04H
	DB	0aaH
	DB	06H
	DB	0c2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	imagerel $ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0eH
	DB	00H
	DB	00H
	DB	0c0H
	DB	02H
	DB	'V'
	DB	00H
	DB	01eH
	DB	02H
	DB	01cH
	DB	04H
	DB	0f5H, 08H
	DB	02H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021e19H
	DD	037010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	01a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	00H
	DB	00H
	DB	0c1H, 03H
	DB	02H
	DB	'H'
	DB	04H
	DB	'}', 0aH
	DB	02H
	DB	098H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0cbH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 021001H
	DD	0130110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 06H
	DB	00H
	DB	00H
	DB	'~'
	DB	02H
	DB	0f5H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 028H
	DD	imagerel $stateUnwindMap$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	imagerel $ip2state$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'~'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	imagerel $ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'\'
	DB	04H
	DB	0c2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010d11H
	DD	0620dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z DB 06H
	DB	00H
	DB	00H
	DB	092H
	DB	02H
	DB	'q', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z DB 028H
	DD	imagerel $stateUnwindMap$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z
	DD	imagerel $ip2state$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z DD 022219H
	DD	02f0110H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z
	DD	0162H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmGetOpCode@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmGetInstructionSize@@YAHE@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FInstructions@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EInstructions@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FLabels@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ELabels@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ DD 010919H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXQEAPEAU_SYMBOL@@_K1@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00@Z DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept1@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAPEAPEAU_SYMBOL@@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FSymbols@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ESymbols@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@U_SYMBOL@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ DD 010919H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXQEAU_SYMBOL@@_K1@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00@Z DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept1@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_SYMBOL@@@std@@QEAAPEAU_SYMBOL@@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z DD 021101H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SmAllocCodeBlock@@YAXPEAU_SMCB@@K@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z DD 012719H
	DD	0a218H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z DD 012219H
	DD	06213H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_SYMBOL@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_SYMBOL@@QEAA@$$QEAU0@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_SYMBOL@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0cH
	DB	00H
	DB	00H
	DB	0b2H
	DB	02H
	DB	'*'
	DB	04H
	DB	'q', 03H
	DB	06H
	DB	0acH
	DB	04H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021511H
	DD	01d0115H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ DD 010919H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Move_assign@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Move_construct@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DB 0aH
	DB	00H
	DB	00H
	DB	08eH
	DB	02H
	DB	0ecH
	DB	04H
	DB	'z'
	DB	02H
	DB	0a6H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DB 028H
	DD	imagerel $stateUnwindMap$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
	DD	imagerel $ip2state$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD 022519H
	DD	0110116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
	DD	072H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z DD 031501H
	DD	07011c215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z DD 031501H
	DD	07011c215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD 011c19H
	DD	0c20dH
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stoll@std@@YA_JAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z DD 012219H
	DD	0a213H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z DD 012219H
	DD	0a213H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hex@std@@YAAEAVios_base@1@AEAV21@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Maklocwcs@std@@YAPEA_WPEB_W@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z DD 032919H
	DD	0140117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_cast@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_cast@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z DD 020e01H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z DB 060H
	DD	imagerel $ip2state$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z DD 011319H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 031001H
	DD	0700c6210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 020f19H
	DD	0700b720fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'n'
	DB	02H
	DB	08aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 011d19H
	DD	0a20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	092H
	DB	02H
	DB	09eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 012719H
	DD	0a218H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z DD 010e19H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	0c2H
	DB	02H
	DB	'v'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 011d19H
	DD	0a20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 021101H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wmemcpy DD 021101H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 012719H
	DD	0a218H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?Labels$initializer$@@3P6AXXZEA DQ FLAT:??__ELabels@@YAXXZ ; Labels$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?Instructions$initializer$@@3P6AXXZEA DQ FLAT:??__EInstructions@@YAXXZ ; Instructions$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00018	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0001d	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00022	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0002c	e8 00 00 00 00	 call	 ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00031	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
  00036	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv76[rsp]
  0003b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00040	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 695  :     }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	c3		 ret	 0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@U_SYMBOL@@U1@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAU3@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@U_SYMBOL@@U1@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,_SYMBOL>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00018	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0001d	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00022	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0002c	e8 00 00 00 00	 call	 ??$forward@U_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z ; std::forward<_SYMBOL>
  00031	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
  00036	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv76[rsp]
  0003b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00040	e8 00 00 00 00	 call	 ??0_SYMBOL@@QEAA@$$QEAU0@@Z

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 695  :     }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	c3		 ret	 0
??$construct@U_SYMBOL@@U1@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,_SYMBOL>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@U_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z PROC ; std::forward<_SYMBOL>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@U_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z ENDP ; std::forward<_SYMBOL>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z PROC		; std::_Refancy<char const *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 262  :     return _Ptr;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 263  : }

  0000a	c3		 ret	 0
??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z ENDP		; std::_Refancy<char const *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1507 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1508 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR <_Vals_0>$[rsp]
  00013	e8 00 00 00 00	 call	 ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00018	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00026	e8 00 00 00 00	 call	 ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0002b	48 89 44 24 28	 mov	 QWORD PTR tv76[rsp], rax
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00039	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
  0003e	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv78[rsp]
  00043	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv76[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv74[rsp]
  0004d	e8 00 00 00 00	 call	 ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1509 :         ++_Last;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005b	48 83 c0 20	 add	 rax, 32			; 00000020H
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00064	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1510 :     }

  00068	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006c	c3		 ret	 0
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release, COMDAT

; 1512 :     pointer _Release() { // suppress any exception handling backout and return _Last

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1513 :         _First = _Last;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0000f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00013	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1514 :         return _Last;

  00016	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1515 :     }

  0001f	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1502 :     ~_Uninitialized_backout_al() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1503 :         _Destroy_range(_First, _Last, _Al);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00020	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00023	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1504 :     }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _Dest$[rsp]
  00019	48 89 08	 mov	 QWORD PTR [rax], rcx
  0001c	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _Dest$[rsp]
  00026	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0002a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _Al_$[rsp]
  00034	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003d	c3		 ret	 0
??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBQEAV10@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBQEAV10@@Z PROC ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _It$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000d	c3		 ret	 0
??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBQEAV10@@Z ENDP ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Emplace_back@U_SYMBOL@@@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX$$QEAU_SYMBOL@@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@U_SYMBOL@@@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX$$QEAU_SYMBOL@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Emplace_back<_SYMBOL>, COMDAT

; 1507 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1508 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR <_Vals_0>$[rsp]
  00013	e8 00 00 00 00	 call	 ??$forward@U_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z ; std::forward<_SYMBOL>
  00018	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00026	e8 00 00 00 00	 call	 ??$_Unfancy@U_SYMBOL@@@std@@YAPEAU_SYMBOL@@PEAU1@@Z ; std::_Unfancy<_SYMBOL>
  0002b	48 89 44 24 28	 mov	 QWORD PTR tv76[rsp], rax
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00039	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
  0003e	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv78[rsp]
  00043	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv76[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv74[rsp]
  0004d	e8 00 00 00 00	 call	 ??$construct@U_SYMBOL@@U1@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAU3@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,_SYMBOL>

; 1509 :         ++_Last;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005b	48 83 c0 48	 add	 rax, 72			; 00000048H
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00064	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1510 :     }

  00068	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006c	c3		 ret	 0
??$_Emplace_back@U_SYMBOL@@@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX$$QEAU_SYMBOL@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Emplace_back<_SYMBOL>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Release, COMDAT

; 1512 :     pointer _Release() { // suppress any exception handling backout and return _Last

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1513 :         _First = _Last;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0000f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00013	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1514 :         return _Last;

  00016	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1515 :     }

  0001f	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::~_Uninitialized_backout_al<std::allocator<_SYMBOL> >, COMDAT

; 1502 :     ~_Uninitialized_backout_al() {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1503 :         _Destroy_range(_First, _Last, _Al);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00020	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00023	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z ; std::_Destroy_range<std::allocator<_SYMBOL> >

; 1504 :     }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::~_Uninitialized_backout_al<std::allocator<_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@PEAU_SYMBOL@@AEAV?$allocator@U_SYMBOL@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@PEAU_SYMBOL@@AEAV?$allocator@U_SYMBOL@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Uninitialized_backout_al<std::allocator<_SYMBOL> >, COMDAT

; 1497 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _Dest$[rsp]
  00019	48 89 08	 mov	 QWORD PTR [rax], rcx
  0001c	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _Dest$[rsp]
  00026	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0002a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _Al_$[rsp]
  00034	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003d	c3		 ret	 0
??0?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@PEAU_SYMBOL@@AEAV?$allocator@U_SYMBOL@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Uninitialized_backout_al<std::allocator<_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AEAU_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z PROC ; std::move<_SYMBOL &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1468 : }

  0000a	c3		 ret	 0
??$move@AEAU_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z ENDP ; std::move<_SYMBOL &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAU_SYMBOL@@@std@@YAPEAU_SYMBOL@@AEBQEAU1@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAU_SYMBOL@@@std@@YAPEAU_SYMBOL@@AEBQEAU1@@Z PROC ; std::_Get_unwrapped<_SYMBOL * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _It$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000d	c3		 ret	 0
??$_Get_unwrapped@AEBQEAU_SYMBOL@@@std@@YAPEAU_SYMBOL@@AEBQEAU1@@Z ENDP ; std::_Get_unwrapped<_SYMBOL * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAU_SYMBOL@@PEAPEAU1@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@00@Z
_TEXT	SEGMENT
_First_ch$ = 32
_Count$ = 40
_Dest_ch$ = 48
_Last_ch$ = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
??$_Copy_memmove@PEAPEAU_SYMBOL@@PEAPEAU1@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@00@Z PROC ; std::_Copy_memmove<_SYMBOL * *,_SYMBOL * *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR _First$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR _First_ch$[rsp], rax

; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR _Last$[rsp]
  00022	48 89 44 24 38	 mov	 QWORD PTR _Last_ch$[rsp], rax

; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR _Dest$[rsp]
  0002c	48 89 44 24 30	 mov	 QWORD PTR _Dest_ch$[rsp], rax

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR _First_ch$[rsp]
  00036	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Last_ch$[rsp]
  0003b	48 2b c8	 sub	 rcx, rax
  0003e	48 8b c1	 mov	 rax, rcx
  00041	48 89 44 24 28	 mov	 QWORD PTR _Count$[rsp], rax

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00046	4c 8b 44 24 28	 mov	 r8, QWORD PTR _Count$[rsp]
  0004b	48 8b 54 24 20	 mov	 rdx, QWORD PTR _First_ch$[rsp]
  00050	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Dest_ch$[rsp]
  00055	e8 00 00 00 00	 call	 memmove

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0005a	48 8b 44 24 28	 mov	 rax, QWORD PTR _Count$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Dest_ch$[rsp]
  00064	48 03 c8	 add	 rcx, rax
  00067	48 8b c1	 mov	 rax, rcx

; 4120 : }

  0006a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006e	c3		 ret	 0
??$_Copy_memmove@PEAPEAU_SYMBOL@@PEAPEAU1@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@00@Z ENDP ; std::_Copy_memmove<_SYMBOL * *,_SYMBOL * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@AEBQEAPEAU1@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@AEBQEAPEAU1@@Z PROC ; std::_Get_unwrapped<_SYMBOL * * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _It$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000d	c3		 ret	 0
??$_Get_unwrapped@AEBQEAPEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@AEBQEAPEAU1@@Z ENDP ; std::_Get_unwrapped<_SYMBOL * * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 105  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 106  :             return _Ok;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]

; 107  :         }

  0000e	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
_TEXT	SEGMENT
tv86 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 103  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

$LN4:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Istr$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00022	90		 npad	 1
  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 89 44 24 20	 mov	 QWORD PTR tv86[rsp], rax
  00030	0f b6 54 24 50	 movzx	 edx, BYTE PTR _Noskip$[rsp]
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv86[rsp]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00045	88 41 08	 mov	 BYTE PTR [rcx+8], al
  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv86 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv86 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 32
tv72 = 40
this$ = 64
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 88   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 89   :             const auto _Rdbuf = _Myistr.rdbuf();

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR tv72[rsp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00022	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv72[rsp]
  00027	48 03 c8	 add	 rcx, rax
  0002a	48 8b c1	 mov	 rax, rcx
  0002d	48 8b c8	 mov	 rcx, rax
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00036	48 89 44 24 20	 mov	 QWORD PTR _Rdbuf$[rsp], rax

; 90   :             if (_Rdbuf) {

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Rdbuf$[rsp], 0
  00041	74 11		 je	 SHORT $LN2@Sentry_bas

; 91   :                 _Rdbuf->_Unlock();

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR _Rdbuf$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Rdbuf$[rsp]
  00050	ff 50 10	 call	 QWORD PTR [rax+16]
  00053	90		 npad	 1
$LN2@Sentry_bas:

; 92   :             }
; 93   :         }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 32
tv73 = 40
this$ = 64
_Istr$ = 72
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 81   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Istr$[rsp]
  00018	48 89 08	 mov	 QWORD PTR [rax], rcx

; 82   :             const auto _Rdbuf = _Myistr.rdbuf();

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00020	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00023	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  00028	48 8b 44 24 28	 mov	 rax, QWORD PTR tv73[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00034	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv73[rsp]
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 8b c1	 mov	 rax, rcx
  0003f	48 8b c8	 mov	 rcx, rax
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00048	48 89 44 24 20	 mov	 QWORD PTR _Rdbuf$[rsp], rax

; 83   :             if (_Rdbuf) {

  0004d	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Rdbuf$[rsp], 0
  00053	74 10		 je	 SHORT $LN2@Sentry_bas

; 84   :                 _Rdbuf->_Lock();

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR _Rdbuf$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Rdbuf$[rsp]
  00062	ff 50 08	 call	 QWORD PTR [rax+8]
$LN2@Sentry_bas:

; 85   :             }
; 86   :         }

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR <_Val2_0>$[rsp]
  00017	e8 00 00 00 00	 call	 ??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ; std::forward<std::_Facet_base * &>
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00021	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00024	48 89 01	 mov	 QWORD PTR [rcx], rax
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
_TEXT	SEGMENT
tv70 = 32
_Left$ = 64
_Left_size$ = 72
_Right$ = 80
_Right_size$ = 88
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT

; 502  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 503  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 504  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _Right_size$[rsp]
  0001d	48 39 44 24 48	 cmp	 QWORD PTR _Left_size$[rsp], rax
  00022	75 22		 jne	 SHORT $LN3@Traits_equ
  00024	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Left_size$[rsp]
  00029	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Right$[rsp]
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Left$[rsp]
  00033	e8 00 00 00 00	 call	 ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
  00038	85 c0		 test	 eax, eax
  0003a	75 0a		 jne	 SHORT $LN3@Traits_equ
  0003c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN4@Traits_equ
$LN3@Traits_equ:
  00046	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN4@Traits_equ:
  0004e	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv70[rsp]

; 505  : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<32>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 44 24 20 01	 mov	 BYTE PTR _Overflow_is_possible$[rsp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000e	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  00018	48 89 44 24 28	 mov	 QWORD PTR _Max_possible$1[rsp], rax

; 60   :         if (_Count > _Max_possible) {

  0001d	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  00027	48 39 44 24 40	 cmp	 QWORD PTR _Count$[rsp], rax
  0002c	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00033	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR _Count$[rsp], 32 ; 00000020H
$LN3@Get_size_o:

; 66   : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<32>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$2 = 56
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
_Al$ = 136
??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00027	48 8d 4c 24 70	 lea	 rcx, QWORD PTR _First$[rsp]
  0002c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBQEAV10@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
  00031	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00036	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _Last$[rsp]
  0003b	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBQEAV10@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
  00040	48 89 44 24 28	 mov	 QWORD PTR _ULast$[rsp], rax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1656 :         return _Dest + (_ULast - _UFirst);
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00045	ba 18 00 00 00	 mov	 edx, 24
  0004a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  0004f	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX_K@Z
  00054	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR _Al$[rsp]
  0005c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR _Dest$[rsp]
  00064	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  00069	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006e	90		 npad	 1

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0006f	eb 0e		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR _UFirst$[rsp]
  00076	48 83 c0 20	 add	 rax, 32			; 00000020H
  0007a	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR _ULast$[rsp]
  00084	48 39 44 24 20	 cmp	 QWORD PTR _UFirst$[rsp], rax
  00089	74 19		 je	 SHORT $LN3@Uninitiali

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));

  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _UFirst$[rsp]
  00090	e8 00 00 00 00	 call	 ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00095	48 8b d0	 mov	 rdx, rax
  00098	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  0009d	e8 00 00 00 00	 call	 ??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1661 :         }

  000a2	eb cd		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1662 : 
; 1663 :         return _Backout._Release();

  000a4	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  000a9	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
  000ae	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  000b3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  000b8	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  000bd	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]

; 1664 :     }
; 1665 : }

  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c7	48 33 cc	 xor	 rcx, rsp
  000ca	e8 00 00 00 00	 call	 __security_check_cookie
  000cf	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000d3	c3		 ret	 0
??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$2 = 56
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
_Al$ = 136
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR _Backout$2[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$2 = 56
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
_Al$ = 136
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR _Backout$2[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0EI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0EI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<72>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 44 24 20 01	 mov	 BYTE PTR _Overflow_is_possible$[rsp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000e	48 b8 8e e3 38
	8e e3 38 8e 03	 mov	 rax, 256204778801521550	; 038e38e38e38e38eH
  00018	48 89 44 24 28	 mov	 QWORD PTR _Max_possible$1[rsp], rax

; 60   :         if (_Count > _Max_possible) {

  0001d	48 b8 8e e3 38
	8e e3 38 8e 03	 mov	 rax, 256204778801521550	; 038e38e38e38e38eH
  00027	48 39 44 24 40	 cmp	 QWORD PTR _Count$[rsp], rax
  0002c	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00033	48 6b 44 24 40
	48		 imul	 rax, QWORD PTR _Count$[rsp], 72 ; 00000048H
$LN3@Get_size_o:

; 66   : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
??$_Get_size_of_n@$0EI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<72>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$2 = 56
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
_Al$ = 136
??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z PROC ; std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00027	48 8d 4c 24 70	 lea	 rcx, QWORD PTR _First$[rsp]
  0002c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAU_SYMBOL@@@std@@YAPEAU_SYMBOL@@AEBQEAU1@@Z ; std::_Get_unwrapped<_SYMBOL * const &>
  00031	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00036	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _Last$[rsp]
  0003b	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAU_SYMBOL@@@std@@YAPEAU_SYMBOL@@AEBQEAU1@@Z ; std::_Get_unwrapped<_SYMBOL * const &>
  00040	48 89 44 24 28	 mov	 QWORD PTR _ULast$[rsp], rax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1656 :         return _Dest + (_ULast - _UFirst);
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00045	ba 18 00 00 00	 mov	 edx, 24
  0004a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  0004f	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z
  00054	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR _Al$[rsp]
  0005c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR _Dest$[rsp]
  00064	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  00069	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@PEAU_SYMBOL@@AEAV?$allocator@U_SYMBOL@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Uninitialized_backout_al<std::allocator<_SYMBOL> >
  0006e	90		 npad	 1

; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  0006f	eb 0e		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR _UFirst$[rsp]
  00076	48 83 c0 48	 add	 rax, 72			; 00000048H
  0007a	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR _ULast$[rsp]
  00084	48 39 44 24 20	 cmp	 QWORD PTR _UFirst$[rsp], rax
  00089	74 19		 je	 SHORT $LN3@Uninitiali

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));

  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _UFirst$[rsp]
  00090	e8 00 00 00 00	 call	 ??$move@AEAU_SYMBOL@@@std@@YA$$QEAU_SYMBOL@@AEAU1@@Z ; std::move<_SYMBOL &>
  00095	48 8b d0	 mov	 rdx, rax
  00098	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  0009d	e8 00 00 00 00	 call	 ??$_Emplace_back@U_SYMBOL@@@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX$$QEAU_SYMBOL@@@Z ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Emplace_back<_SYMBOL>

; 1661 :         }

  000a2	eb cd		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1662 : 
; 1663 :         return _Backout._Release();

  000a4	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  000a9	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@XZ ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::_Release
  000ae	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  000b3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Backout$2[rsp]
  000b8	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::~_Uninitialized_backout_al<std::allocator<_SYMBOL> >
  000bd	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]

; 1664 :     }
; 1665 : }

  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c7	48 33 cc	 xor	 rcx, rsp
  000ca	e8 00 00 00 00	 call	 __security_check_cookie
  000cf	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000d3	c3		 ret	 0
??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z ENDP ; std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$2 = 56
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
_Al$ = 136
?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR _Backout$2[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::~_Uninitialized_backout_al<std::allocator<_SYMBOL> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$2 = 56
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
_Al$ = 136
?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR _Backout$2[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<_SYMBOL> >::~_Uninitialized_backout_al<std::allocator<_SYMBOL> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 44 24 20 01	 mov	 BYTE PTR _Overflow_is_possible$[rsp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000e	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00018	48 89 44 24 28	 mov	 QWORD PTR _Max_possible$1[rsp], rax

; 60   :         if (_Count > _Max_possible) {

  0001d	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00027	48 39 44 24 40	 cmp	 QWORD PTR _Count$[rsp], rax
  0002c	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR _Count$[rsp]
  00038	48 c1 e0 03	 shl	 rax, 3
$LN3@Get_size_o:

; 66   : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$ = 88
??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z PROC ; std::_Uninitialized_move<_SYMBOL * *,std::allocator<_SYMBOL *> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00018	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _First$[rsp]
  0001d	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAPEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@AEBQEAPEAU1@@Z ; std::_Get_unwrapped<_SYMBOL * * const &>
  00022	48 89 44 24 20	 mov	 QWORD PTR _UFirst$[rsp], rax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00027	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Last$[rsp]
  0002c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBQEAPEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@AEBQEAPEAU1@@Z ; std::_Get_unwrapped<_SYMBOL * * const &>
  00031	48 89 44 24 28	 mov	 QWORD PTR _ULast$[rsp], rax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Dest$[rsp]
  0003b	e8 00 00 00 00	 call	 ??$_Unfancy@PEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@@Z ; std::_Unfancy<_SYMBOL *>
  00040	4c 8b c0	 mov	 r8, rax
  00043	48 8b 54 24 28	 mov	 rdx, QWORD PTR _ULast$[rsp]
  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _UFirst$[rsp]
  0004d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PEAPEAU_SYMBOL@@PEAPEAU1@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@00@Z ; std::_Copy_memmove<_SYMBOL * *,_SYMBOL * *>

; 1656 :         return _Dest + (_ULast - _UFirst);

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR _UFirst$[rsp]
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _ULast$[rsp]
  0005c	48 2b c8	 sub	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	48 c1 f8 03	 sar	 rax, 3
  00066	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Dest$[rsp]
  0006b	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z ENDP ; std::_Uninitialized_move<_SYMBOL * *,std::allocator<_SYMBOL *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$exchange@PEAV_Facet_base@std@@PEAV12@@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEAPEAV10@@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAV_Facet_base@std@@PEAV12@@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEAPEAV10@@Z PROC ; std::exchange<std::_Facet_base *,std::_Facet_base *>, COMDAT

; 597  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 598  :     // assign _New_val to _Val, return previous _Val
; 599  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Val$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 04 24	 mov	 QWORD PTR _Old_val$[rsp], rax

; 600  :     _Val         = static_cast<_Other&&>(_New_val);

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR _Val$[rsp]
  0001f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _New_val$[rsp]
  00024	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00027	48 89 08	 mov	 QWORD PTR [rax], rcx

; 601  :     return _Old_val;

  0002a	48 8b 04 24	 mov	 rax, QWORD PTR _Old_val$[rsp]

; 602  : }

  0002e	48 83 c4 18	 add	 rsp, 24
  00032	c3		 ret	 0
??$exchange@PEAV_Facet_base@std@@PEAV12@@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEAPEAV10@@Z ENDP ; std::exchange<std::_Facet_base *,std::_Facet_base *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 698  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 699  :         _Ptr->~_Uty();

  0000e	33 d2		 xor	 edx, edx
  00010	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00015	e8 00 00 00 00	 call	 ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z

; 700  :     }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR _Bytes$[rsp]
  0000e	48 83 c0 27	 add	 rax, 39			; 00000027H
  00012	48 89 44 24 28	 mov	 QWORD PTR _Block_size$[rsp], rax

; 116  :     if (_Block_size <= _Bytes) {

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR _Bytes$[rsp]
  0001c	48 39 44 24 28	 cmp	 QWORD PTR _Block_size$[rsp], rax
  00021	77 05		 ja	 SHORT $LN8@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00023	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00028	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Block_size$[rsp]
  0002d	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  00032	48 89 44 24 20	 mov	 QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Ptr_container$[rsp], 0
  0003d	74 02		 je	 SHORT $LN9@Allocate_m
  0003f	eb 0c		 jmp	 SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 f4		 jne	 SHORT $LN7@Allocate_m
$LN10@Allocate_m:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e4		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR _Ptr_container$[rsp]
  00058	48 83 c0 27	 add	 rax, 39			; 00000027H
  0005c	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H
  00060	48 89 44 24 30	 mov	 QWORD PTR _Ptr$[rsp], rax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00065	b8 08 00 00 00	 mov	 eax, 8
  0006a	48 6b c0 ff	 imul	 rax, rax, -1
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00073	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Ptr_container$[rsp]
  00078	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 129  : }

  00081	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00085	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 275  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 276  : }

  0000a	c3		 ret	 0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$destroy@U_SYMBOL@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@U_SYMBOL@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@@Z PROC ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::destroy<_SYMBOL>, COMDAT

; 698  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 699  :         _Ptr->~_Uty();

  0000e	33 d2		 xor	 edx, edx
  00010	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00015	e8 00 00 00 00	 call	 ??_G_SYMBOL@@QEAAPEAXI@Z

; 700  :     }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
??$destroy@U_SYMBOL@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::destroy<_SYMBOL>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _It$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000d	c3		 ret	 0
??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv68 = 48
$T3 = 56
__$ReturnUdt$ = 80
_Left$ = 88
_Right$ = 96
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 252  :             is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 253  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 254  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

  00013	48 8b 44 24 58	 mov	 rax, QWORD PTR _Left$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00020	48 8b 44 24 60	 mov	 rax, QWORD PTR _Right$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0002d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00032	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00037	48 89 44 24 30	 mov	 QWORD PTR tv68[rsp], rax
  0003c	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  00041	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv68[rsp]
  0004b	48 2b c8	 sub	 rcx, rax
  0004e	48 8b c1	 mov	 rax, rcx
  00051	48 89 44 24 38	 mov	 QWORD PTR $T3[rsp], rax
  00056	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T3[rsp]
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00060	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00065	48 8b 44 24 50	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 255  :     }

  0006a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006e	c3		 ret	 0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
_State$ = 32
tv307 = 36
tv189 = 37
tv312 = 38
tv250 = 39
_Pad$ = 40
tv136 = 48
tv308 = 52
$T1 = 56
$T2 = 60
tv313 = 64
$T3 = 68
$T4 = 72
tv306 = 80
tv191 = 88
tv309 = 96
tv216 = 104
tv310 = 112
tv311 = 120
tv252 = 128
tv273 = 136
tv287 = 144
tv302 = 152
$T5 = 160
_Ok$ = 168
__$ArrayPad$ = 184
_Ostr$ = 208
_Data$ = 216
_Size$ = 224
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 423  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 424  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 425  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 426  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

  00028	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _State$[rsp], 0

; 427  : 
; 428  :     _SizeT _Pad;
; 429  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  00030	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00038	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003b	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00047	48 03 c8	 add	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 8b c8	 mov	 rcx, rax
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00056	48 85 c0	 test	 rax, rax
  00059	7e 30		 jle	 SHORT $LN10@Insert_str
  0005b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00063	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00066	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0006a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00072	48 03 c8	 add	 rcx, rax
  00075	48 8b c1	 mov	 rax, rcx
  00078	48 8b c8	 mov	 rcx, rax
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00081	48 3b 84 24 e0
	00 00 00	 cmp	 rax, QWORD PTR _Size$[rsp]
  00089	77 0b		 ja	 SHORT $LN8@Insert_str
$LN10@Insert_str:

; 430  :         _Pad = 0;

  0008b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _Pad$[rsp], 0

; 431  :     } else {

  00094	eb 33		 jmp	 SHORT $LN9@Insert_str
$LN8@Insert_str:

; 432  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

  00096	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0009e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a1	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000a5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  000bc	48 2b 84 24 e0
	00 00 00	 sub	 rax, QWORD PTR _Size$[rsp]
  000c4	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN9@Insert_str:

; 433  :     }
; 434  : 
; 435  :     const typename _Ostr_t::sentry _Ok(_Ostr);

  000c9	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR _Ostr$[rsp]
  000d1	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  000d9	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000de	90		 npad	 1

; 436  : 
; 437  :     if (!_Ok) {

  000df	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  000e7	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000ec	0f b6 c0	 movzx	 eax, al
  000ef	85 c0		 test	 eax, eax
  000f1	75 10		 jne	 SHORT $LN11@Insert_str

; 438  :         _State |= _Ostr_t::badbit;

  000f3	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  000f7	83 c8 04	 or	 eax, 4
  000fa	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 439  :     } else { // state okay, insert characters

  000fe	e9 95 02 00 00	 jmp	 $LN12@Insert_str
$LN11@Insert_str:

; 440  :         _TRY_IO_BEGIN
; 441  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

  00103	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0010b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00112	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0011a	48 03 c8	 add	 rcx, rax
  0011d	48 8b c1	 mov	 rax, rcx
  00120	48 8b c8	 mov	 rcx, rax
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
  00129	89 44 24 30	 mov	 DWORD PTR tv136[rsp], eax
  0012d	8b 44 24 30	 mov	 eax, DWORD PTR tv136[rsp]
  00131	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00136	83 f8 40	 cmp	 eax, 64			; 00000040H
  00139	0f 84 d0 00 00
	00		 je	 $LN14@Insert_str

; 442  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0013f	eb 0d		 jmp	 SHORT $LN4@Insert_str
$LN2@Insert_str:
  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pad$[rsp]
  00146	48 ff c8	 dec	 rax
  00149	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN4@Insert_str:
  0014e	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pad$[rsp], 0
  00154	0f 86 b5 00 00
	00		 jbe	 $LN14@Insert_str

; 443  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0015a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00162	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00165	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00169	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00171	48 03 c8	 add	 rcx, rax
  00174	48 8b c1	 mov	 rax, rcx
  00177	48 8b c8	 mov	 rcx, rax
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00180	48 89 44 24 50	 mov	 QWORD PTR tv306[rsp], rax
  00185	48 8b 44 24 50	 mov	 rax, QWORD PTR tv306[rsp]
  0018a	48 89 44 24 58	 mov	 QWORD PTR tv191[rsp], rax
  0018f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00197	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0019e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  001a6	48 03 c8	 add	 rcx, rax
  001a9	48 8b c1	 mov	 rax, rcx
  001ac	48 8b c8	 mov	 rcx, rax
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  001b5	88 44 24 24	 mov	 BYTE PTR tv307[rsp], al
  001b9	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv307[rsp]
  001be	88 44 24 25	 mov	 BYTE PTR tv189[rsp], al
  001c2	0f b6 54 24 25	 movzx	 edx, BYTE PTR tv189[rsp]
  001c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv191[rsp]
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  001d2	89 44 24 34	 mov	 DWORD PTR tv308[rsp], eax
  001d6	8b 44 24 34	 mov	 eax, DWORD PTR tv308[rsp]
  001da	89 44 24 38	 mov	 DWORD PTR $T1[rsp], eax
  001de	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  001e3	89 44 24 3c	 mov	 DWORD PTR $T2[rsp], eax
  001e7	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T1[rsp]
  001ec	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR $T2[rsp]
  001f1	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  001f6	0f b6 c0	 movzx	 eax, al
  001f9	85 c0		 test	 eax, eax
  001fb	74 0d		 je	 SHORT $LN15@Insert_str

; 444  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  001fd	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  00201	83 c8 04	 or	 eax, 4
  00204	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 445  :                     break;

  00208	eb 05		 jmp	 SHORT $LN14@Insert_str
$LN15@Insert_str:

; 446  :                 }
; 447  :             }

  0020a	e9 32 ff ff ff	 jmp	 $LN2@Insert_str
$LN14@Insert_str:

; 448  :         }
; 449  : 
; 450  :         if (_State == _Ostr_t::goodbit
; 451  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  0020f	83 7c 24 20 00	 cmp	 DWORD PTR _State$[rsp], 0
  00214	75 74		 jne	 SHORT $LN16@Insert_str
  00216	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0021e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00221	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00225	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0022d	48 03 c8	 add	 rcx, rax
  00230	48 8b c1	 mov	 rax, rcx
  00233	48 8b c8	 mov	 rcx, rax
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0023c	48 89 44 24 60	 mov	 QWORD PTR tv309[rsp], rax
  00241	48 8b 44 24 60	 mov	 rax, QWORD PTR tv309[rsp]
  00246	48 89 44 24 68	 mov	 QWORD PTR tv216[rsp], rax
  0024b	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR _Size$[rsp]
  00253	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR _Data$[rsp]
  0025b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv216[rsp]
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00266	48 89 44 24 70	 mov	 QWORD PTR tv310[rsp], rax
  0026b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Size$[rsp]
  00273	48 39 44 24 70	 cmp	 QWORD PTR tv310[rsp], rax
  00278	74 10		 je	 SHORT $LN16@Insert_str

; 452  :             _State |= _Ostr_t::badbit;

  0027a	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  0027e	83 c8 04	 or	 eax, 4
  00281	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 453  :         } else {

  00285	e9 d6 00 00 00	 jmp	 $LN17@Insert_str
$LN16@Insert_str:

; 454  :             for (; 0 < _Pad; --_Pad) { // pad on right

  0028a	eb 0d		 jmp	 SHORT $LN7@Insert_str
$LN5@Insert_str:
  0028c	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pad$[rsp]
  00291	48 ff c8	 dec	 rax
  00294	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN7@Insert_str:
  00299	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pad$[rsp], 0
  0029f	0f 86 bb 00 00
	00		 jbe	 $LN17@Insert_str

; 455  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  002a5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  002ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002b4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  002bc	48 03 c8	 add	 rcx, rax
  002bf	48 8b c1	 mov	 rax, rcx
  002c2	48 8b c8	 mov	 rcx, rax
  002c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002cb	48 89 44 24 78	 mov	 QWORD PTR tv311[rsp], rax
  002d0	48 8b 44 24 78	 mov	 rax, QWORD PTR tv311[rsp]
  002d5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv252[rsp], rax
  002dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  002e5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002e8	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002ec	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  002f4	48 03 c8	 add	 rcx, rax
  002f7	48 8b c1	 mov	 rax, rcx
  002fa	48 8b c8	 mov	 rcx, rax
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  00303	88 44 24 26	 mov	 BYTE PTR tv312[rsp], al
  00307	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv312[rsp]
  0030c	88 44 24 27	 mov	 BYTE PTR tv250[rsp], al
  00310	0f b6 54 24 27	 movzx	 edx, BYTE PTR tv250[rsp]
  00315	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv252[rsp]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  00323	89 44 24 40	 mov	 DWORD PTR tv313[rsp], eax
  00327	8b 44 24 40	 mov	 eax, DWORD PTR tv313[rsp]
  0032b	89 44 24 44	 mov	 DWORD PTR $T3[rsp], eax
  0032f	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00334	89 44 24 48	 mov	 DWORD PTR $T4[rsp], eax
  00338	48 8d 54 24 44	 lea	 rdx, QWORD PTR $T3[rsp]
  0033d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T4[rsp]
  00342	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00347	0f b6 c0	 movzx	 eax, al
  0034a	85 c0		 test	 eax, eax
  0034c	74 0d		 je	 SHORT $LN18@Insert_str

; 456  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  0034e	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  00352	83 c8 04	 or	 eax, 4
  00355	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 457  :                     break;

  00359	eb 05		 jmp	 SHORT $LN17@Insert_str
$LN18@Insert_str:

; 458  :                 }
; 459  :             }

  0035b	e9 2c ff ff ff	 jmp	 $LN5@Insert_str
$LN17@Insert_str:

; 460  :         }
; 461  : 
; 462  :         _Ostr.width(0);

  00360	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00368	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0036b	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0036f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00377	48 03 c8	 add	 rcx, rax
  0037a	48 8b c1	 mov	 rax, rcx
  0037d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  00385	33 d2		 xor	 edx, edx
  00387	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv273[rsp]
  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
  00395	90		 npad	 1
  00396	eb 00		 jmp	 SHORT $LN12@Insert_str
$LN24@Insert_str:
$LN12@Insert_str:

; 463  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 464  :     }
; 465  : 
; 466  :     _Ostr.setstate(_State);

  00398	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  003a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a3	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  003a7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  003af	48 03 c8	 add	 rcx, rax
  003b2	48 8b c1	 mov	 rax, rcx
  003b5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv302[rsp], rax
  003bd	45 33 c0	 xor	 r8d, r8d
  003c0	8b 54 24 20	 mov	 edx, DWORD PTR _State$[rsp]
  003c4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv302[rsp]
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 467  :     return _Ostr;

  003d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  003da	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  003e2	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  003ea	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  003ef	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]

; 468  : }

  003f7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ff	48 33 cc	 xor	 rcx, rsp
  00402	e8 00 00 00 00	 call	 __security_check_cookie
  00407	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0040e	c3		 ret	 0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv307 = 36
tv189 = 37
tv312 = 38
tv250 = 39
_Pad$ = 40
tv136 = 48
tv308 = 52
$T1 = 56
$T2 = 60
tv313 = 64
$T3 = 68
$T4 = 72
tv306 = 80
tv191 = 88
tv309 = 96
tv216 = 104
tv310 = 112
tv311 = 120
tv252 = 128
tv273 = 136
tv287 = 144
tv302 = 152
$T5 = 160
_Ok$ = 168
__$ArrayPad$ = 184
_Ostr$ = 208
_Data$ = 216
_Size$ = 224
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rbp]
  00010	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv307 = 36
tv189 = 37
tv312 = 38
tv250 = 39
_Pad$ = 40
tv136 = 48
tv308 = 52
$T1 = 56
$T2 = 60
tv313 = 64
$T3 = 68
$T4 = 72
tv306 = 80
tv191 = 88
tv309 = 96
tv216 = 104
tv310 = 112
tv311 = 120
tv252 = 128
tv273 = 136
tv287 = 144
tv302 = 152
$T5 = 160
_Ok$ = 168
__$ArrayPad$ = 184
_Ostr$ = 208
_Data$ = 216
_Size$ = 224
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1

; 463  :         _CATCH_IO_(_Ostr_t, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  0000d	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001b	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv287[rbp], rax
  0002f	41 b0 01	 mov	 r8b, 1
  00032	ba 04 00 00 00	 mov	 edx, 4
  00037	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv287[rbp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00044	90		 npad	 1
  00045	48 8d 05 00 00
	00 00		 lea	 rax, $LN24@catch$1
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
  00052	cc		 int	 3
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv307 = 36
tv189 = 37
tv312 = 38
tv250 = 39
_Pad$ = 40
tv136 = 48
tv308 = 52
$T1 = 56
$T2 = 60
tv313 = 64
$T3 = 68
$T4 = 72
tv306 = 80
tv191 = 88
tv309 = 96
tv216 = 104
tv310 = 112
tv311 = 120
tv252 = 128
tv273 = 136
tv287 = 144
tv302 = 152
$T5 = 160
_Ok$ = 168
__$ArrayPad$ = 184
_Ostr$ = 208
_Data$ = 216
_Size$ = 224
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rbp]
  00010	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv307 = 36
tv189 = 37
tv312 = 38
tv250 = 39
_Pad$ = 40
tv136 = 48
tv308 = 52
$T1 = 56
$T2 = 60
tv313 = 64
$T3 = 68
$T4 = 72
tv306 = 80
tv191 = 88
tv309 = 96
tv216 = 104
tv310 = 112
tv311 = 120
tv252 = 128
tv273 = 136
tv287 = 144
tv302 = 152
$T5 = 160
_Ok$ = 168
__$ArrayPad$ = 184
_Ostr$ = 208
_Data$ = 216
_Size$ = 224
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1

; 463  :         _CATCH_IO_(_Ostr_t, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  0000d	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001b	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv287[rbp], rax
  0002f	41 b0 01	 mov	 r8b, 1
  00032	ba 04 00 00 00	 mov	 edx, 4
  00037	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv287[rbp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00044	90		 npad	 1
  00045	48 8d 05 00 00
	00 00		 lea	 rax, $LN24@catch$1
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
  00052	cc		 int	 3
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
_Changed$ = 32
_State$ = 36
tv208 = 40
tv210 = 44
$T1 = 48
tv65 = 56
tv209 = 64
tv211 = 72
tv165 = 80
tv186 = 88
tv204 = 96
$T2 = 104
_Meta$3 = 112
_Metadelim$4 = 116
_Ok$ = 120
__$ArrayPad$ = 136
_Istr$ = 160
_Str$ = 168
_Delim$ = 176
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 29   :     const _Elem _Delim) { // get characters into string, discard delimiter

$LN21:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 30   :     using _Myis = basic_istream<_Elem, _Traits>;
; 31   : 
; 32   :     typename _Myis::iostate _State = _Myis::goodbit;

  00028	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _State$[rsp], 0

; 33   :     bool _Changed                  = false;

  00030	c6 44 24 20 00	 mov	 BYTE PTR _Changed$[rsp], 0

; 34   :     const typename _Myis::sentry _Ok(_Istr, true);

  00035	41 b0 01	 mov	 r8b, 1
  00038	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR _Istr$[rsp]
  00040	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _Ok$[rsp]
  00045	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0004a	90		 npad	 1

; 35   : 
; 36   :     if (_Ok) { // state okay, extract characters

  0004b	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _Ok$[rsp]
  00050	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  00055	0f b6 c0	 movzx	 eax, al
  00058	85 c0		 test	 eax, eax
  0005a	0f 84 8d 01 00
	00		 je	 $LN5@getline

; 37   :         _TRY_IO_BEGIN
; 38   :         _Str.erase();

  00060	33 d2		 xor	 edx, edx
  00062	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _Str$[rsp]
  0006a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 39   :         const typename _Traits::int_type _Metadelim = _Traits::to_int_type(_Delim);

  0006f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Delim$[rsp]
  00077	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  0007c	89 44 24 74	 mov	 DWORD PTR _Metadelim$4[rsp], eax

; 40   :         typename _Traits::int_type _Meta            = _Istr.rdbuf()->sgetc();

  00080	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR _Istr$[rsp]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0008f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _Istr$[rsp]
  00097	48 03 c8	 add	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000a6	48 89 44 24 38	 mov	 QWORD PTR tv65[rsp], rax
  000ab	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv65[rsp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  000b6	89 44 24 28	 mov	 DWORD PTR tv208[rsp], eax
  000ba	8b 44 24 28	 mov	 eax, DWORD PTR tv208[rsp]
  000be	89 44 24 70	 mov	 DWORD PTR _Meta$3[rsp], eax

; 41   : 
; 42   :         for (;; _Meta = _Istr.rdbuf()->snextc()) {

  000c2	eb 42		 jmp	 SHORT $LN4@getline
$LN2@getline:
  000c4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR _Istr$[rsp]
  000cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cf	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _Istr$[rsp]
  000db	48 03 c8	 add	 rcx, rax
  000de	48 8b c1	 mov	 rax, rcx
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000ea	48 89 44 24 40	 mov	 QWORD PTR tv209[rsp], rax
  000ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv209[rsp]
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  000fa	89 44 24 2c	 mov	 DWORD PTR tv210[rsp], eax
  000fe	8b 44 24 2c	 mov	 eax, DWORD PTR tv210[rsp]
  00102	89 44 24 70	 mov	 DWORD PTR _Meta$3[rsp], eax
$LN4@getline:

; 43   :             if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  00106	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0010b	89 44 24 30	 mov	 DWORD PTR $T1[rsp], eax
  0010f	48 8d 54 24 70	 lea	 rdx, QWORD PTR _Meta$3[rsp]
  00114	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00119	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0011e	0f b6 c0	 movzx	 eax, al
  00121	85 c0		 test	 eax, eax
  00123	74 15		 je	 SHORT $LN7@getline

; 44   :                 _State |= _Myis::eofbit;

  00125	8b 44 24 24	 mov	 eax, DWORD PTR _State$[rsp]
  00129	83 c8 01	 or	 eax, 1
  0012c	89 44 24 24	 mov	 DWORD PTR _State$[rsp], eax

; 45   :                 break;

  00130	e9 b6 00 00 00	 jmp	 $LN3@getline
  00135	e9 ac 00 00 00	 jmp	 $LN8@getline
$LN7@getline:

; 46   :             } else if (_Traits::eq_int_type(_Meta, _Metadelim)) { // got a delimiter, discard it and quit

  0013a	48 8d 54 24 74	 lea	 rdx, QWORD PTR _Metadelim$4[rsp]
  0013f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR _Meta$3[rsp]
  00144	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00149	0f b6 c0	 movzx	 eax, al
  0014c	85 c0		 test	 eax, eax
  0014e	74 3f		 je	 SHORT $LN9@getline

; 47   :                 _Changed = true;

  00150	c6 44 24 20 01	 mov	 BYTE PTR _Changed$[rsp], 1

; 48   :                 _Istr.rdbuf()->sbumpc();

  00155	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR _Istr$[rsp]
  0015d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00160	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00164	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _Istr$[rsp]
  0016c	48 03 c8	 add	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	48 8b c8	 mov	 rcx, rax
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0017b	48 89 44 24 48	 mov	 QWORD PTR tv211[rsp], rax
  00180	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv211[rsp]
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ

; 49   :                 break;

  0018b	eb 5e		 jmp	 SHORT $LN3@getline
  0018d	eb 57		 jmp	 SHORT $LN8@getline
$LN9@getline:

; 50   :             } else if (_Str.max_size() <= _Str.size()) { // string too large, quit

  0018f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _Str$[rsp]
  00197	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0019c	48 89 44 24 50	 mov	 QWORD PTR tv165[rsp], rax
  001a1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _Str$[rsp]
  001a9	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  001ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv165[rsp]
  001b3	48 3b c1	 cmp	 rax, rcx
  001b6	77 0f		 ja	 SHORT $LN11@getline

; 51   :                 _State |= _Myis::failbit;

  001b8	8b 44 24 24	 mov	 eax, DWORD PTR _State$[rsp]
  001bc	83 c8 02	 or	 eax, 2
  001bf	89 44 24 24	 mov	 DWORD PTR _State$[rsp], eax

; 52   :                 break;

  001c3	eb 26		 jmp	 SHORT $LN3@getline

; 53   :             } else { // got a character, add it to string

  001c5	eb 1f		 jmp	 SHORT $LN8@getline
$LN11@getline:

; 54   :                 _Str += _Traits::to_char_type(_Meta);

  001c7	48 8d 4c 24 70	 lea	 rcx, QWORD PTR _Meta$3[rsp]
  001cc	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  001d1	0f b6 d0	 movzx	 edx, al
  001d4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _Str$[rsp]
  001dc	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 55   :                 _Changed = true;

  001e1	c6 44 24 20 01	 mov	 BYTE PTR _Changed$[rsp], 1
$LN8@getline:

; 56   :             }
; 57   :         }

  001e6	e9 d9 fe ff ff	 jmp	 $LN2@getline
$LN3@getline:
  001eb	eb 00		 jmp	 SHORT $LN5@getline
$LN19@getline:
$LN5@getline:

; 58   :         _CATCH_IO_(_Myis, _Istr)
; 59   :     }
; 60   : 
; 61   :     if (!_Changed) {

  001ed	0f b6 44 24 20	 movzx	 eax, BYTE PTR _Changed$[rsp]
  001f2	85 c0		 test	 eax, eax
  001f4	75 0b		 jne	 SHORT $LN13@getline

; 62   :         _State |= _Myis::failbit;

  001f6	8b 44 24 24	 mov	 eax, DWORD PTR _State$[rsp]
  001fa	83 c8 02	 or	 eax, 2
  001fd	89 44 24 24	 mov	 DWORD PTR _State$[rsp], eax
$LN13@getline:

; 63   :     }
; 64   : 
; 65   :     _Istr.setstate(_State);

  00201	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR _Istr$[rsp]
  00209	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020c	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00210	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _Istr$[rsp]
  00218	48 03 c8	 add	 rcx, rax
  0021b	48 8b c1	 mov	 rax, rcx
  0021e	48 89 44 24 60	 mov	 QWORD PTR tv204[rsp], rax
  00223	45 33 c0	 xor	 r8d, r8d
  00226	8b 54 24 24	 mov	 edx, DWORD PTR _State$[rsp]
  0022a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv204[rsp]
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 66   :     return _Istr;

  00235	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR _Istr$[rsp]
  0023d	48 89 44 24 68	 mov	 QWORD PTR $T2[rsp], rax
  00242	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _Ok$[rsp]
  00247	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
  0024c	48 8b 44 24 68	 mov	 rax, QWORD PTR $T2[rsp]

; 67   : }

  00251	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00259	48 33 cc	 xor	 rcx, rsp
  0025c	e8 00 00 00 00	 call	 __security_check_cookie
  00261	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00268	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
tv208 = 40
tv210 = 44
$T1 = 48
tv65 = 56
tv209 = 64
tv211 = 72
tv165 = 80
tv186 = 88
tv204 = 96
$T2 = 104
_Meta$3 = 112
_Metadelim$4 = 116
_Ok$ = 120
__$ArrayPad$ = 136
_Istr$ = 160
_Str$ = 168
_Delim$ = 176
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 78	 lea	 rcx, QWORD PTR _Ok$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
tv208 = 40
tv210 = 44
$T1 = 48
tv65 = 56
tv209 = 64
tv211 = 72
tv165 = 80
tv186 = 88
tv204 = 96
$T2 = 104
_Meta$3 = 112
_Metadelim$4 = 116
_Ok$ = 120
__$ArrayPad$ = 136
_Istr$ = 160
_Str$ = 168
_Delim$ = 176
?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$1

; 58   :         _CATCH_IO_(_Myis, _Istr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
  0000d	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Istr$[rbp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001b	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Istr$[rbp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 89 45 58	 mov	 QWORD PTR tv186[rbp], rax
  0002c	41 b0 01	 mov	 r8b, 1
  0002f	ba 04 00 00 00	 mov	 edx, 4
  00034	48 8b 4d 58	 mov	 rcx, QWORD PTR tv186[rbp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0003e	90		 npad	 1
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$1
  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
  0004c	cc		 int	 3
?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
tv208 = 40
tv210 = 44
$T1 = 48
tv65 = 56
tv209 = 64
tv211 = 72
tv165 = 80
tv186 = 88
tv204 = 96
$T2 = 104
_Meta$3 = 112
_Metadelim$4 = 116
_Ok$ = 120
__$ArrayPad$ = 136
_Istr$ = 160
_Str$ = 168
_Delim$ = 176
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 78	 lea	 rcx, QWORD PTR _Ok$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
tv208 = 40
tv210 = 44
$T1 = 48
tv65 = 56
tv209 = 64
tv211 = 72
tv165 = 80
tv186 = 88
tv204 = 96
$T2 = 104
_Meta$3 = 112
_Metadelim$4 = 116
_Ok$ = 120
__$ArrayPad$ = 136
_Istr$ = 160
_Str$ = 168
_Delim$ = 176
?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$1

; 58   :         _CATCH_IO_(_Myis, _Istr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
  0000d	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR _Istr$[rbp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001b	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR _Istr$[rbp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 89 45 58	 mov	 QWORD PTR tv186[rbp], rax
  0002c	41 b0 01	 mov	 r8b, 1
  0002f	ba 04 00 00 00	 mov	 edx, 4
  00034	48 8b 4d 58	 mov	 rcx, QWORD PTR tv186[rbp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0003e	90		 npad	 1
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$1
  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
  0004c	cc		 int	 3
?catch$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1468 : }

  0000a	c3		 ret	 0
??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z
_TEXT	SEGMENT
_It$ = 48
_UIt$ = 56
??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z PROC ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char * &>, COMDAT

; 1417 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1418 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1419 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR _UIt$[rsp]
  00013	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _It$[rsp]
  0001b	e8 00 00 00 00	 call	 ?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Seek_to

; 1420 :     } else {
; 1421 :         _It = static_cast<_UIter&&>(_UIt);
; 1422 :     }
; 1423 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z ENDP ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YAPEADAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z
_TEXT	SEGMENT
_COff$1 = 32
_It$ = 64
_Off$ = 72
??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YAPEADAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z PROC ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &,__int64>, COMDAT

; 1335 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1336 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1337 :         return _It + 0;
; 1338 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1339 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1340 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1341 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1342 :         const auto _COff = static_cast<_CDiff>(_Off);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR _Off$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR _COff$1[rsp], rax

; 1343 : 
; 1344 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1345 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1346 :             "integer overflow");
; 1347 :         (void) _COff;
; 1348 : 
; 1349 :         _It._Verify_offset(static_cast<_IDiff>(_Off));

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Off$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _It$[rsp]
  00022	e8 00 00 00 00	 call	 ?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Verify_offset

; 1350 :         return static_cast<_Iter&&>(_It)._Unwrapped();

  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _It$[rsp]
  0002c	e8 00 00 00 00	 call	 ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped

; 1351 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1352 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1353 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1354 :     } else {
; 1355 :         // pass through iterator that doesn't participate in checking
; 1356 :         return static_cast<_Iter&&>(_It);
; 1357 :     }
; 1358 : }

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YAPEADAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z ENDP ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA_JAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA_JAEBQEAD0@Z PROC ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char *>, COMDAT

; 1483 : _NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1484 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1485 :     if constexpr (_Is_random_iter_v<_Iter>) {
; 1486 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR _Last$[rsp]
  0000f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR _First$[rsp]
  00014	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00017	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001a	48 2b c1	 sub	 rax, rcx

; 1487 :     } else {
; 1488 :         return _Distance_unknown{};
; 1489 :     }
; 1490 : }

  0001d	c3		 ret	 0
??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA_JAEBQEAD0@Z ENDP ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;
; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _It$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped

; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT

; 1192 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1193 :     // check that [_First, _Last) forms an iterator range
; 1194 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1195 :         _Verify_range(_First, _Last);
; 1196 :     }
; 1197 : }

  0000a	c3		 ret	 0
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z
_TEXT	SEGMENT
_UVal_trunc$ = 0
_RNext$ = 32
_UVal$ = 40
??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z PROC	; std::_UIntegral_to_buff<char,unsigned __int64>, COMDAT

; 454  : _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { // format _UVal into buffer *ending at* _RNext

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 455  :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 456  : 
; 457  : #ifdef _WIN64
; 458  :     auto _UVal_trunc = _UVal;

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR _UVal$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR _UVal_trunc$[rsp], rax
$LN4@UIntegral_:

; 459  : #else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
; 460  : 
; 461  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 462  :     if _CONSTEXPR_IF (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 463  :         while (_UVal > 0xFFFFFFFFU) {
; 464  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 465  :             _UVal /= 1000000000;
; 466  : 
; 467  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 468  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 469  :                 _UVal_chunk /= 10;
; 470  :             }
; 471  :         }
; 472  :     }
; 473  : 
; 474  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 475  : #endif // _WIN64
; 476  : 
; 477  :     do {
; 478  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR _RNext$[rsp]
  0001c	48 ff c8	 dec	 rax
  0001f	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax
  00024	33 d2		 xor	 edx, edx
  00026	48 8b 04 24	 mov	 rax, QWORD PTR _UVal_trunc$[rsp]
  0002a	b9 0a 00 00 00	 mov	 ecx, 10
  0002f	48 f7 f1	 div	 rcx
  00032	48 8b c2	 mov	 rax, rdx
  00035	48 83 c0 30	 add	 rax, 48			; 00000030H
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _RNext$[rsp]
  0003e	88 01		 mov	 BYTE PTR [rcx], al

; 479  :         _UVal_trunc /= 10;

  00040	33 d2		 xor	 edx, edx
  00042	48 8b 04 24	 mov	 rax, QWORD PTR _UVal_trunc$[rsp]
  00046	b9 0a 00 00 00	 mov	 ecx, 10
  0004b	48 f7 f1	 div	 rcx
  0004e	48 89 04 24	 mov	 QWORD PTR _UVal_trunc$[rsp], rax

; 480  :     } while (_UVal_trunc != 0);

  00052	48 83 3c 24 00	 cmp	 QWORD PTR _UVal_trunc$[rsp], 0
  00057	75 be		 jne	 SHORT $LN4@UIntegral_

; 481  :     return _RNext;

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR _RNext$[rsp]

; 482  : }

  0005e	48 83 c4 18	 add	 rsp, 24
  00062	c3		 ret	 0
??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z ENDP	; std::_UIntegral_to_buff<char,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 36
tv70 = 40
_Alproxy$ = 48
tv128 = 56
tv94 = 64
_Proxy$ = 72
__$ArrayPad$ = 80
this$ = 112
_First$ = 120
_Last$ = 128
_Al$ = 136
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>, COMDAT

; 2376 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0002c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00031	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR _Al$[rsp]
  00039	0f b6 54 24 22	 movzx	 edx, BYTE PTR $T3[rsp]
  0003e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv70[rsp]
  00043	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
  00048	90		 npad	 1

; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00049	48 8d 44 24 23	 lea	 rax, QWORD PTR $T4[rsp]
  0004e	48 89 44 24 30	 mov	 QWORD PTR _Alproxy$[rsp], rax

; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00053	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00058	4c 8b c0	 mov	 r8, rax
  0005b	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Alproxy$[rsp]
  00060	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00065	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2379 :         _Tidy_init();

  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0006f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2380 :         _Adl_verify_range(_First, _Last);

  00074	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR _Last$[rsp]
  0007c	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _First$[rsp]
  00081	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>

; 2381 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());

  00086	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T5[rsp]
  0008b	88 44 24 20	 mov	 BYTE PTR $T1[rsp], al
  0008f	0f b6 44 24 20	 movzx	 eax, BYTE PTR $T1[rsp]
  00094	88 44 24 21	 mov	 BYTE PTR $T2[rsp], al
  00098	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR _Last$[rsp]
  000a0	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z ; std::_Get_unwrapped<char * &>
  000a5	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000aa	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _First$[rsp]
  000af	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z ; std::_Get_unwrapped<char * &>
  000b4	48 89 44 24 40	 mov	 QWORD PTR tv94[rsp], rax
  000b9	44 0f b6 4c 24
	21		 movzx	 r9d, BYTE PTR $T2[rsp]
  000bf	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv128[rsp]
  000c4	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv94[rsp]
  000c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  000ce	e8 00 00 00 00	 call	 ?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct

; 2382 :         _Proxy._Release();

  000d3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  000d8	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
  000dd	90		 npad	 1

; 2383 :     }

  000de	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e8	48 33 cc	 xor	 rcx, rsp
  000eb	e8 00 00 00 00	 call	 __security_check_cookie
  000f0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000f4	c3		 ret	 0
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 36
tv70 = 40
_Alproxy$ = 48
tv128 = 56
tv94 = 64
_Proxy$ = 72
__$ArrayPad$ = 80
this$ = 112
_First$ = 120
_Last$ = 128
_Al$ = 136
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 36
tv70 = 40
_Alproxy$ = 48
tv128 = 56
tv94 = 64
_Proxy$ = 72
__$ArrayPad$ = 80
this$ = 112
_First$ = 120
_Last$ = 128
_Al$ = 136
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 70	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
_TEXT	SEGMENT
_UVal_trunc$ = 0
_RNext$ = 32
_UVal$ = 40
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z PROC	; std::_UIntegral_to_buff<char,unsigned int>, COMDAT

; 454  : _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { // format _UVal into buffer *ending at* _RNext

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 455  :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 456  : 
; 457  : #ifdef _WIN64
; 458  :     auto _UVal_trunc = _UVal;

  0000d	8b 44 24 28	 mov	 eax, DWORD PTR _UVal$[rsp]
  00011	89 04 24	 mov	 DWORD PTR _UVal_trunc$[rsp], eax
$LN4@UIntegral_:

; 459  : #else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
; 460  : 
; 461  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 462  :     if _CONSTEXPR_IF (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 463  :         while (_UVal > 0xFFFFFFFFU) {
; 464  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 465  :             _UVal /= 1000000000;
; 466  : 
; 467  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 468  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 469  :                 _UVal_chunk /= 10;
; 470  :             }
; 471  :         }
; 472  :     }
; 473  : 
; 474  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 475  : #endif // _WIN64
; 476  : 
; 477  :     do {
; 478  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

  00014	48 8b 44 24 20	 mov	 rax, QWORD PTR _RNext$[rsp]
  00019	48 ff c8	 dec	 rax
  0001c	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax
  00021	33 d2		 xor	 edx, edx
  00023	8b 04 24	 mov	 eax, DWORD PTR _UVal_trunc$[rsp]
  00026	b9 0a 00 00 00	 mov	 ecx, 10
  0002b	f7 f1		 div	 ecx
  0002d	8b c2		 mov	 eax, edx
  0002f	83 c0 30	 add	 eax, 48			; 00000030H
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _RNext$[rsp]
  00037	88 01		 mov	 BYTE PTR [rcx], al

; 479  :         _UVal_trunc /= 10;

  00039	33 d2		 xor	 edx, edx
  0003b	8b 04 24	 mov	 eax, DWORD PTR _UVal_trunc$[rsp]
  0003e	b9 0a 00 00 00	 mov	 ecx, 10
  00043	f7 f1		 div	 ecx
  00045	89 04 24	 mov	 DWORD PTR _UVal_trunc$[rsp], eax

; 480  :     } while (_UVal_trunc != 0);

  00048	83 3c 24 00	 cmp	 DWORD PTR _UVal_trunc$[rsp], 0
  0004c	75 c6		 jne	 SHORT $LN4@UIntegral_

; 481  :     return _RNext;

  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR _RNext$[rsp]

; 482  : }

  00053	48 83 c4 18	 add	 rsp, 24
  00057	c3		 ret	 0
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ENDP	; std::_UIntegral_to_buff<char,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
_TEXT	SEGMENT
_Array$ = 8
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z PROC		; std::end<char,21>, COMDAT

; 2122 : _NODISCARD constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 2123 :     return _Array + _Size;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Array$[rsp]
  0000a	48 83 c0 15	 add	 rax, 21

; 2124 : }

  0000e	c3		 ret	 0
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ENDP		; std::end<char,21>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Ptr$ = 72
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT

; 2455 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00018	4c 8d 44 24 48	 lea	 r8, QWORD PTR _Ptr$[rsp]
  0001d	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00022	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv70[rsp]
  00027	e8 00 00 00 00	 call	 ??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1344 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1345 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT

; 2540 :     pointer release() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2541 :         return _STD exchange(_Mypair._Myval2, pointer());

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR $T1[rsp], 0
  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00017	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ??$exchange@PEAV_Facet_base@std@@PEAV12@@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEAPEAV10@@Z ; std::exchange<std::_Facet_base *,std::_Facet_base *>

; 2542 :     }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv75 = 32
tv77 = 40
this$ = 64
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT

; 2510 :     ~unique_ptr() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2511 :         if (_Mypair._Myval2) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00012	74 2e		 je	 SHORT $LN2@unique_ptr

; 2512 :             _Mypair._Get_first()(_Mypair._Myval2);

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
  00021	48 89 44 24 28	 mov	 QWORD PTR tv77[rsp], rax
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 44 24 20	 mov	 QWORD PTR tv75[rsp], rax
  00033	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv75[rsp]
  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv77[rsp]
  0003d	e8 00 00 00 00	 call	 ??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
$LN2@unique_ptr:

; 2513 :         }
; 2514 :     }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv71 = 40
tv72 = 48
this$ = 80
_Ptr$ = 88
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT

; 2400 :     void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2401 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 2402 :         delete _Ptr;

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0001e	74 25		 je	 SHORT $LN3@operator
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 89 44 24 28	 mov	 QWORD PTR tv71[rsp], rax
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0003a	ff 54 24 28	 call	 QWORD PTR tv71[rsp]
  0003e	48 89 44 24 30	 mov	 QWORD PTR tv72[rsp], rax
  00043	eb 09		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00045	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv72[rsp], 0
$LN4@operator:

; 2403 :     }

  0004e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00052	c3		 ret	 0
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 275  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 276  : }

  0000a	c3		 ret	 0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {

  00013	eb 0e		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR _First$[rsp]
  0001a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0001e	48 89 44 24 30	 mov	 QWORD PTR _First$[rsp], rax
$LN4@Destroy_ra:
  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR _Last$[rsp]
  00028	48 39 44 24 30	 cmp	 QWORD PTR _First$[rsp], rax
  0002d	74 19		 je	 SHORT $LN3@Destroy_ra

; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _First$[rsp]
  00034	e8 00 00 00 00	 call	 ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00039	48 8b d0	 mov	 rdx, rax
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Al$[rsp]
  00041	e8 00 00 00 00	 call	 ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 961  :         }

  00046	eb cd		 jmp	 SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 962  :     }
; 963  : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	48 81 7c 24 38
	00 10 00 00	 cmp	 QWORD PTR _Bytes$[rsp], 4096 ; 00001000H
  00017	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00019	48 8d 54 24 38	 lea	 rdx, QWORD PTR _Bytes$[rsp]
  0001e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Ptr$[rsp]
  00023	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00028	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Bytes$[rsp]
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00032	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00037	90		 npad	 1

; 222  : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00009	48 81 7c 24 30
	00 10 00 00	 cmp	 QWORD PTR _Bytes$[rsp], 4096 ; 00001000H
  00012	72 0c		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Bytes$[rsp]
  00019	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0001e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00020	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Bytes$[rsp], 0
  00026	74 0c		 je	 SHORT $LN3@Allocate

; 206  :         return _Traits::_Allocate(_Bytes);

  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Bytes$[rsp]
  0002d	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  00032	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00034	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 04 24 00	 mov	 BYTE PTR _Overflow_is_possible$[rsp], 0

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0000d	48 8b 44 24 20	 mov	 rax, QWORD PTR _Count$[rsp]

; 66   : }

  00012	48 83 c4 18	 add	 rsp, 24
  00016	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 42   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 43   :     // return larger of _Left and _Right
; 44   :     return _Left < _Right ? _Right : _Left;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  00018	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001e	73 0b		 jae	 SHORT $LN3@max
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00025	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00029	eb 09		 jmp	 SHORT $LN4@max
$LN3@max:
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00030	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
$LN4@max:
  00034	48 8b 04 24	 mov	 rax, QWORD PTR tv65[rsp]
  00038	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp], rax
  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR $T1[rsp]

; 45   : }

  00042	48 83 c4 18	 add	 rsp, 24
  00046	c3		 ret	 0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT

; 1341 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Val1$[rsp]
  00017	e8 00 00 00 00	 call	 ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Obj$[rsp]
  00013	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00018	48 8b d0	 mov	 rdx, rax
  0001b	b9 08 00 00 00	 mov	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00025	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0002a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0002f	e8 00 00 00 00	 call	 ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_size$ = 64
_New_capacity$ = 72
_Old_capacity$ = 80
_Old_ptr$1 = 88
_Al$ = 96
_Raw_new$ = 104
_New_ptr$ = 112
__$ArrayPad$ = 120
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>, COMDAT

; 4244 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4245 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4246 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4247 :         auto& _My_data            = _Mypair._Myval2;

  0002a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 89 44 24 30	 mov	 QWORD PTR _My_data$[rsp], rax

; 4248 :         const size_type _Old_size = _My_data._Mysize;

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00040	48 89 44 24 38	 mov	 QWORD PTR _Old_size$[rsp], rax

; 4249 :         if (max_size() - _Old_size < _Size_increase) {

  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0004d	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00052	48 2b 44 24 38	 sub	 rax, QWORD PTR _Old_size$[rsp]
  00057	48 3b 84 24 98
	00 00 00	 cmp	 rax, QWORD PTR _Size_increase$[rsp]
  0005f	73 05		 jae	 SHORT $LN2@Reallocate

; 4250 :             _Xlen_string(); // result too long

  00061	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4251 :         }
; 4252 : 
; 4253 :         const size_type _New_size     = _Old_size + _Size_increase;

  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR _Size_increase$[rsp]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 40	 mov	 QWORD PTR _New_size$[rsp], rax

; 4254 :         const size_type _Old_capacity = _My_data._Myres;

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00083	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00087	48 89 44 24 50	 mov	 QWORD PTR _Old_capacity$[rsp], rax

; 4255 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  0008c	48 8b 54 24 40	 mov	 rdx, QWORD PTR _New_size$[rsp]
  00091	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00099	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0009e	48 89 44 24 48	 mov	 QWORD PTR _New_capacity$[rsp], rax

; 4256 :         auto& _Al                     = _Getal();

  000a3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000ab	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000b0	48 89 44 24 60	 mov	 QWORD PTR _Al$[rsp], rax

; 4257 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000b5	48 8b 44 24 48	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  000ba	48 83 c0 01	 add	 rax, 1
  000be	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000c5	48 0f 42 c1	 cmovb	 rax, rcx
  000c9	48 8b d0	 mov	 rdx, rax
  000cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Al$[rsp]
  000d1	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  000d6	48 89 44 24 70	 mov	 QWORD PTR _New_ptr$[rsp], rax

; 4258 :         _My_data._Orphan_all();

  000db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _My_data$[rsp]
  000e0	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4259 :         _My_data._Mysize      = _New_size;

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  000ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _New_size$[rsp]
  000ef	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 4260 :         _My_data._Myres       = _New_capacity;

  000f3	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  000f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_capacity$[rsp]
  000fd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4261 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00101	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00106	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0010b	48 89 44 24 68	 mov	 QWORD PTR _Raw_new$[rsp], rax

; 4262 :         if (_BUF_SIZE <= _Old_capacity) {

  00110	48 83 7c 24 50
	10		 cmp	 QWORD PTR _Old_capacity$[rsp], 16
  00116	72 74		 jb	 SHORT $LN3@Reallocate

; 4263 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00118	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  0011d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00120	48 89 44 24 58	 mov	 QWORD PTR _Old_ptr$1[rsp], rax

; 4264 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  00125	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Old_ptr$1[rsp]
  0012a	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0012f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR <_Args_1>$[rsp]
  00137	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  00144	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00149	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _Old_size$[rsp]
  0014e	4c 8b c0	 mov	 r8, rax
  00151	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Raw_new$[rsp]
  00156	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR _Fn$[rsp]
  0015e	e8 00 00 00 00	 call	 ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 4265 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00163	48 8b 44 24 50	 mov	 rax, QWORD PTR _Old_capacity$[rsp]
  00168	48 ff c0	 inc	 rax
  0016b	4c 8b c0	 mov	 r8, rax
  0016e	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Old_ptr$1[rsp]
  00173	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Al$[rsp]
  00178	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4266 :             _My_data._Bx._Ptr = _New_ptr;

  0017d	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00182	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00187	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4267 :         } else {

  0018a	eb 4b		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4268 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  0018c	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00191	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR <_Args_1>$[rsp]
  00199	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  001a6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001ab	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _Old_size$[rsp]
  001b0	4c 8b c0	 mov	 r8, rax
  001b3	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Raw_new$[rsp]
  001b8	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR _Fn$[rsp]
  001c0	e8 00 00 00 00	 call	 ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 4269 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001c5	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  001ca	48 8d 54 24 70	 lea	 rdx, QWORD PTR _New_ptr$[rsp]
  001cf	48 8b c8	 mov	 rcx, rax
  001d2	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4270 :         }
; 4271 : 
; 4272 :         return *this;

  001d7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 4273 :     }

  001df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e4	48 33 cc	 xor	 rcx, rsp
  001e7	e8 00 00 00 00	 call	 __security_check_cookie
  001ec	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001f3	c3		 ret	 0
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ptr$ = 96
_Count$ = 104
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 2871 :                 const size_type _Count) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2872 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00018	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Old_size$[rsp]
  0001d	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Old_ptr$[rsp]
  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00027	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 2873 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  0002c	48 8b 44 24 58	 mov	 rax, QWORD PTR _Old_size$[rsp]
  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	4c 8b 44 24 68	 mov	 r8, QWORD PTR _Count$[rsp]
  00041	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00046	48 8b c8	 mov	 rcx, rax
  00049	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0004e	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00053	48 8b 44 24 68	 mov	 rax, QWORD PTR _Count$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  0005d	48 03 c8	 add	 rcx, rax
  00060	48 8b c1	 mov	 rax, rcx
  00063	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00073	48 8b c8	 mov	 rcx, rax
  00076	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2875 :             },

  0007b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007f	c3		 ret	 0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
_TEXT	SEGMENT
_New_capacity$ = 32
_Old_capacity$ = 40
_Al$ = 48
_New_ptr$ = 56
__$ArrayPad$ = 64
this$ = 96
_New_size$ = 104
_Fn$ = 112
<_Args_0>$ = 120
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>, COMDAT

; 4218 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4219 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4220 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4221 :         if (_New_size > max_size()) {

  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00031	48 39 44 24 68	 cmp	 QWORD PTR _New_size$[rsp], rax
  00036	76 05		 jbe	 SHORT $LN2@Reallocate

; 4222 :             _Xlen_string(); // result too long

  00038	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4223 :         }
; 4224 : 
; 4225 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0003d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00042	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00046	48 89 44 24 28	 mov	 QWORD PTR _Old_capacity$[rsp], rax

; 4226 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  0004b	48 8b 54 24 68	 mov	 rdx, QWORD PTR _New_size$[rsp]
  00050	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00055	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0005a	48 89 44 24 20	 mov	 QWORD PTR _New_capacity$[rsp], rax

; 4227 :         auto& _Al                     = _Getal();

  0005f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00064	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00069	48 89 44 24 30	 mov	 QWORD PTR _Al$[rsp], rax

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  00073	48 83 c0 01	 add	 rax, 1
  00077	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0007e	48 0f 42 c1	 cmovb	 rax, rcx
  00082	48 8b d0	 mov	 rdx, rax
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Al$[rsp]
  0008a	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  0008f	48 89 44 24 38	 mov	 QWORD PTR _New_ptr$[rsp], rax

; 4229 :         _Mypair._Myval2._Orphan_all();

  00094	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  000a1	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _New_size$[rsp]
  000ab	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  000af	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _New_capacity$[rsp]
  000b9	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4232 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  000bd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  000c2	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  000c7	4c 8b 4c 24 78	 mov	 r9, QWORD PTR <_Args_0>$[rsp]
  000cc	4c 8b 44 24 68	 mov	 r8, QWORD PTR _New_size$[rsp]
  000d1	48 8b d0	 mov	 rdx, rax
  000d4	48 8d 4c 24 70	 lea	 rcx, QWORD PTR _Fn$[rsp]
  000d9	e8 00 00 00 00	 call	 ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  000de	48 83 7c 24 28
	10		 cmp	 QWORD PTR _Old_capacity$[rsp], 16
  000e4	72 2c		 jb	 SHORT $LN3@Reallocate

; 4234 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000e6	48 8b 44 24 28	 mov	 rax, QWORD PTR _Old_capacity$[rsp]
  000eb	48 ff c0	 inc	 rax
  000ee	4c 8b c0	 mov	 r8, rax
  000f1	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000f6	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000f9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Al$[rsp]
  000fe	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4235 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00108	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  0010d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4236 :         } else {

  00110	eb 12		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00117	48 8d 54 24 38	 lea	 rdx, QWORD PTR _New_ptr$[rsp]
  0011c	48 8b c8	 mov	 rcx, rax
  0011f	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4238 :         }
; 4239 : 
; 4240 :         return *this;

  00124	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 4241 :     }

  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012e	48 33 cc	 xor	 rcx, rsp
  00131	e8 00 00 00 00	 call	 __security_check_cookie
  00136	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013a	c3		 ret	 0
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Count$ = 80
_Ptr$ = 88
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z PROC ; <lambda_66f57f934f28d61049862f64df852ff0>::operator(), COMDAT

; 2976 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2977 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  00018	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Count$[rsp]
  0001d	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00027	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0002c	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count$[rsp]
  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  0003b	48 03 c8	 add	 rcx, rax
  0003e	48 8b c1	 mov	 rax, rcx
  00041	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00046	48 8b c8	 mov	 rcx, rax
  00049	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2979 :             },

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z ENDP ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_size$ = 64
_New_capacity$ = 72
_Old_capacity$ = 80
_Old_ptr$1 = 88
_Al$ = 96
_Raw_new$ = 104
_New_ptr$ = 112
__$ArrayPad$ = 120
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>, COMDAT

; 4244 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4245 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4246 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4247 :         auto& _My_data            = _Mypair._Myval2;

  0002a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 89 44 24 30	 mov	 QWORD PTR _My_data$[rsp], rax

; 4248 :         const size_type _Old_size = _My_data._Mysize;

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00040	48 89 44 24 38	 mov	 QWORD PTR _Old_size$[rsp], rax

; 4249 :         if (max_size() - _Old_size < _Size_increase) {

  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0004d	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00052	48 2b 44 24 38	 sub	 rax, QWORD PTR _Old_size$[rsp]
  00057	48 3b 84 24 98
	00 00 00	 cmp	 rax, QWORD PTR _Size_increase$[rsp]
  0005f	73 05		 jae	 SHORT $LN2@Reallocate

; 4250 :             _Xlen_string(); // result too long

  00061	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4251 :         }
; 4252 : 
; 4253 :         const size_type _New_size     = _Old_size + _Size_increase;

  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR _Size_increase$[rsp]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 40	 mov	 QWORD PTR _New_size$[rsp], rax

; 4254 :         const size_type _Old_capacity = _My_data._Myres;

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00083	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00087	48 89 44 24 50	 mov	 QWORD PTR _Old_capacity$[rsp], rax

; 4255 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  0008c	48 8b 54 24 40	 mov	 rdx, QWORD PTR _New_size$[rsp]
  00091	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00099	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0009e	48 89 44 24 48	 mov	 QWORD PTR _New_capacity$[rsp], rax

; 4256 :         auto& _Al                     = _Getal();

  000a3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000ab	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000b0	48 89 44 24 60	 mov	 QWORD PTR _Al$[rsp], rax

; 4257 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000b5	48 8b 44 24 48	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  000ba	48 83 c0 01	 add	 rax, 1
  000be	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000c5	48 0f 42 c1	 cmovb	 rax, rcx
  000c9	48 8b d0	 mov	 rdx, rax
  000cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Al$[rsp]
  000d1	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  000d6	48 89 44 24 70	 mov	 QWORD PTR _New_ptr$[rsp], rax

; 4258 :         _My_data._Orphan_all();

  000db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _My_data$[rsp]
  000e0	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4259 :         _My_data._Mysize      = _New_size;

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  000ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _New_size$[rsp]
  000ef	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 4260 :         _My_data._Myres       = _New_capacity;

  000f3	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  000f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_capacity$[rsp]
  000fd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4261 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00101	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00106	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0010b	48 89 44 24 68	 mov	 QWORD PTR _Raw_new$[rsp], rax

; 4262 :         if (_BUF_SIZE <= _Old_capacity) {

  00110	48 83 7c 24 50
	10		 cmp	 QWORD PTR _Old_capacity$[rsp], 16
  00116	72 66		 jb	 SHORT $LN3@Reallocate

; 4263 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00118	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  0011d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00120	48 89 44 24 58	 mov	 QWORD PTR _Old_ptr$1[rsp], rax

; 4264 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  00125	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Old_ptr$1[rsp]
  0012a	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0012f	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR <_Args_0>$[rsp]
  00137	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0013b	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _Old_size$[rsp]
  00140	4c 8b c0	 mov	 r8, rax
  00143	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Raw_new$[rsp]
  00148	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR _Fn$[rsp]
  00150	e8 00 00 00 00	 call	 ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()

; 4265 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00155	48 8b 44 24 50	 mov	 rax, QWORD PTR _Old_capacity$[rsp]
  0015a	48 ff c0	 inc	 rax
  0015d	4c 8b c0	 mov	 r8, rax
  00160	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Old_ptr$1[rsp]
  00165	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Al$[rsp]
  0016a	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4266 :             _My_data._Bx._Ptr = _New_ptr;

  0016f	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00174	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00179	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4267 :         } else {

  0017c	eb 3d		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4268 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00183	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR <_Args_0>$[rsp]
  0018b	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0018f	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _Old_size$[rsp]
  00194	4c 8b c0	 mov	 r8, rax
  00197	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Raw_new$[rsp]
  0019c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR _Fn$[rsp]
  001a4	e8 00 00 00 00	 call	 ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()

; 4269 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001a9	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  001ae	48 8d 54 24 70	 lea	 rdx, QWORD PTR _New_ptr$[rsp]
  001b3	48 8b c8	 mov	 rcx, rax
  001b6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4270 :         }
; 4271 : 
; 4272 :         return *this;

  001bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 4273 :     }

  001c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c8	48 33 cc	 xor	 rcx, rsp
  001cb	e8 00 00 00 00	 call	 __security_check_cookie
  001d0	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001d7	c3		 ret	 0
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ch$ = 96
??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z PROC ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator(), COMDAT

; 3619 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3620 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00018	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Old_size$[rsp]
  0001d	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Old_ptr$[rsp]
  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00027	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 3621 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0002c	48 8b 44 24 58	 mov	 rax, QWORD PTR _Old_size$[rsp]
  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	48 8d 54 24 60	 lea	 rdx, QWORD PTR _Ch$[rsp]
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3622 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00049	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR _New_ptr$[rsp]
  00053	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  00058	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  0005d	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00062	48 8b c8	 mov	 rcx, rax
  00065	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3623 :             },

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBAXQEADQEBD_KD@Z ENDP ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 267  : void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 268  :     _Obj.~_Ty();
; 269  : }

  00005	c3		 ret	 0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$_Pocma@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@0@Z PROC ; std::_Pocma<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 901  : void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 902  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 903  :         _Left = _STD move(_Right);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Right$[rsp]
  00013	e8 00 00 00 00	 call	 ??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>

; 904  :     }
; 905  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
??$_Pocma@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@0@Z ENDP ; std::_Pocma<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z PROC ; std::_Destroy_range<std::allocator<_SYMBOL> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {

  00013	eb 0e		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR _First$[rsp]
  0001a	48 83 c0 48	 add	 rax, 72			; 00000048H
  0001e	48 89 44 24 30	 mov	 QWORD PTR _First$[rsp], rax
$LN4@Destroy_ra:
  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR _Last$[rsp]
  00028	48 39 44 24 30	 cmp	 QWORD PTR _First$[rsp], rax
  0002d	74 19		 je	 SHORT $LN3@Destroy_ra

; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _First$[rsp]
  00034	e8 00 00 00 00	 call	 ??$_Unfancy@U_SYMBOL@@@std@@YAPEAU_SYMBOL@@PEAU1@@Z ; std::_Unfancy<_SYMBOL>
  00039	48 8b d0	 mov	 rdx, rax
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Al$[rsp]
  00041	e8 00 00 00 00	 call	 ??$destroy@U_SYMBOL@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::destroy<_SYMBOL>

; 961  :         }

  00046	eb cd		 jmp	 SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 962  :     }
; 963  : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAXPEAPEAU_SYMBOL@@QEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAXPEAPEAU_SYMBOL@@QEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z PROC ; std::_Destroy_range<std::allocator<_SYMBOL *> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAXPEAPEAU_SYMBOL@@QEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<_SYMBOL *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 275  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 276  : }

  0000a	c3		 ret	 0
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z PROC ; std::addressof<std::codecvt<char,char,_Mbstatet> const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 275  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 276  : }

  0000a	c3		 ret	 0
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ENDP ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 275  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 276  : }

  0000a	c3		 ret	 0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1341 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Val1$[rsp]
  00017	e8 00 00 00 00	 call	 ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1468 : }

  0000a	c3		 ret	 0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@$$CBD@std@@YAPEBDPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@$$CBD@std@@YAPEBDPEBD@Z PROC		; std::_Unfancy<char const >, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 289  :     return _Ptr;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 290  : }

  0000a	c3		 ret	 0
??$_Unfancy@$$CBD@std@@YAPEBDPEBD@Z ENDP		; std::_Unfancy<char const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 275  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 276  : }

  0000a	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z PROC		; std::_Refancy<char *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 262  :     return _Ptr;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 263  : }

  0000a	c3		 ret	 0
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_Possible_matches_end$ = 40
_Haystack$ = 64
_Hay_size$ = 72
_Start_at$ = 80
_Needle$ = 88
_Needle_size$ = 96
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 531  :     const size_t _Needle_size) noexcept {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 532  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 533  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR _Hay_size$[rsp]
  0001d	48 39 44 24 60	 cmp	 QWORD PTR _Needle_size$[rsp], rax
  00022	77 17		 ja	 SHORT $LN6@Traits_fin
  00024	48 8b 44 24 60	 mov	 rax, QWORD PTR _Needle_size$[rsp]
  00029	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Hay_size$[rsp]
  0002e	48 2b c8	 sub	 rcx, rax
  00031	48 8b c1	 mov	 rax, rcx
  00034	48 39 44 24 50	 cmp	 QWORD PTR _Start_at$[rsp], rax
  00039	76 0c		 jbe	 SHORT $LN5@Traits_fin
$LN6@Traits_fin:

; 534  :         // xpos cannot exist, report failure
; 535  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 536  :         // 1. _Start_at <= xpos
; 537  :         // 2. xpos + _Needle_size <= _Hay_size;
; 538  :         // therefore:
; 539  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 540  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 541  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 542  :         return static_cast<size_t>(-1);

  0003b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00042	e9 b9 00 00 00	 jmp	 $LN1@Traits_fin
$LN5@Traits_fin:

; 543  :     }
; 544  : 
; 545  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00047	48 83 7c 24 60
	00		 cmp	 QWORD PTR _Needle_size$[rsp], 0
  0004d	75 0a		 jne	 SHORT $LN7@Traits_fin

; 546  :         return _Start_at;

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR _Start_at$[rsp]
  00054	e9 a7 00 00 00	 jmp	 $LN1@Traits_fin
$LN7@Traits_fin:

; 547  :     }
; 548  : 
; 549  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00059	48 8b 44 24 60	 mov	 rax, QWORD PTR _Needle_size$[rsp]
  0005e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Hay_size$[rsp]
  00063	48 2b c8	 sub	 rcx, rax
  00066	48 8b c1	 mov	 rax, rcx
  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Haystack$[rsp]
  0006e	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  00073	48 89 44 24 28	 mov	 QWORD PTR _Possible_matches_end$[rsp], rax

; 550  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR _Start_at$[rsp]
  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Haystack$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 20	 mov	 QWORD PTR _Match_try$1[rsp], rax
  0008d	eb 0d		 jmp	 SHORT $LN4@Traits_fin
$LN2@Traits_fin:
  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR _Match_try$1[rsp]
  00094	48 ff c0	 inc	 rax
  00097	48 89 44 24 20	 mov	 QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_fin:

; 551  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR _Match_try$1[rsp]
  000a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Possible_matches_end$[rsp]
  000a6	48 2b c8	 sub	 rcx, rax
  000a9	48 8b c1	 mov	 rax, rcx
  000ac	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Needle$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Match_try$1[rsp]
  000b9	e8 00 00 00 00	 call	 ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
  000be	48 89 44 24 20	 mov	 QWORD PTR _Match_try$1[rsp], rax

; 552  :         if (!_Match_try) { // didn't find first character; report failure

  000c3	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Match_try$1[rsp], 0
  000c9	75 09		 jne	 SHORT $LN8@Traits_fin

; 553  :             return static_cast<size_t>(-1);

  000cb	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000d2	eb 2c		 jmp	 SHORT $LN1@Traits_fin
$LN8@Traits_fin:

; 554  :         }
; 555  : 
; 556  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  000d4	4c 8b 44 24 60	 mov	 r8, QWORD PTR _Needle_size$[rsp]
  000d9	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Needle$[rsp]
  000de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Match_try$1[rsp]
  000e3	e8 00 00 00 00	 call	 ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
  000e8	85 c0		 test	 eax, eax
  000ea	75 12		 jne	 SHORT $LN9@Traits_fin

; 557  :             return static_cast<size_t>(_Match_try - _Haystack);

  000ec	48 8b 44 24 40	 mov	 rax, QWORD PTR _Haystack$[rsp]
  000f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Match_try$1[rsp]
  000f6	48 2b c8	 sub	 rcx, rax
  000f9	48 8b c1	 mov	 rax, rcx
  000fc	eb 02		 jmp	 SHORT $LN1@Traits_fin
$LN9@Traits_fin:

; 558  :         }
; 559  :     }

  000fe	eb 8f		 jmp	 SHORT $LN2@Traits_fin
$LN1@Traits_fin:

; 560  : }

  00100	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00104	c3		 ret	 0
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1468 : }

  0000a	c3		 ret	 0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 125  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 126  :             return _Ok;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]

; 127  :         }

  0000e	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
_Zero_uncaught_exceptions$ = 33
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 110  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 111  : #if !_HAS_EXCEPTIONS
; 112  :             const bool _Zero_uncaught_exceptions = true;
; 113  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 114  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00009	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0000e	0f b6 c0	 movzx	 eax, al
  00011	85 c0		 test	 eax, eax
  00013	75 07		 jne	 SHORT $LN4@sentry
  00015	c6 44 24 20 01	 mov	 BYTE PTR tv72[rsp], 1
  0001a	eb 05		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  0001c	c6 44 24 20 00	 mov	 BYTE PTR tv72[rsp], 0
$LN5@sentry:
  00021	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv72[rsp]
  00026	88 44 24 21	 mov	 BYTE PTR _Zero_uncaught_exceptions$[rsp], al

; 115  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 116  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 117  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 118  : 
; 119  :             if (_Zero_uncaught_exceptions) {

  0002a	0f b6 44 24 21	 movzx	 eax, BYTE PTR _Zero_uncaught_exceptions$[rsp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@sentry

; 120  :                 this->_Myostr._Osfx();

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
$LN2@sentry:

; 121  :             }
; 122  :         }

  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00046	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0004b	90		 npad	 1
  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ostr$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  0001d	90		 npad	 1

; 93   :             if (!_Ostr.good()) {

  0001e	48 8b 44 24 48	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0002a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0002f	48 03 c8	 add	 rcx, rax
  00032	48 8b c1	 mov	 rax, rcx
  00035	48 8b c8	 mov	 rcx, rax
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
  0003e	0f b6 c0	 movzx	 eax, al
  00041	85 c0		 test	 eax, eax
  00043	75 0b		 jne	 SHORT $LN2@sentry

; 94   :                 _Ok = false;

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004a	c6 40 08 00	 mov	 BYTE PTR [rax+8], 0

; 95   :                 return;

  0004e	eb 77		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 96   :             }
; 97   : 
; 98   :             const auto _Tied = _Ostr.tie();

  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00061	48 03 c8	 add	 rcx, rax
  00064	48 8b c1	 mov	 rax, rcx
  00067	48 8b c8	 mov	 rcx, rax
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00070	48 89 44 24 20	 mov	 QWORD PTR _Tied$[rsp], rax

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  00075	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Tied$[rsp], 0
  0007b	74 0c		 je	 SHORT $LN4@sentry
  0007d	48 8b 44 24 48	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00082	48 39 44 24 20	 cmp	 QWORD PTR _Tied$[rsp], rax
  00087	75 0b		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008e	c6 40 08 01	 mov	 BYTE PTR [rax+8], 1

; 101  :                 return;

  00092	eb 33		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

  00094	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Tied$[rsp]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR _Ostr$[rsp]
  000a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000ab	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  000b0	48 03 c8	 add	 rcx, rax
  000b3	48 8b c1	 mov	 rax, rcx
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
  000bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000c4	88 41 08	 mov	 BYTE PTR [rcx+8], al
$LN1@sentry:

; 107  :         }

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000cc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d0	c3		 ret	 0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 32
tv72 = 40
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR tv72[rsp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00022	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv72[rsp]
  00027	48 03 c8	 add	 rcx, rax
  0002a	48 8b c1	 mov	 rax, rcx
  0002d	48 8b c8	 mov	 rcx, rax
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00036	48 89 44 24 20	 mov	 QWORD PTR _Rdbuf$[rsp], rax

; 80   :             if (_Rdbuf) {

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Rdbuf$[rsp], 0
  00041	74 11		 je	 SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR _Rdbuf$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Rdbuf$[rsp]
  00050	ff 50 10	 call	 QWORD PTR [rax+16]
  00053	90		 npad	 1
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 32
tv73 = 40
this$ = 64
_Ostr$ = 72
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00018	48 89 08	 mov	 QWORD PTR [rax], rcx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00020	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00023	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  00028	48 8b 44 24 28	 mov	 rax, QWORD PTR tv73[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00034	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv73[rsp]
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 8b c1	 mov	 rax, rcx
  0003f	48 8b c8	 mov	 rcx, rax
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00048	48 89 44 24 20	 mov	 QWORD PTR _Rdbuf$[rsp], rax

; 73   :             if (_Rdbuf) {

  0004d	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Rdbuf$[rsp], 0
  00053	74 10		 je	 SHORT $LN2@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR _Rdbuf$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Rdbuf$[rsp]
  00062	ff 50 08	 call	 QWORD PTR [rax+8]
$LN2@Sentry_bas:

; 75   :             }
; 76   :         }

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>, COMDAT

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1341 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Val1$[rsp]
  00017	e8 00 00 00 00	 call	 ??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z PROC ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1468 : }

  0000a	c3		 ret	 0
??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AEAV10@@Z PROC ; std::addressof<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 275  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 276  : }

  0000a	c3		 ret	 0
??$addressof@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AEAV10@@Z ENDP ; std::addressof<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv134 = 120
tv132 = 128
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  00016	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0001e	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00023	48 89 44 24 48	 mov	 QWORD PTR _Al$[rsp], rax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  00028	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 89 44 24 58	 mov	 QWORD PTR _My_data$[rsp], rax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00035	48 8b 44 24 58	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003a	48 89 44 24 30	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR _My_data$[rsp]
  00044	48 83 c0 08	 add	 rax, 8
  00048	48 89 44 24 38	 mov	 QWORD PTR _Mylast$[rsp], rax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _Whereptr$[rsp]
  0005d	48 2b c8	 sub	 rcx, rax
  00060	48 8b c1	 mov	 rax, rcx
  00063	48 c1 f8 05	 sar	 rax, 5
  00067	48 89 44 24 28	 mov	 QWORD PTR _Whereoff$[rsp], rax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0006c	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00071	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00076	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00079	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007c	48 2b c1	 sub	 rax, rcx
  0007f	48 c1 f8 05	 sar	 rax, 5
  00083	48 89 44 24 60	 mov	 QWORD PTR _Oldsize$[rsp], rax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00088	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00090	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  00095	48 39 44 24 60	 cmp	 QWORD PTR _Oldsize$[rsp], rax
  0009a	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  0009c	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000a1	48 8b 44 24 60	 mov	 rax, QWORD PTR _Oldsize$[rsp]
  000a6	48 ff c0	 inc	 rax
  000a9	48 89 44 24 70	 mov	 QWORD PTR _Newsize$[rsp], rax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000ae	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Newsize$[rsp]
  000b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000bb	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
  000c0	48 89 44 24 50	 mov	 QWORD PTR _Newcapacity$[rsp], rax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000c5	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Newcapacity$[rsp]
  000ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Al$[rsp]
  000cf	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
  000d4	48 89 44 24 20	 mov	 QWORD PTR _Newvec$[rsp], rax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000d9	48 6b 44 24 28
	20		 imul	 rax, QWORD PTR _Whereoff$[rsp], 32 ; 00000020H
  000df	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  000e4	48 8d 44 01 20	 lea	 rax, QWORD PTR [rcx+rax+32]
  000e9	48 89 44 24 68	 mov	 QWORD PTR _Constructed_last$[rsp], rax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR _Constructed_last$[rsp]
  000f3	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 747  : 
; 748  :         _TRY_BEGIN
; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000f8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  00100	e8 00 00 00 00	 call	 ??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00105	48 89 44 24 78	 mov	 QWORD PTR tv134[rsp], rax
  0010a	48 6b 44 24 28
	20		 imul	 rax, QWORD PTR _Whereoff$[rsp], 32 ; 00000020H
  00110	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  00115	48 03 c8	 add	 rcx, rax
  00118	48 8b c1	 mov	 rax, rcx
  0011b	48 8b c8	 mov	 rcx, rax
  0011e	e8 00 00 00 00	 call	 ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00123	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  0012b	4c 8b 44 24 78	 mov	 r8, QWORD PTR tv134[rsp]
  00130	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv132[rsp]
  00138	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Al$[rsp]
  0013d	e8 00 00 00 00	 call	 ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00142	48 6b 44 24 28
	20		 imul	 rax, QWORD PTR _Whereoff$[rsp], 32 ; 00000020H
  00148	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  0014d	48 03 c8	 add	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0015d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00160	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR _Whereptr$[rsp], rax
  00168	75 24		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0016a	4c 8b 4c 24 20	 mov	 r9, QWORD PTR _Newvec$[rsp]
  0016f	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00174	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00177	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0017c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0017f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00187	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  0018c	eb 5d		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0018e	4c 8b 4c 24 20	 mov	 r9, QWORD PTR _Newvec$[rsp]
  00193	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR _Whereptr$[rsp]
  0019b	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  001a0	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001a3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001ab	e8 00 00 00 00	 call	 ?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove

; 756  :             _Constructed_first = _Newvec;

  001b0	48 8b 44 24 20	 mov	 rax, QWORD PTR _Newvec$[rsp]
  001b5	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001ba	48 6b 44 24 28
	20		 imul	 rax, QWORD PTR _Whereoff$[rsp], 32 ; 00000020H
  001c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  001c5	48 8d 44 01 20	 lea	 rax, QWORD PTR [rcx+rax+32]
  001ca	4c 8b c8	 mov	 r9, rax
  001cd	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  001d2	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  001d5	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR _Whereptr$[rsp]
  001dd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001e5	e8 00 00 00 00	 call	 ?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove
  001ea	90		 npad	 1
$LN5@Emplace_re:
  001eb	eb 00		 jmp	 SHORT $LN9@Emplace_re
$LN10@Emplace_re:
$LN9@Emplace_re:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001ed	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Newcapacity$[rsp]
  001f2	4c 8b 44 24 70	 mov	 r8, QWORD PTR _Newsize$[rsp]
  001f7	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Newvec$[rsp]
  001fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00204	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00209	48 6b 44 24 28
	20		 imul	 rax, QWORD PTR _Whereoff$[rsp], 32 ; 00000020H
  0020f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  00214	48 03 c8	 add	 rcx, rax
  00217	48 8b c1	 mov	 rax, rcx

; 767  :     }

  0021a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00221	c3		 ret	 0
$LN11@Emplace_re:
??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv134 = 120
tv132 = 128
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA PROC ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::catch$0

; 758  :         }
; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 45 68	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00011	48 8b 55 40	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00015	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00021	4c 8b 45 50	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00025	48 8b 55 20	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00029	48 8b 4d 48	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;

  00032	33 d2		 xor	 edx, edx
  00034	33 c9		 xor	 ecx, ecx
  00036	e8 00 00 00 00	 call	 _CxxThrowException
  0003b	90		 npad	 1

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, $LN10@catch$0
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
  00049	cc		 int	 3
?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA ENDP ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv134 = 120
tv132 = 128
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA PROC ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::catch$0

; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z$0:

; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 45 68	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00011	48 8b 55 40	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00015	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00021	4c 8b 45 50	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00025	48 8b 55 20	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00029	48 8b 4d 48	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 762  :         _RERAISE;

  00032	33 d2		 xor	 edx, edx
  00034	33 c9		 xor	 ecx, ecx
  00036	e8 00 00 00 00	 call	 _CxxThrowException
  0003b	90		 npad	 1

; 763  :         _CATCH_END

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, $LN10@catch$0
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
  00049	cc		 int	 3
?catch$0@?0???$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z@4HA ENDP ; `std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00018	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0001d	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00022	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0002c	e8 00 00 00 00	 call	 ??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00031	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
  00036	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv76[rsp]
  0003b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00040	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 695  :     }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	c3		 ret	 0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z PROC ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 289  :     return _Ptr;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 290  : }

  0000a	c3		 ret	 0
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv81 = 48
tv79 = 56
tv77 = 64
_Result$ = 72
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 89 44 24 20	 mov	 QWORD PTR _Mylast$[rsp], rax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00026	48 8b 4c 24 68	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  0002b	e8 00 00 00 00	 call	 ??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00030	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	e8 00 00 00 00	 call	 ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00042	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
  00047	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00051	48 89 44 24 40	 mov	 QWORD PTR tv77[rsp], rax
  00056	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv81[rsp]
  0005b	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv79[rsp]
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv77[rsp]
  00065	e8 00 00 00 00	 call	 ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>

; 688  :         _Orphan_range(_Mylast, _Mylast);

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0006f	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00077	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0007f	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 89 44 24 48	 mov	 QWORD PTR _Result$[rsp], rax

; 690  :         ++_Mylast;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00096	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00099	48 83 c0 20	 add	 rax, 32			; 00000020H
  0009d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Mylast$[rsp]
  000a2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;

  000a5	48 8b 44 24 48	 mov	 rax, QWORD PTR _Result$[rsp]

; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  000aa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ae	c3		 ret	 0
??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
_Result$ = 64
this$ = 96
<_Val_0>$ = 104
??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR _My_data$[rsp], rax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 89 44 24 28	 mov	 QWORD PTR _Mylast$[rsp], rax

; 704  :         if (_Mylast != _My_data._Myend) {

  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00030	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00034	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00037	74 19		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00039	48 8b 4c 24 68	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  0003e	e8 00 00 00 00	 call	 ??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00043	48 8b d0	 mov	 rdx, rax
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0004b	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00050	eb 3a		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  00057	e8 00 00 00 00	 call	 ??$forward@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  0005c	48 89 44 24 30	 mov	 QWORD PTR tv83[rsp], rax
  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 89 44 24 38	 mov	 QWORD PTR tv81[rsp], rax
  0006e	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv83[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv81[rsp]
  00078	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0007d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00082	48 89 44 24 40	 mov	 QWORD PTR _Result$[rsp], rax

; 709  : #if _HAS_CXX17
; 710  :         return _Result;

  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR _Result$[rsp]
$LN1@emplace_ba:

; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0008c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00090	c3		 ret	 0
??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1><>, COMDAT

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??0?$allocator@U_SYMBOL@@@std@@QEAA@XZ ; std::allocator<_SYMBOL>::allocator<_SYMBOL>
  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<_SYMBOL> >::_Vector_val<std::_Simple_types<_SYMBOL> >
  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1><>, COMDAT

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??0?$allocator@PEAU_SYMBOL@@@std@@QEAA@XZ ; std::allocator<_SYMBOL *>::allocator<_SYMBOL *>
  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<_SYMBOL *> >::_Vector_val<std::_Simple_types<_SYMBOL *> >
  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv134 = 120
tv132 = 128
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_reallocate<_SYMBOL *>, COMDAT

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  00016	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0001e	e8 00 00 00 00	 call	 ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
  00023	48 89 44 24 48	 mov	 QWORD PTR _Al$[rsp], rax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  00028	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 89 44 24 58	 mov	 QWORD PTR _My_data$[rsp], rax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00035	48 8b 44 24 58	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003a	48 89 44 24 30	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR _My_data$[rsp]
  00044	48 83 c0 08	 add	 rax, 8
  00048	48 89 44 24 38	 mov	 QWORD PTR _Mylast$[rsp], rax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _Whereptr$[rsp]
  0005d	48 2b c8	 sub	 rcx, rax
  00060	48 8b c1	 mov	 rax, rcx
  00063	48 c1 f8 03	 sar	 rax, 3
  00067	48 89 44 24 28	 mov	 QWORD PTR _Whereoff$[rsp], rax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0006c	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00071	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00076	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00079	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007c	48 2b c1	 sub	 rax, rcx
  0007f	48 c1 f8 03	 sar	 rax, 3
  00083	48 89 44 24 60	 mov	 QWORD PTR _Oldsize$[rsp], rax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00088	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00090	e8 00 00 00 00	 call	 ?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::max_size
  00095	48 39 44 24 60	 cmp	 QWORD PTR _Oldsize$[rsp], rax
  0009a	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  0009c	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@CAXXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000a1	48 8b 44 24 60	 mov	 rax, QWORD PTR _Oldsize$[rsp]
  000a6	48 ff c0	 inc	 rax
  000a9	48 89 44 24 70	 mov	 QWORD PTR _Newsize$[rsp], rax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000ae	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Newsize$[rsp]
  000b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000bb	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBA_K_K@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Calculate_growth
  000c0	48 89 44 24 50	 mov	 QWORD PTR _Newcapacity$[rsp], rax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000c5	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Newcapacity$[rsp]
  000ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Al$[rsp]
  000cf	e8 00 00 00 00	 call	 ?allocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAPEAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL *>::allocate
  000d4	48 89 44 24 20	 mov	 QWORD PTR _Newvec$[rsp], rax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR _Newvec$[rsp]
  000de	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Whereoff$[rsp]
  000e3	48 8d 44 c8 08	 lea	 rax, QWORD PTR [rax+rcx*8+8]
  000e8	48 89 44 24 68	 mov	 QWORD PTR _Constructed_last$[rsp], rax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000ed	48 8b 44 24 68	 mov	 rax, QWORD PTR _Constructed_last$[rsp]
  000f2	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 747  : 
; 748  :         _TRY_BEGIN
; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000f7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  000ff	e8 00 00 00 00	 call	 ??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ; std::forward<_SYMBOL *>
  00104	48 89 44 24 78	 mov	 QWORD PTR tv134[rsp], rax
  00109	48 8b 44 24 20	 mov	 rax, QWORD PTR _Newvec$[rsp]
  0010e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Whereoff$[rsp]
  00113	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 ??$_Unfancy@PEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@@Z ; std::_Unfancy<_SYMBOL *>
  0011f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  00127	4c 8b 44 24 78	 mov	 r8, QWORD PTR tv134[rsp]
  0012c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv132[rsp]
  00134	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Al$[rsp]
  00139	e8 00 00 00 00	 call	 ??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::construct<_SYMBOL *,_SYMBOL *>

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Newvec$[rsp]
  00143	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Whereoff$[rsp]
  00148	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0014c	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00151	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00156	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00159	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR _Whereptr$[rsp], rax
  00161	75 24		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00163	4c 8b 4c 24 20	 mov	 r9, QWORD PTR _Newvec$[rsp]
  00168	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0016d	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00170	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00175	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00178	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00180	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  00185	eb 5c		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  00187	4c 8b 4c 24 20	 mov	 r9, QWORD PTR _Newvec$[rsp]
  0018c	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR _Whereptr$[rsp]
  00194	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00199	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0019c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001a4	e8 00 00 00 00	 call	 ?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove

; 756  :             _Constructed_first = _Newvec;

  001a9	48 8b 44 24 20	 mov	 rax, QWORD PTR _Newvec$[rsp]
  001ae	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001b3	48 8b 44 24 20	 mov	 rax, QWORD PTR _Newvec$[rsp]
  001b8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Whereoff$[rsp]
  001bd	48 8d 44 c8 08	 lea	 rax, QWORD PTR [rax+rcx*8+8]
  001c2	4c 8b c8	 mov	 r9, rax
  001c5	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  001ca	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  001cd	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR _Whereptr$[rsp]
  001d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001dd	e8 00 00 00 00	 call	 ?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove
  001e2	90		 npad	 1
$LN5@Emplace_re:
  001e3	eb 00		 jmp	 SHORT $LN9@Emplace_re
$LN10@Emplace_re:
$LN9@Emplace_re:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001e5	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Newcapacity$[rsp]
  001ea	4c 8b 44 24 70	 mov	 r8, QWORD PTR _Newsize$[rsp]
  001ef	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Newvec$[rsp]
  001f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001fc	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXQEAPEAU_SYMBOL@@_K1@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00201	48 8b 44 24 20	 mov	 rax, QWORD PTR _Newvec$[rsp]
  00206	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Whereoff$[rsp]
  0020b	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]

; 767  :     }

  0020f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00216	c3		 ret	 0
$LN11@Emplace_re:
??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_reallocate<_SYMBOL *>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv134 = 120
tv132 = 128
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA PROC ; `std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_reallocate<_SYMBOL *>'::`1'::catch$0

; 758  :         }
; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 45 68	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00011	48 8b 55 40	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00015	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Destroy

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00021	4c 8b 45 50	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00025	48 8b 55 20	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00029	48 8b 4d 48	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL *>::deallocate

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;

  00032	33 d2		 xor	 edx, edx
  00034	33 c9		 xor	 ecx, ecx
  00036	e8 00 00 00 00	 call	 _CxxThrowException
  0003b	90		 npad	 1

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, $LN10@catch$0
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
  00049	cc		 int	 3
?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA ENDP ; `std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_reallocate<_SYMBOL *>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv134 = 120
tv132 = 128
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA PROC ; `std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_reallocate<_SYMBOL *>'::`1'::catch$0

; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z$0:

; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 45 68	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00011	48 8b 55 40	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00015	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00021	4c 8b 45 50	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00025	48 8b 55 20	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00029	48 8b 4d 48	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL *>::deallocate

; 762  :         _RERAISE;

  00032	33 d2		 xor	 edx, edx
  00034	33 c9		 xor	 ecx, ecx
  00036	e8 00 00 00 00	 call	 _CxxThrowException
  0003b	90		 npad	 1

; 763  :         _CATCH_END

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, $LN10@catch$0
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
  00049	cc		 int	 3
?catch$0@?0???$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z@4HA ENDP ; `std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_reallocate<_SYMBOL *>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::construct<_SYMBOL *,_SYMBOL *>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00018	b9 08 00 00 00	 mov	 ecx, 8
  0001d	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00022	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0002c	e8 00 00 00 00	 call	 ??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ; std::forward<_SYMBOL *>
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 695  :     }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::construct<_SYMBOL *,_SYMBOL *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@PEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@@Z PROC ; std::_Unfancy<_SYMBOL *>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 289  :     return _Ptr;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 290  : }

  0000a	c3		 ret	 0
??$_Unfancy@PEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@@Z ENDP ; std::_Unfancy<_SYMBOL *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv81 = 48
tv79 = 56
tv77 = 64
_Result$ = 72
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_back_with_unused_capacity<_SYMBOL *>, COMDAT

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 89 44 24 20	 mov	 QWORD PTR _Mylast$[rsp], rax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00026	48 8b 4c 24 68	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  0002b	e8 00 00 00 00	 call	 ??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ; std::forward<_SYMBOL *>
  00030	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	e8 00 00 00 00	 call	 ??$_Unfancy@PEAU_SYMBOL@@@std@@YAPEAPEAU_SYMBOL@@PEAPEAU1@@Z ; std::_Unfancy<_SYMBOL *>
  00042	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
  00047	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	e8 00 00 00 00	 call	 ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
  00051	48 89 44 24 40	 mov	 QWORD PTR tv77[rsp], rax
  00056	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv81[rsp]
  0005b	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv79[rsp]
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv77[rsp]
  00065	e8 00 00 00 00	 call	 ??$construct@PEAU_SYMBOL@@PEAU1@@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@PEAU_SYMBOL@@@1@QEAPEAU_SYMBOL@@$$QEAPEAU3@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::construct<_SYMBOL *,_SYMBOL *>

; 688  :         _Orphan_range(_Mylast, _Mylast);

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0006f	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00077	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0007f	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAXPEAPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 89 44 24 48	 mov	 QWORD PTR _Result$[rsp], rax

; 690  :         ++_Mylast;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00096	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00099	48 83 c0 08	 add	 rax, 8
  0009d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Mylast$[rsp]
  000a2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;

  000a5	48 8b 44 24 48	 mov	 rax, QWORD PTR _Result$[rsp]

; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  000aa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ae	c3		 ret	 0
??$_Emplace_back_with_unused_capacity@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_back_with_unused_capacity<_SYMBOL *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z PROC ; std::forward<_SYMBOL *>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ENDP ; std::forward<_SYMBOL *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
_Result$ = 64
this$ = 96
<_Val_0>$ = 104
??$emplace_back@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::emplace_back<_SYMBOL *>, COMDAT

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR _My_data$[rsp], rax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 89 44 24 28	 mov	 QWORD PTR _Mylast$[rsp], rax

; 704  :         if (_Mylast != _My_data._Myend) {

  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00030	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00034	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00037	74 19		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00039	48 8b 4c 24 68	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  0003e	e8 00 00 00 00	 call	 ??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ; std::forward<_SYMBOL *>
  00043	48 8b d0	 mov	 rdx, rax
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0004b	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_back_with_unused_capacity<_SYMBOL *>
  00050	eb 3a		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  00057	e8 00 00 00 00	 call	 ??$forward@PEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ; std::forward<_SYMBOL *>
  0005c	48 89 44 24 30	 mov	 QWORD PTR tv83[rsp], rax
  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 89 44 24 38	 mov	 QWORD PTR tv81[rsp], rax
  0006e	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv83[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv81[rsp]
  00078	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0007d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@QEAPEAU2@$$QEAPEAU2@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Emplace_reallocate<_SYMBOL *>
  00082	48 89 44 24 40	 mov	 QWORD PTR _Result$[rsp], rax

; 709  : #if _HAS_CXX17
; 710  :         return _Result;

  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR _Result$[rsp]
$LN1@emplace_ba:

; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0008c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00090	c3		 ret	 0
??$emplace_back@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::emplace_back<_SYMBOL *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AEAPEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z PROC ; std::move<_SYMBOL * &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1468 : }

  0000a	c3		 ret	 0
??$move@AEAPEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ENDP ; std::move<_SYMBOL * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 275  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 276  : }

  0000a	c3		 ret	 0
??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z PROC ; std::pointer_traits<char *>::pointer_to, COMDAT

; 146  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 147  :         return _STD addressof(_Val);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Val$[rsp]
  0000e	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPEADAEAD@Z ; std::addressof<char>

; 148  :     }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ENDP ; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 289  :     return _Ptr;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 290  : }

  0000a	c3		 ret	 0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z PROC		; std::max<char *>, COMDAT

; 42   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 43   :     // return larger of _Left and _Right
; 44   :     return _Left < _Right ? _Right : _Left;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  00018	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001e	73 0b		 jae	 SHORT $LN3@max
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00025	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00029	eb 09		 jmp	 SHORT $LN4@max
$LN3@max:
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00030	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
$LN4@max:
  00034	48 8b 04 24	 mov	 rax, QWORD PTR tv65[rsp]
  00038	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp], rax
  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR $T1[rsp]

; 45   : }

  00042	48 83 c4 18	 add	 rsp, 24
  00046	c3		 ret	 0
??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z ENDP		; std::max<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 67   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 68   :     // return smaller of _Left and _Right
; 69   :     return _Right < _Left ? _Right : _Left;

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00013	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Left$[rsp]
  00018	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001e	73 0b		 jae	 SHORT $LN3@min
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00025	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00029	eb 09		 jmp	 SHORT $LN4@min
$LN3@min:
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00030	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
$LN4@min:
  00034	48 8b 04 24	 mov	 rax, QWORD PTR tv65[rsp]
  00038	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp], rax
  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR $T1[rsp]

; 70   : }

  00042	48 83 c4 18	 add	 rsp, 24
  00046	c3		 ret	 0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Pfmod$1 = 32
_Pf$2 = 40
_Id$3 = 48
$T4 = 56
_Psave$5 = 64
_Lock$6 = 72
_Psave_guard$7 = 80
__$ArrayPad$ = 88
_Loc$ = 112
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 426  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 427  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00018	33 d2		 xor	 edx, edx
  0001a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$6[rsp]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00025	90		 npad	 1

; 428  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  0002d	48 89 44 24 40	 mov	 QWORD PTR _Psave$5[rsp], rax

; 429  : 
; 430  :     const size_t _Id         = _Facet::id;

  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
  0003f	48 89 44 24 30	 mov	 QWORD PTR _Id$3[rsp], rax

; 431  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  00044	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Id$3[rsp]
  00049	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _Loc$[rsp]
  0004e	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ; std::locale::_Getfacet
  00053	48 89 44 24 28	 mov	 QWORD PTR _Pf$2[rsp], rax

; 432  : 
; 433  :     if (!_Pf) {

  00058	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pf$2[rsp], 0
  0005e	0f 85 a3 00 00
	00		 jne	 $LN2@use_facet

; 434  :         if (_Psave) {

  00064	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Psave$5[rsp], 0
  0006a	74 0f		 je	 SHORT $LN3@use_facet

; 435  :             _Pf = _Psave; // lazy facet already allocated

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR _Psave$5[rsp]
  00071	48 89 44 24 28	 mov	 QWORD PTR _Pf$2[rsp], rax
  00076	e9 8c 00 00 00	 jmp	 $LN2@use_facet
$LN3@use_facet:

; 436  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  0007b	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Loc$[rsp]
  00080	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Psave$5[rsp]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
  0008b	48 83 f8 ff	 cmp	 rax, -1
  0008f	75 08		 jne	 SHORT $LN5@use_facet

; 437  : #if _HAS_EXCEPTIONS
; 438  :             _Throw_bad_cast(); // lazy disallowed

  00091	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
  00096	90		 npad	 1

; 439  : #else // _HAS_EXCEPTIONS
; 440  :             _CSTD abort(); // lazy disallowed
; 441  : #endif // _HAS_EXCEPTIONS
; 442  :         } else { // queue up lazy facet for destruction

  00097	eb 6e		 jmp	 SHORT $LN2@use_facet
$LN5@use_facet:

; 443  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR _Psave$5[rsp]
  0009e	48 89 44 24 20	 mov	 QWORD PTR _Pfmod$1[rsp], rax

; 444  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  000a3	ba 08 00 00 00	 mov	 edx, 8
  000a8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Psave_guard$7[rsp]
  000ad	e8 00 00 00 00	 call	 ?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z
  000b2	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Pfmod$1[rsp]
  000b7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Psave_guard$7[rsp]
  000bc	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
  000c1	90		 npad	 1

; 445  : 
; 446  : #if defined(_M_CEE)
; 447  :             _Facet_Register_m(_Pfmod);
; 448  : #else // defined(_M_CEE)
; 449  :             _Facet_Register(_Pfmod);

  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Pfmod$1[rsp]
  000c7	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 450  : #endif // defined(_M_CEE)
; 451  : 
; 452  :             _Pfmod->_Incref();

  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR _Pfmod$1[rsp]
  000d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Pfmod$1[rsp]
  000d9	ff 50 08	 call	 QWORD PTR [rax+8]

; 453  :             _Facetptr<_Facet>::_Psave = _Psave;

  000dc	48 8b 44 24 40	 mov	 rax, QWORD PTR _Psave$5[rsp]
  000e1	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB, rax ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 454  :             _Pf                       = _Psave;

  000e8	48 8b 44 24 40	 mov	 rax, QWORD PTR _Psave$5[rsp]
  000ed	48 89 44 24 28	 mov	 QWORD PTR _Pf$2[rsp], rax

; 455  : 
; 456  :             (void) _Psave_guard.release();

  000f2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Psave_guard$7[rsp]
  000f7	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
  000fc	90		 npad	 1

; 457  :         }

  000fd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Psave_guard$7[rsp]
  00102	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 458  :     }
; 459  : 
; 460  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pf$2[rsp]
  0010c	48 89 44 24 38	 mov	 QWORD PTR $T4[rsp], rax
  00111	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$6[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0011c	48 8b 44 24 38	 mov	 rax, QWORD PTR $T4[rsp]

; 461  :     _END_LOCK()
; 462  : } // end of use_facet body

  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00126	48 33 cc	 xor	 rcx, rsp
  00129	e8 00 00 00 00	 call	 __security_check_cookie
  0012e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00132	c3		 ret	 0
$LN10@use_facet:
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Pfmod$1 = 32
_Pf$2 = 40
_Id$3 = 48
$T4 = 56
_Psave$5 = 64
_Lock$6 = 72
_Psave_guard$7 = 80
__$ArrayPad$ = 88
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 48	 lea	 rcx, QWORD PTR _Lock$6[rbp]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Pfmod$1 = 32
_Pf$2 = 40
_Id$3 = 48
$T4 = 56
_Psave$5 = 64
_Lock$6 = 72
_Psave_guard$7 = 80
__$ArrayPad$ = 88
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 50	 lea	 rcx, QWORD PTR _Psave_guard$7[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Pfmod$1 = 32
_Pf$2 = 40
_Id$3 = 48
$T4 = 56
_Psave$5 = 64
_Lock$6 = 72
_Psave_guard$7 = 80
__$ArrayPad$ = 88
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 48	 lea	 rcx, QWORD PTR _Lock$6[rbp]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Pfmod$1 = 32
_Pf$2 = 40
_Id$3 = 48
$T4 = 56
_Psave$5 = 64
_Lock$6 = 72
_Psave_guard$7 = 80
__$ArrayPad$ = 88
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 50	 lea	 rcx, QWORD PTR _Psave_guard$7[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z
_TEXT	SEGMENT
_Num_is_one$ = 32
_Den_is_one$ = 33
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
__$ReturnUdt$ = 96
_Dur$ = 104
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>, COMDAT

; 373  :         is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 374  :         // convert duration to another duration; truncate
; 375  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 376  : 
; 377  :         using _ToRep = typename _To::rep;
; 378  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 379  : 
; 380  :         constexpr bool _Num_is_one = _CF::num == 1;

  0000e	c6 44 24 20 01	 mov	 BYTE PTR _Num_is_one$[rsp], 1

; 381  :         constexpr bool _Den_is_one = _CF::den == 1;

  00013	c6 44 24 21 01	 mov	 BYTE PTR _Den_is_one$[rsp], 1

; 382  : 
; 383  :         if (_Den_is_one) {

  00018	33 c0		 xor	 eax, eax
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	74 55		 je	 SHORT $LN2@duration_c

; 384  :             if (_Num_is_one) {

  0001f	33 c0		 xor	 eax, eax
  00021	83 f8 01	 cmp	 eax, 1
  00024	74 27		 je	 SHORT $LN4@duration_c

; 385  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));

  00026	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Dur$[rsp]
  0002b	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00030	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00035	48 8d 54 24 28	 lea	 rdx, QWORD PTR $T1[rsp]
  0003a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0003f	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  00049	eb 7a		 jmp	 SHORT $LN1@duration_c

; 386  :             } else {

  0004b	eb 25		 jmp	 SHORT $LN5@duration_c
$LN4@duration_c:

; 387  :                 return static_cast<_To>(

  0004d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Dur$[rsp]
  00052	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00057	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  0005c	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  00061	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00066	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  0006b	48 8b 44 24 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  00070	eb 53		 jmp	 SHORT $LN1@duration_c
$LN5@duration_c:

; 388  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 389  :             }
; 390  :         } else {

  00072	eb 51		 jmp	 SHORT $LN1@duration_c
$LN2@duration_c:

; 391  :             if (_Num_is_one) {

  00074	33 c0		 xor	 eax, eax
  00076	83 f8 01	 cmp	 eax, 1
  00079	74 27		 je	 SHORT $LN6@duration_c

; 392  :                 return static_cast<_To>(

  0007b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Dur$[rsp]
  00080	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00085	48 89 44 24 38	 mov	 QWORD PTR $T3[rsp], rax
  0008a	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T3[rsp]
  0008f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00094	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  00099	48 8b 44 24 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  0009e	eb 25		 jmp	 SHORT $LN1@duration_c

; 393  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 394  :             } else {

  000a0	eb 23		 jmp	 SHORT $LN1@duration_c
$LN6@duration_c:

; 395  :                 return static_cast<_To>(static_cast<_ToRep>(

  000a2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Dur$[rsp]
  000a7	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  000ac	48 89 44 24 40	 mov	 QWORD PTR $T4[rsp], rax
  000b1	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T4[rsp]
  000b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000bb	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  000c0	48 8b 44 24 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@duration_c:

; 396  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 397  :             }
; 398  :         }
; 399  :     }

  000c5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c9	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\chrono
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
tv77 = 32
tv75 = 40
$T1 = 48
$T2 = 56
__$ReturnUdt$ = 80
_Left$ = 88
_Right$ = 96
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 496  :             is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 497  :         return _Left.time_since_epoch() - _Right.time_since_epoch();

  00013	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Right$[rsp]
  0001d	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00022	48 89 44 24 20	 mov	 QWORD PTR tv77[rsp], rax
  00027	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T2[rsp]
  0002c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Left$[rsp]
  00031	e8 00 00 00 00	 call	 ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
  00036	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  0003b	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv77[rsp]
  00040	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv75[rsp]
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0004a	e8 00 00 00 00	 call	 ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 498  :     }

  00054	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00058	c3		 ret	 0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\main.cpp
;	COMDAT main
_TEXT	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main	PROC						; COMDAT

; 27   : {

$LN11:
  00000	48 81 ec a8 0b
	00 00		 sub	 rsp, 2984		; 00000ba8H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 90
	0b 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 28   : 	
; 29   : 	SMCB Block;
; 30   : 	SmAllocCodeBlock(&Block, 0x10000);

  00019	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  0001e	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR Block$[rsp]
  00026	e8 00 00 00 00	 call	 ?SmAllocCodeBlock@@YAXPEAU_SMCB@@K@Z ; SmAllocCodeBlock

; 31   : 	SmLoadFromFile("C:\\Users\\Iizerd\\source\\repos\\StackMachine\\Code\\Example.txt");

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG139129
  00032	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  0003a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003f	90		 npad	 1
  00040	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00048	e8 00 00 00 00	 call	 ?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SmLoadFromFile
  0004d	90		 npad	 1
  0004e	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00056	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 32   : 	SmParseLoadedFile();

  0005b	e8 00 00 00 00	 call	 ?SmParseLoadedFile@@YAXXZ ; SmParseLoadedFile

; 33   : 	SmAssembleToBlock(&Block);

  00060	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR Block$[rsp]
  00068	e8 00 00 00 00	 call	 ?SmAssembleToBlock@@YAXPEAU_SMCB@@@Z ; SmAssembleToBlock

; 34   : 	ULONG64 Offset = 0;

  0006d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR Offset$[rsp], 0

; 35   : 	INT Size = 0;

  00076	c7 84 24 58 01
	00 00 00 00 00
	00		 mov	 DWORD PTR Size$[rsp], 0
$LN2@main:

; 36   : 	while (*(PUCHAR)((PUCHAR)Block.Base + Offset) != VMEXIT)

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR Offset$[rsp]
  00086	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  0008e	48 03 c8	 add	 rcx, rax
  00091	48 8b c1	 mov	 rax, rcx
  00094	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00097	83 f8 01	 cmp	 eax, 1
  0009a	0f 84 8a 00 00
	00		 je	 $LN3@main

; 37   : 	{
; 38   : 		std::cout << SmDecodeInstruction(((PUCHAR)Block.Base + Offset), &Size);

  000a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000a7	48 89 44 24 70	 mov	 QWORD PTR tv86[rsp], rax
  000ac	48 8b 44 24 28	 mov	 rax, QWORD PTR Offset$[rsp]
  000b1	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  000b9	48 03 c8	 add	 rcx, rax
  000bc	48 8b c1	 mov	 rax, rcx
  000bf	4c 8d 84 24 58
	01 00 00	 lea	 r8, QWORD PTR Size$[rsp]
  000c7	48 8b d0	 mov	 rdx, rax
  000ca	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  000d2	e8 00 00 00 00	 call	 ?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z ; SmDecodeInstruction
  000d7	48 89 44 24 58	 mov	 QWORD PTR tv67[rsp], rax
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR tv67[rsp]
  000e1	48 89 44 24 60	 mov	 QWORD PTR tv250[rsp], rax
  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR tv250[rsp]
  000eb	48 89 44 24 68	 mov	 QWORD PTR tv88[rsp], rax
  000f0	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv88[rsp]
  000f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv86[rsp]
  000fa	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  000ff	90		 npad	 1
  00100	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  00108	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 39   : 		Offset += Size;

  0010d	48 63 84 24 58
	01 00 00	 movsxd	 rax, DWORD PTR Size$[rsp]
  00115	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Offset$[rsp]
  0011a	48 03 c8	 add	 rcx, rax
  0011d	48 8b c1	 mov	 rax, rcx
  00120	48 89 44 24 28	 mov	 QWORD PTR Offset$[rsp], rax

; 40   : 	}

  00125	e9 57 ff ff ff	 jmp	 $LN2@main
$LN3@main:

; 41   : 	std::cout << SmDecodeInstruction(((PUCHAR)Block.Base + Offset), NULL);

  0012a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00131	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  00139	48 8b 44 24 28	 mov	 rax, QWORD PTR Offset$[rsp]
  0013e	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  00146	48 03 c8	 add	 rcx, rax
  00149	48 8b c1	 mov	 rax, rcx
  0014c	45 33 c0	 xor	 r8d, r8d
  0014f	48 8b d0	 mov	 rdx, rax
  00152	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  0015a	e8 00 00 00 00	 call	 ?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z ; SmDecodeInstruction
  0015f	48 89 44 24 78	 mov	 QWORD PTR tv254[rsp], rax
  00164	48 8b 44 24 78	 mov	 rax, QWORD PTR tv254[rsp]
  00169	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv252[rsp], rax
  00171	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv252[rsp]
  00179	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  00181	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv135[rsp]
  00189	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  00191	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  00196	90		 npad	 1
  00197	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  0019f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 42   : 
; 43   : 	system("pause");

  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG139130
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_system
$LN4@main:

; 44   : 
; 45   : 	VM_HANDLER_TABLE HandlerTable;
; 46   : 	VM_CONTEXT Context;
; 47   : 	VM_AUX_STORAGE Storage;
; 48   : 
; 49   : 	//InitHandlerTable(&HandlerTable);
; 50   : 	//Context.Num[R1].Addr64 = TestFunc;
; 51   : 
; 52   : 	//printf("%llu is the meme.\n", Context.Num[R1].Addr64);
; 53   : 	//VmExecute(&Context, Block.Base, &HandlerTable, &Storage);
; 54   : 	//printf("%llu is the meme.\n", Context.Num[R1].Addr64);
; 55   : 	//system("pause");
; 56   : 
; 57   : 	while (TRUE)

  001b1	33 c0		 xor	 eax, eax
  001b3	83 f8 01	 cmp	 eax, 1
  001b6	0f 84 dc 02 00
	00		 je	 $LN5@main

; 58   : 	{
; 59   : 		system("pause");

  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG139131
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_system

; 60   : 		
; 61   : 		std::string Ex = "Hello this is a test string. It is really long because I want to really get a good idea for how \

  001c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG139132
  001d0	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  001d8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001dd	90		 npad	 1

; 62   : long this is actually going to take for both methods. Did you know that while my username looks like lizerd, it is actually Iizerd \
; 63   : with a capitol i at the start instead of an L. I think this is cool and unique and separates me from other people :D. Now im making \
; 64   : this string even longer and talking more about lizards. Did you know there are some lizards that can shoot blood from their eyes? \
; 65   : when I found this out I thought it was super cool. A sick defense mechanism that allows them to scare off predators.";
; 66   : 
; 67   : 
; 68   : 		char XorKey = 'A';

  001de	c6 44 24 20 41	 mov	 BYTE PTR XorKey$1[rsp], 65 ; 00000041H

; 69   : 		ULONG ArraySize = Ex.size();

  001e3	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  001eb	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  001f0	89 44 24 30	 mov	 DWORD PTR ArraySize$2[rsp], eax

; 70   : 		InitHandlerTable(&HandlerTable);

  001f4	48 8d 8c 24 90
	03 00 00	 lea	 rcx, QWORD PTR HandlerTable$[rsp]
  001fc	e8 00 00 00 00	 call	 ?InitHandlerTable@@YAXPEAU_VM_HANDLER_TABLE@@@Z ; InitHandlerTable

; 71   : 		std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();

  00201	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR start$12[rsp]
  00209	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 72   : 		Context.Num[R13] = Ex.data();

  0020e	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  00216	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  0021b	b9 08 00 00 00	 mov	 ecx, 8
  00220	48 6b c9 0d	 imul	 rcx, rcx, 13
  00224	48 89 84 0c 90
	01 00 00	 mov	 QWORD PTR Context$[rsp+rcx], rax

; 73   : 		Context.Num[R12] = (PVOID)(CHAR)XorKey;

  0022c	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR XorKey$1[rsp]
  00232	b9 08 00 00 00	 mov	 ecx, 8
  00237	48 6b c9 0c	 imul	 rcx, rcx, 12
  0023b	48 89 84 0c 90
	01 00 00	 mov	 QWORD PTR Context$[rsp+rcx], rax

; 74   : 		Context.Num[R11] = (PVOID)(ULONG64)ArraySize;

  00243	8b 44 24 30	 mov	 eax, DWORD PTR ArraySize$2[rsp]
  00247	b9 08 00 00 00	 mov	 ecx, 8
  0024c	48 6b c9 0b	 imul	 rcx, rcx, 11
  00250	48 89 84 0c 90
	01 00 00	 mov	 QWORD PTR Context$[rsp+rcx], rax

; 75   : 		VmEnter(&Context, Block.Base, &HandlerTable, &Storage);

  00258	4c 8d 8c 24 90
	02 00 00	 lea	 r9, QWORD PTR Storage$[rsp]
  00260	4c 8d 84 24 90
	03 00 00	 lea	 r8, QWORD PTR HandlerTable$[rsp]
  00268	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR Block$[rsp]
  00270	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR Context$[rsp]
  00278	e8 00 00 00 00	 call	 VmEnter

; 76   : 		Context.Num[R13] = Ex.data();

  0027d	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  00285	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  0028a	b9 08 00 00 00	 mov	 ecx, 8
  0028f	48 6b c9 0d	 imul	 rcx, rcx, 13
  00293	48 89 84 0c 90
	01 00 00	 mov	 QWORD PTR Context$[rsp+rcx], rax

; 77   : 		Context.Num[R12] = (PVOID)(CHAR)XorKey;

  0029b	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR XorKey$1[rsp]
  002a1	b9 08 00 00 00	 mov	 ecx, 8
  002a6	48 6b c9 0c	 imul	 rcx, rcx, 12
  002aa	48 89 84 0c 90
	01 00 00	 mov	 QWORD PTR Context$[rsp+rcx], rax

; 78   : 		Context.Num[R11] = (PVOID)(ULONG64)ArraySize;

  002b2	8b 44 24 30	 mov	 eax, DWORD PTR ArraySize$2[rsp]
  002b6	b9 08 00 00 00	 mov	 ecx, 8
  002bb	48 6b c9 0b	 imul	 rcx, rcx, 11
  002bf	48 89 84 0c 90
	01 00 00	 mov	 QWORD PTR Context$[rsp+rcx], rax

; 79   : 		VmEnter(&Context, Block.Base, &HandlerTable, &Storage);

  002c7	4c 8d 8c 24 90
	02 00 00	 lea	 r9, QWORD PTR Storage$[rsp]
  002cf	4c 8d 84 24 90
	03 00 00	 lea	 r8, QWORD PTR HandlerTable$[rsp]
  002d7	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR Block$[rsp]
  002df	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR Context$[rsp]
  002e7	e8 00 00 00 00	 call	 VmEnter

; 80   : 		std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();

  002ec	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR end$13[rsp]
  002f4	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 81   : 		//std::cout << "\n\n" << Ex << " Was the string.\n";
; 82   : 		std::cout << "My Machine took " << std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() << " microseconds.\n";

  002f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG139134
  00300	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00307	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0030c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv196[rsp], rax
  00314	4c 8d 84 24 60
	01 00 00	 lea	 r8, QWORD PTR start$12[rsp]
  0031c	48 8d 94 24 68
	01 00 00	 lea	 rdx, QWORD PTR end$13[rsp]
  00324	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T3[rsp]
  0032c	e8 00 00 00 00	 call	 ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00331	48 8b d0	 mov	 rdx, rax
  00334	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR $T4[rsp]
  0033c	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
  00341	48 8b c8	 mov	 rcx, rax
  00344	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00349	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv194[rsp], rax
  00351	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv194[rsp]
  00359	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv196[rsp]
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_J@Z
  00367	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG139133
  0036e	48 8b c8	 mov	 rcx, rax
  00371	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 83   : 
; 84   : 		start = std::chrono::high_resolution_clock::now();

  00376	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  0037e	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
  00383	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00386	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR start$12[rsp], rax

; 85   : 		CXorStr(Ex.data(), 'A', Ex.size());

  0038e	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  00396	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0039b	89 44 24 34	 mov	 DWORD PTR tv211[rsp], eax
  0039f	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  003a7	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  003ac	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv209[rsp], rax
  003b4	44 8b 44 24 34	 mov	 r8d, DWORD PTR tv211[rsp]
  003b9	b2 41		 mov	 dl, 65			; 00000041H
  003bb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv209[rsp]
  003c3	e8 00 00 00 00	 call	 ?CXorStr@@YAXPEAXDK@Z	; CXorStr

; 86   : 		CXorStr(Ex.data(), 'A', Ex.size());

  003c8	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  003d0	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  003d5	89 44 24 38	 mov	 DWORD PTR tv223[rsp], eax
  003d9	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  003e1	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  003e6	48 89 44 24 40	 mov	 QWORD PTR tv221[rsp], rax
  003eb	44 8b 44 24 38	 mov	 r8d, DWORD PTR tv223[rsp]
  003f0	b2 41		 mov	 dl, 65			; 00000041H
  003f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv221[rsp]
  003f7	e8 00 00 00 00	 call	 ?CXorStr@@YAXPEAXDK@Z	; CXorStr

; 87   : 		end = std::chrono::high_resolution_clock::now();

  003fc	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00404	e8 00 00 00 00	 call	 ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
  00409	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0040c	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR end$13[rsp], rax

; 88   : 
; 89   : 		//std::cout << "\n\n" << Ex << " Was the string.\n";
; 90   : 		std::cout << "The C One took  " << std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() << " microseconds.\n";

  00414	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG139136
  0041b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00422	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00427	48 89 44 24 50	 mov	 QWORD PTR tv247[rsp], rax
  0042c	4c 8d 84 24 60
	01 00 00	 lea	 r8, QWORD PTR start$12[rsp]
  00434	48 8d 94 24 68
	01 00 00	 lea	 rdx, QWORD PTR end$13[rsp]
  0043c	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  00444	e8 00 00 00 00	 call	 ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00449	48 8b d0	 mov	 rdx, rax
  0044c	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00454	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,0>
  00459	48 8b c8	 mov	 rcx, rax
  0045c	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
  00461	48 89 44 24 48	 mov	 QWORD PTR tv245[rsp], rax
  00466	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv245[rsp]
  0046b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv247[rsp]
  00470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_J@Z
  00476	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG139135
  0047d	48 8b c8	 mov	 rcx, rax
  00480	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00485	90		 npad	 1

; 91   : 	}

  00486	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Ex$14[rsp]
  0048e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00493	e9 19 fd ff ff	 jmp	 $LN4@main
$LN5@main:

; 92   : }

  00498	48 8b 8c 24 90
	0b 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a0	48 33 cc	 xor	 rcx, rsp
  004a3	e8 00 00 00 00	 call	 __security_check_cookie
  004a8	48 81 c4 a8 0b
	00 00		 add	 rsp, 2984		; 00000ba8H
  004af	c3		 ret	 0
main	ENDP
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main$dtor$0 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d e0 00
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$0 ENDP
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main$dtor$1 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 00 01
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$1 ENDP
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main$dtor$2 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 20 01
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$2 ENDP
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main$dtor$3 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 70 01
	00 00		 lea	 rcx, QWORD PTR Ex$14[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main$dtor$0 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d e0 00
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main$dtor$1 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 00 01
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main$dtor$2 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 20 01
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
XorKey$1 = 32
Offset$ = 40
ArraySize$2 = 48
tv211 = 52
tv223 = 56
tv221 = 64
tv245 = 72
tv247 = 80
tv67 = 88
tv250 = 96
tv88 = 104
tv86 = 112
tv254 = 120
tv252 = 128
tv135 = 136
tv133 = 144
tv194 = 152
tv196 = 160
tv209 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 256
$T11 = 288
Block$ = 320
Size$ = 344
start$12 = 352
end$13 = 360
Ex$14 = 368
Context$ = 400
Storage$ = 656
HandlerTable$ = 912
__$ArrayPad$ = 2960
main$dtor$3 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 70 01
	00 00		 lea	 rcx, QWORD PTR Ex$14[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\main.cpp
;	COMDAT ?TestFunc@@YA_J_J00000@Z
_TEXT	SEGMENT
v1$ = 48
v2$ = 56
v3$ = 64
v4$ = 72
v5$ = 80
v6$ = 88
?TestFunc@@YA_J_J00000@Z PROC				; TestFunc, COMDAT

; 20   : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 21   : 	printf("Got here. %i\n", v6);

  00018	48 8b 54 24 58	 mov	 rdx, QWORD PTR v6$[rsp]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG139027
  00024	e8 00 00 00 00	 call	 printf

; 22   : 	//std::cout << v1 << ' ' << v2 << ' ' << v3 << ' ' << v4 << '\n';
; 23   : 	return v1 + v2 + v3 + v4 + v5 + v6;

  00029	48 8b 44 24 38	 mov	 rax, QWORD PTR v2$[rsp]
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v1$[rsp]
  00033	48 03 c8	 add	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	48 03 44 24 40	 add	 rax, QWORD PTR v3$[rsp]
  0003e	48 03 44 24 48	 add	 rax, QWORD PTR v4$[rsp]
  00043	48 03 44 24 50	 add	 rax, QWORD PTR v5$[rsp]
  00048	48 03 44 24 58	 add	 rax, QWORD PTR v6$[rsp]

; 24   : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
?TestFunc@@YA_J_J00000@Z ENDP				; TestFunc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\main.cpp
;	COMDAT ?CXorStr@@YAXPEAXDK@Z
_TEXT	SEGMENT
i$1 = 0
Arr$ = 32
XorKey$ = 40
ArraySize$ = 48
?CXorStr@@YAXPEAXDK@Z PROC				; CXorStr, COMDAT

; 14   : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 15   : 	for (int i = 0; i < ArraySize; i++)

  00012	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$1[rsp], 0
  00019	eb 08		 jmp	 SHORT $LN4@CXorStr
$LN2@CXorStr:
  0001b	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  0001e	ff c0		 inc	 eax
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@CXorStr:
  00023	8b 44 24 30	 mov	 eax, DWORD PTR ArraySize$[rsp]
  00027	39 04 24	 cmp	 DWORD PTR i$1[rsp], eax
  0002a	73 24		 jae	 SHORT $LN3@CXorStr

; 16   : 		((PUCHAR)Arr)[i] ^= XorKey;

  0002c	0f be 44 24 28	 movsx	 eax, BYTE PTR XorKey$[rsp]
  00031	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00035	48 8b 54 24 20	 mov	 rdx, QWORD PTR Arr$[rsp]
  0003a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0003e	33 c8		 xor	 ecx, eax
  00040	8b c1		 mov	 eax, ecx
  00042	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00046	48 8b 54 24 20	 mov	 rdx, QWORD PTR Arr$[rsp]
  0004b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004e	eb cb		 jmp	 SHORT $LN2@CXorStr
$LN3@CXorStr:

; 17   : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
?CXorStr@@YAXPEAXDK@Z ENDP				; CXorStr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\chrono
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>, COMDAT

; 82   :             : _MyRep(static_cast<_Rep>(_Val)) {}

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _Val$[rsp]
  00014	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00017	48 89 08	 mov	 QWORD PTR [rax], rcx
  0001a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001f	c3		 ret	 0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT

; 194  :         _NODISCARD constexpr _Duration time_since_epoch() const noexcept(is_arithmetic_v<rep>) /* strengthened */ {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 195  :             return _MyDur;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00017	48 89 01	 mov	 QWORD PTR [rcx], rax
  0001a	48 8b 44 24 10	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 196  :         }

  0001f	c3		 ret	 0
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 186  :         constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) // strengthened

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 187  :             : _MyDur(_Other) {}

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR _Other$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00017	48 89 01	 mov	 QWORD PTR [rcx], rax
  0001a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001f	c3		 ret	 0
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT

; 93   :         _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 94   :             return _MyRep;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 95   :         }

  0000d	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
_Freq$ = 32
_Ctr$ = 40
_Part$ = 48
_Whole$ = 56
$T1 = 64
$T2 = 72
__$ReturnUdt$ = 96
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT

; 606  :         _NODISCARD static time_point now() noexcept { // get current time

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 607  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  00009	e8 00 00 00 00	 call	 _Query_perf_frequency
  0000e	48 89 44 24 20	 mov	 QWORD PTR _Freq$[rsp], rax

; 608  :             const long long _Ctr  = _Query_perf_counter();

  00013	e8 00 00 00 00	 call	 _Query_perf_counter
  00018	48 89 44 24 28	 mov	 QWORD PTR _Ctr$[rsp], rax

; 609  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 610  :             // Instead of just having "(_Ctr * period::den) / _Freq",
; 611  :             // the algorithm below prevents overflow when _Ctr is sufficiently large.
; 612  :             // It assumes that _Freq * period::den does not overflow, which is currently true for nano period.
; 613  :             // It is not realistic for _Ctr to accumulate to large values from zero with this assumption,
; 614  :             // but the initial value of _Ctr could be large.
; 615  :             const long long _Whole = (_Ctr / _Freq) * period::den;

  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR _Ctr$[rsp]
  00022	48 99		 cdq
  00024	48 f7 7c 24 20	 idiv	 QWORD PTR _Freq$[rsp]
  00029	48 69 c0 00 ca
	9a 3b		 imul	 rax, rax, 1000000000	; 3b9aca00H
  00030	48 89 44 24 38	 mov	 QWORD PTR _Whole$[rsp], rax

; 616  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR _Ctr$[rsp]
  0003a	48 99		 cdq
  0003c	48 f7 7c 24 20	 idiv	 QWORD PTR _Freq$[rsp]
  00041	48 8b c2	 mov	 rax, rdx
  00044	48 69 c0 00 ca
	9a 3b		 imul	 rax, rax, 1000000000	; 3b9aca00H
  0004b	48 99		 cdq
  0004d	48 f7 7c 24 20	 idiv	 QWORD PTR _Freq$[rsp]
  00052	48 89 44 24 30	 mov	 QWORD PTR _Part$[rsp], rax

; 617  :             return time_point(duration(_Whole + _Part));

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR _Part$[rsp]
  0005c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Whole$[rsp]
  00061	48 03 c8	 add	 rcx, rax
  00064	48 8b c1	 mov	 rax, rcx
  00067	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  0006c	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T1[rsp]
  00071	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T2[rsp]
  00076	e8 00 00 00 00	 call	 ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00083	e8 00 00 00 00	 call	 ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 618  :         }

  0008d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00091	c3		 ret	 0
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z
_TEXT	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z PROC ; SmDecodeInstruction, COMDAT

; 734  : {

$LN31:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00028	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T3[rsp], 0

; 735  : 	INT InstructionSize = SmGetInstructionSize(*(PUCHAR)Instruction);

  00030	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  00038	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0003b	e8 00 00 00 00	 call	 ?SmGetInstructionSize@@YAHE@Z ; SmGetInstructionSize
  00040	89 44 24 28	 mov	 DWORD PTR InstructionSize$[rsp], eax

; 736  : 	std::string T = "";

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG134242
  0004b	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  00053	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00058	90		 npad	 1

; 737  : 	for (INT i = 0; i < InstructionSize; i++)

  00059	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00061	eb 0a		 jmp	 SHORT $LN4@SmDecodeIn
$LN2@SmDecodeIn:
  00063	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00067	ff c0		 inc	 eax
  00069	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@SmDecodeIn:
  0006d	8b 44 24 28	 mov	 eax, DWORD PTR InstructionSize$[rsp]
  00071	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00075	7d 5e		 jge	 SHORT $LN3@SmDecodeIn

; 738  : 	{
; 739  : 		T += SmPrintByteAsHex(*(PUCHAR)((PUCHAR)Instruction + i));

  00077	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0007c	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR Instruction$[rsp]
  00084	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00088	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T4[rsp]
  00090	e8 00 00 00 00	 call	 ?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; SmPrintByteAsHex
  00095	48 89 44 24 38	 mov	 QWORD PTR tv67[rsp], rax
  0009a	48 8b 44 24 38	 mov	 rax, QWORD PTR tv67[rsp]
  0009f	48 89 44 24 40	 mov	 QWORD PTR tv191[rsp], rax
  000a4	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv191[rsp]
  000a9	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  000b1	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  000b6	90		 npad	 1
  000b7	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T4[rsp]
  000bf	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 740  : 		T += ' ';

  000c4	b2 20		 mov	 dl, 32			; 00000020H
  000c6	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  000ce	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 741  : 	}

  000d3	eb 8e		 jmp	 SHORT $LN2@SmDecodeIn
$LN3@SmDecodeIn:

; 742  : 	for (INT i = 0; i < 9 - InstructionSize; i++)

  000d5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  000dd	eb 0a		 jmp	 SHORT $LN7@SmDecodeIn
$LN5@SmDecodeIn:
  000df	8b 44 24 2c	 mov	 eax, DWORD PTR i$2[rsp]
  000e3	ff c0		 inc	 eax
  000e5	89 44 24 2c	 mov	 DWORD PTR i$2[rsp], eax
$LN7@SmDecodeIn:
  000e9	b8 09 00 00 00	 mov	 eax, 9
  000ee	2b 44 24 28	 sub	 eax, DWORD PTR InstructionSize$[rsp]
  000f2	39 44 24 2c	 cmp	 DWORD PTR i$2[rsp], eax
  000f6	7d 16		 jge	 SHORT $LN6@SmDecodeIn

; 743  : 	{
; 744  : 		T += "   ";

  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG134243
  000ff	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  00107	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 745  : 	}

  0010c	eb d1		 jmp	 SHORT $LN5@SmDecodeIn
$LN6@SmDecodeIn:

; 746  : 	T += '\t';

  0010e	b2 09		 mov	 dl, 9
  00110	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  00118	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 747  : 	T += InstructionBindings[*(PUCHAR)Instruction];

  0011d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  00125	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?InstructionBindings@@3PAPEBDA ; InstructionBindings
  0012f	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00133	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  0013b	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 748  : 	if (InstructionSize != 1)

  00140	83 7c 24 28 01	 cmp	 DWORD PTR InstructionSize$[rsp], 1
  00145	0f 84 0b 02 00
	00		 je	 $LN10@SmDecodeIn

; 749  : 	{
; 750  : 		T += '\t';

  0014b	b2 09		 mov	 dl, 9
  0014d	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  00155	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 751  : 		switch (*(PUCHAR)Instruction)

  0015a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  00162	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00165	89 44 24 24	 mov	 DWORD PTR tv131[rsp], eax
  00169	8b 44 24 24	 mov	 eax, DWORD PTR tv131[rsp]
  0016d	83 e8 03	 sub	 eax, 3
  00170	89 44 24 24	 mov	 DWORD PTR tv131[rsp], eax
  00174	81 7c 24 24 86
	00 00 00	 cmp	 DWORD PTR tv131[rsp], 134 ; 00000086H
  0017c	0f 87 d4 01 00
	00		 ja	 $LN10@SmDecodeIn
  00182	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv131[rsp]
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0018e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN29@SmDecodeIn[rcx+rax]
  00196	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN30@SmDecodeIn[rcx+rax*4]
  0019d	48 03 c1	 add	 rax, rcx
  001a0	ff e0		 jmp	 rax
$LN11@SmDecodeIn:

; 752  : 		{
; 753  : 		case LDIB:
; 754  : 		case LDIBSXW:
; 755  : 		case LDIBSXD:
; 756  : 		case LDIBSXQ:
; 757  : 		case LDIBZXW:
; 758  : 		case LDIBZXD:
; 759  : 		case LDIBZXQ:
; 760  : 		{
; 761  : 			T += std::to_string((INT)(*(PCHAR)((PUCHAR)Instruction + 1)));

  001a2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  001aa	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001ae	8b d0		 mov	 edx, eax
  001b0	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  001b8	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  001bd	48 89 44 24 48	 mov	 QWORD PTR tv186[rsp], rax
  001c2	48 8b 44 24 48	 mov	 rax, QWORD PTR tv186[rsp]
  001c7	48 89 44 24 50	 mov	 QWORD PTR tv193[rsp], rax
  001cc	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv193[rsp]
  001d1	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  001d9	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  001de	90		 npad	 1
  001df	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  001e7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 762  : 			break;

  001ec	e9 65 01 00 00	 jmp	 $LN10@SmDecodeIn
$LN12@SmDecodeIn:

; 763  : 		}
; 764  : 		case LDIW:
; 765  : 		case EDITSP:
; 766  : 		case LDIWSXD:
; 767  : 		case LDIWSXQ:
; 768  : 		case LDIWZXD:
; 769  : 		case LDIWZXQ:
; 770  : 		case LDBPB:
; 771  : 		case LDBPW:
; 772  : 		case LDBPD:
; 773  : 		case LDBPQ:
; 774  : 		case STBPB:
; 775  : 		case STBPW:
; 776  : 		case STBPD:
; 777  : 		case STBPQ:
; 778  : 		{
; 779  : 			T += std::to_string(*(PSHORT)((PUCHAR)Instruction + 1));

  001f1	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  001f9	0f bf 40 01	 movsx	 eax, WORD PTR [rax+1]
  001fd	8b d0		 mov	 edx, eax
  001ff	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00207	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  0020c	48 89 44 24 58	 mov	 QWORD PTR tv207[rsp], rax
  00211	48 8b 44 24 58	 mov	 rax, QWORD PTR tv207[rsp]
  00216	48 89 44 24 60	 mov	 QWORD PTR tv195[rsp], rax
  0021b	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv195[rsp]
  00220	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  00228	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  0022d	90		 npad	 1
  0022e	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00236	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 780  : 			break;

  0023b	e9 16 01 00 00	 jmp	 $LN10@SmDecodeIn
$LN13@SmDecodeIn:

; 781  : 		}
; 782  : 		case LDIDSXQ:
; 783  : 		case LDIDZXQ:
; 784  : 		case LDID:
; 785  : 		{
; 786  : 			T += std::to_string(*(PINT)((PUCHAR)Instruction + 1));

  00240	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  00248	8b 50 01	 mov	 edx, DWORD PTR [rax+1]
  0024b	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  00253	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
  00258	48 89 44 24 68	 mov	 QWORD PTR tv208[rsp], rax
  0025d	48 8b 44 24 68	 mov	 rax, QWORD PTR tv208[rsp]
  00262	48 89 44 24 70	 mov	 QWORD PTR tv197[rsp], rax
  00267	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv197[rsp]
  0026c	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  00274	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00279	90		 npad	 1
  0027a	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  00282	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 787  : 			break;

  00287	e9 ca 00 00 00	 jmp	 $LN10@SmDecodeIn
$LN14@SmDecodeIn:

; 788  : 		}
; 789  : 		case LDIQ:
; 790  : 		{
; 791  : 			T += std::to_string(*(PLONG64)((PUCHAR)Instruction + 1));

  0028c	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  00294	48 8b 50 01	 mov	 rdx, QWORD PTR [rax+1]
  00298	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  002a0	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ; std::to_string
  002a5	48 89 44 24 78	 mov	 QWORD PTR tv209[rsp], rax
  002aa	48 8b 44 24 78	 mov	 rax, QWORD PTR tv209[rsp]
  002af	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv199[rsp], rax
  002b7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv199[rsp]
  002bf	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  002c7	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  002cc	90		 npad	 1
  002cd	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  002d5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 792  : 			break;

  002da	eb 7a		 jmp	 SHORT $LN10@SmDecodeIn
$LN15@SmDecodeIn:

; 793  : 		}
; 794  : 		case POPB:
; 795  : 		case POPW:
; 796  : 		case POPD:
; 797  : 		case POPQ:
; 798  : 		case PUSHB:
; 799  : 		case PUSHW:
; 800  : 		case PUSHD:
; 801  : 		case PUSHQ:
; 802  : 		case STSP:
; 803  : 		case LDSP:
; 804  : 		case STIP:
; 805  : 		case LDIP:
; 806  : 		{
; 807  : 			T += RegisterBindings[*(PUCHAR)((PUCHAR)Instruction + 1)];

  002dc	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  002e4	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RegisterBindings@@3PAPEBDA ; RegisterBindings
  002ef	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  002f3	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  002fb	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 808  : 			break;

  00300	eb 54		 jmp	 SHORT $LN10@SmDecodeIn
$LN16@SmDecodeIn:

; 809  : 		}
; 810  : 		case JMPI:
; 811  : 		case JL:
; 812  : 		case JLE:
; 813  : 		case JG:
; 814  : 		case JGE:
; 815  : 		case JZ:
; 816  : 		case JNZ:
; 817  : 		case CALL:
; 818  : 		case LDSB:
; 819  : 		case LDSW:
; 820  : 		case LDSD:
; 821  : 		case LDSQ:
; 822  : 		case STSB:
; 823  : 		case STSW:
; 824  : 		case STSD:
; 825  : 		case STSQ:
; 826  : 		{
; 827  : 			T += std::to_string(*(PLONG64)((PUCHAR)Instruction + 1));

  00302	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Instruction$[rsp]
  0030a	48 8b 50 01	 mov	 rdx, QWORD PTR [rax+1]
  0030e	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00316	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ; std::to_string
  0031b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv210[rsp], rax
  00323	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv210[rsp]
  0032b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv201[rsp], rax
  00333	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv201[rsp]
  0033b	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  00343	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
  00348	90		 npad	 1
  00349	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00351	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@SmDecodeIn:

; 828  : 			break;
; 829  : 		}
; 830  : 		default:
; 831  : 			break;
; 832  : 		}
; 833  : 	}
; 834  : 
; 835  : 	if (ReturnedSize)

  00356	48 83 bc 24 a0
	01 00 00 00	 cmp	 QWORD PTR ReturnedSize$[rsp], 0
  0035f	74 0e		 je	 SHORT $LN18@SmDecodeIn

; 836  : 		*ReturnedSize = InstructionSize;

  00361	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR ReturnedSize$[rsp]
  00369	8b 4c 24 28	 mov	 ecx, DWORD PTR InstructionSize$[rsp]
  0036d	89 08		 mov	 DWORD PTR [rax], ecx
$LN18@SmDecodeIn:

; 837  : 
; 838  : 	T += '\n';

  0036f	b2 0a		 mov	 dl, 10
  00371	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  00379	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 839  : 	return T;

  0037e	48 8d 94 24 58
	01 00 00	 lea	 rdx, QWORD PTR T$[rsp]
  00386	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0038e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00393	8b 44 24 30	 mov	 eax, DWORD PTR $T3[rsp]
  00397	83 c8 01	 or	 eax, 1
  0039a	89 44 24 30	 mov	 DWORD PTR $T3[rsp], eax
  0039e	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR T$[rsp]
  003a6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  003ab	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 840  : }

  003b3	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003bb	48 33 cc	 xor	 rcx, rsp
  003be	e8 00 00 00 00	 call	 __security_check_cookie
  003c3	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  003ca	c3		 ret	 0
  003cb	90		 npad	 1
$LN30@SmDecodeIn:
  003cc	00 00 00 00	 DD	 $LN11@SmDecodeIn
  003d0	00 00 00 00	 DD	 $LN12@SmDecodeIn
  003d4	00 00 00 00	 DD	 $LN13@SmDecodeIn
  003d8	00 00 00 00	 DD	 $LN14@SmDecodeIn
  003dc	00 00 00 00	 DD	 $LN15@SmDecodeIn
  003e0	00 00 00 00	 DD	 $LN16@SmDecodeIn
  003e4	00 00 00 00	 DD	 $LN10@SmDecodeIn
$LN29@SmDecodeIn:
  003e8	00		 DB	 0
  003e9	01		 DB	 1
  003ea	02		 DB	 2
  003eb	03		 DB	 3
  003ec	00		 DB	 0
  003ed	00		 DB	 0
  003ee	00		 DB	 0
  003ef	01		 DB	 1
  003f0	01		 DB	 1
  003f1	02		 DB	 2
  003f2	00		 DB	 0
  003f3	00		 DB	 0
  003f4	00		 DB	 0
  003f5	01		 DB	 1
  003f6	01		 DB	 1
  003f7	02		 DB	 2
  003f8	06		 DB	 6
  003f9	06		 DB	 6
  003fa	06		 DB	 6
  003fb	06		 DB	 6
  003fc	06		 DB	 6
  003fd	06		 DB	 6
  003fe	06		 DB	 6
  003ff	06		 DB	 6
  00400	06		 DB	 6
  00401	06		 DB	 6
  00402	06		 DB	 6
  00403	06		 DB	 6
  00404	06		 DB	 6
  00405	06		 DB	 6
  00406	06		 DB	 6
  00407	06		 DB	 6
  00408	06		 DB	 6
  00409	06		 DB	 6
  0040a	06		 DB	 6
  0040b	06		 DB	 6
  0040c	04		 DB	 4
  0040d	04		 DB	 4
  0040e	04		 DB	 4
  0040f	04		 DB	 4
  00410	04		 DB	 4
  00411	04		 DB	 4
  00412	04		 DB	 4
  00413	04		 DB	 4
  00414	06		 DB	 6
  00415	06		 DB	 6
  00416	06		 DB	 6
  00417	06		 DB	 6
  00418	06		 DB	 6
  00419	06		 DB	 6
  0041a	06		 DB	 6
  0041b	06		 DB	 6
  0041c	06		 DB	 6
  0041d	06		 DB	 6
  0041e	06		 DB	 6
  0041f	06		 DB	 6
  00420	06		 DB	 6
  00421	06		 DB	 6
  00422	06		 DB	 6
  00423	06		 DB	 6
  00424	06		 DB	 6
  00425	06		 DB	 6
  00426	06		 DB	 6
  00427	06		 DB	 6
  00428	06		 DB	 6
  00429	06		 DB	 6
  0042a	06		 DB	 6
  0042b	06		 DB	 6
  0042c	06		 DB	 6
  0042d	06		 DB	 6
  0042e	06		 DB	 6
  0042f	06		 DB	 6
  00430	06		 DB	 6
  00431	06		 DB	 6
  00432	06		 DB	 6
  00433	06		 DB	 6
  00434	06		 DB	 6
  00435	06		 DB	 6
  00436	06		 DB	 6
  00437	06		 DB	 6
  00438	06		 DB	 6
  00439	06		 DB	 6
  0043a	06		 DB	 6
  0043b	06		 DB	 6
  0043c	06		 DB	 6
  0043d	06		 DB	 6
  0043e	06		 DB	 6
  0043f	06		 DB	 6
  00440	06		 DB	 6
  00441	05		 DB	 5
  00442	05		 DB	 5
  00443	05		 DB	 5
  00444	05		 DB	 5
  00445	05		 DB	 5
  00446	05		 DB	 5
  00447	05		 DB	 5
  00448	05		 DB	 5
  00449	06		 DB	 6
  0044a	06		 DB	 6
  0044b	01		 DB	 1
  0044c	04		 DB	 4
  0044d	04		 DB	 4
  0044e	04		 DB	 4
  0044f	04		 DB	 4
  00450	06		 DB	 6
  00451	06		 DB	 6
  00452	06		 DB	 6
  00453	06		 DB	 6
  00454	06		 DB	 6
  00455	06		 DB	 6
  00456	06		 DB	 6
  00457	06		 DB	 6
  00458	06		 DB	 6
  00459	06		 DB	 6
  0045a	06		 DB	 6
  0045b	06		 DB	 6
  0045c	06		 DB	 6
  0045d	06		 DB	 6
  0045e	06		 DB	 6
  0045f	05		 DB	 5
  00460	05		 DB	 5
  00461	05		 DB	 5
  00462	05		 DB	 5
  00463	05		 DB	 5
  00464	05		 DB	 5
  00465	05		 DB	 5
  00466	05		 DB	 5
  00467	01		 DB	 1
  00468	01		 DB	 1
  00469	01		 DB	 1
  0046a	01		 DB	 1
  0046b	01		 DB	 1
  0046c	01		 DB	 1
  0046d	01		 DB	 1
  0046e	01		 DB	 1
?SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z ENDP ; SmDecodeInstruction
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 58 01
	00 00		 lea	 rcx, QWORD PTR T$[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T4[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d b8 00
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$3
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d d8 00
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$3
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d f8 00
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$4
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$5
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 18 01
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$5
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$6
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 38 01
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 58 01
	00 00		 lea	 rcx, QWORD PTR T$[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T4[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$1@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d b8 00
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$2@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$3
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d d8 00
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$3@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d f8 00
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$4@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$5
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 18 01
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$5@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 32
tv131 = 36
InstructionSize$ = 40
i$2 = 44
$T3 = 48
tv67 = 56
tv191 = 64
tv186 = 72
tv193 = 80
tv207 = 88
tv195 = 96
tv208 = 104
tv197 = 112
tv209 = 120
tv199 = 128
tv210 = 136
tv201 = 144
$T4 = 152
$T5 = 184
$T6 = 216
$T7 = 248
$T8 = 280
$T9 = 312
T$ = 344
__$ArrayPad$ = 376
__$ReturnUdt$ = 400
Instruction$ = 408
ReturnedSize$ = 416
?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA PROC ; `SmDecodeInstruction'::`1'::dtor$6
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 38 01
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$6@?0??SmDecodeInstruction@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAXPEAH@Z@4HA ENDP ; `SmDecodeInstruction'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmAssembleToFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
File$ = 8
?SmAssembleToFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; SmAssembleToFile, COMDAT

; 729  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 730  : 
; 731  : }

  00005	c3		 ret	 0
?SmAssembleToFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; SmAssembleToFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4470 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4471 :     return _Left._Equal(_Right);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Left$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal

; 4472 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv75 = 32
tv73 = 40
_Ostr$ = 64
_Str$ = 72
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4641 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4642 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Str$[rsp]
  00013	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00018	48 89 44 24 20	 mov	 QWORD PTR tv75[rsp], rax
  0001d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Str$[rsp]
  00022	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00027	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  0002c	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv75[rsp]
  00031	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv73[rsp]
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0003b	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>

; 4643 : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmAssembleToBlock@@YAXPEAU_SMCB@@@Z
_TEXT	SEGMENT
Instruction$1 = 32
tv78 = 40
<begin>$L0$2 = 48
<begin>$L1$3 = 56
<range>$L0$4 = 64
<range>$L1$5 = 72
Label$6 = 80
<end>$L0$7 = 88
tv88 = 96
tv135 = 104
tv150 = 112
tv164 = 120
tv177 = 128
tv188 = 136
tv197 = 144
tv195 = 152
<end>$L1$8 = 160
tv214 = 168
OPC$9 = 176
T$10 = 180
T$11 = 184
T$12 = 188
T$13 = 192
T$14 = 200
T$15 = 216
__$ArrayPad$ = 232
Block$ = 256
?SmAssembleToBlock@@YAXPEAU_SMCB@@@Z PROC		; SmAssembleToBlock, COMDAT

; 562  : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 563  : 	for (PSYMBOL Instruction : Instructions)

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?Instructions@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Instructions
  00025	48 89 44 24 40	 mov	 QWORD PTR <range>$L0$4[rsp], rax
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR <range>$L0$4[rsp]
  0002f	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_begin
  00034	48 89 44 24 30	 mov	 QWORD PTR <begin>$L0$2[rsp], rax
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR <range>$L0$4[rsp]
  0003e	e8 00 00 00 00	 call	 ?_Unchecked_end@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_end
  00043	48 89 44 24 58	 mov	 QWORD PTR <end>$L0$7[rsp], rax
  00048	eb 0e		 jmp	 SHORT $LN4@SmAssemble
$LN2@SmAssemble:
  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR <begin>$L0$2[rsp]
  0004f	48 83 c0 08	 add	 rax, 8
  00053	48 89 44 24 30	 mov	 QWORD PTR <begin>$L0$2[rsp], rax
$LN4@SmAssemble:
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR <end>$L0$7[rsp]
  0005d	48 39 44 24 30	 cmp	 QWORD PTR <begin>$L0$2[rsp], rax
  00062	0f 84 de 03 00
	00		 je	 $LN3@SmAssemble
  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR <begin>$L0$2[rsp]
  0006d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00070	48 89 44 24 20	 mov	 QWORD PTR Instruction$1[rsp], rax

; 564  : 	{
; 565  : 		if (Instruction->InstructionSize == 1)

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  0007a	83 78 0c 01	 cmp	 DWORD PTR [rax+12], 1
  0007e	75 30		 jne	 SHORT $LN10@SmAssemble

; 566  : 		{
; 567  : 			UCHAR OPC = Instruction->OpCode;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  00085	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00089	88 84 24 b0 00
	00 00		 mov	 BYTE PTR OPC$9[rsp], al

; 568  : 			SmPushBackBlock(Block, &OPC, 1);

  00090	41 b8 01 00 00
	00		 mov	 r8d, 1
  00096	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR OPC$9[rsp]
  0009e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  000a6	e8 00 00 00 00	 call	 ?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z ; SmPushBackBlock

; 569  : 		}

  000ab	e9 91 03 00 00	 jmp	 $LN11@SmAssemble
$LN10@SmAssemble:

; 570  : 		else
; 571  : 		{
; 572  : 			switch (Instruction->OpCode)

  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  000b5	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000b9	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
  000bd	8b 44 24 28	 mov	 eax, DWORD PTR tv78[rsp]
  000c1	83 e8 03	 sub	 eax, 3
  000c4	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
  000c8	81 7c 24 28 86
	00 00 00	 cmp	 DWORD PTR tv78[rsp], 134 ; 00000086H
  000d0	0f 87 6b 03 00
	00		 ja	 $LN20@SmAssemble
  000d6	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv78[rsp]
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000e2	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN22@SmAssemble[rcx+rax]
  000ea	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN23@SmAssemble[rcx+rax*4]
  000f1	48 03 c1	 add	 rax, rcx
  000f4	ff e0		 jmp	 rax
$LN12@SmAssemble:

; 573  : 			{
; 574  : 			case LDIB:
; 575  : 			case LDIBSXW:
; 576  : 			case LDIBSXD:
; 577  : 			case LDIBSXQ:
; 578  : 			case LDIBZXW:
; 579  : 			case LDIBZXD:
; 580  : 			case LDIBZXQ:
; 581  : 			{
; 582  : #pragma pack(push, 1)
; 583  : 				struct
; 584  : 				{
; 585  : 					UCHAR v1;
; 586  : 					CHAR v2;
; 587  : 				}T;
; 588  : #pragma pack(pop)
; 589  : 				T.v1 = Instruction->OpCode;

  000f6	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  000fb	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000ff	88 84 24 b4 00
	00 00		 mov	 BYTE PTR T$10[rsp], al

; 590  : 				T.v2 = std::stoi(Instruction->Ele[1]);

  00106	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  0010b	48 83 c0 30	 add	 rax, 48			; 00000030H
  0010f	48 89 44 24 60	 mov	 QWORD PTR tv88[rsp], rax
  00114	ba 01 00 00 00	 mov	 edx, 1
  00119	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv88[rsp]
  0011e	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  00123	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00129	33 d2		 xor	 edx, edx
  0012b	48 8b c8	 mov	 rcx, rax
  0012e	e8 00 00 00 00	 call	 ?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
  00133	88 84 24 b5 00
	00 00		 mov	 BYTE PTR T$10[rsp+1], al

; 591  : 				SmPushBackBlock(Block, &T, 2);

  0013a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00140	48 8d 94 24 b4
	00 00 00	 lea	 rdx, QWORD PTR T$10[rsp]
  00148	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  00150	e8 00 00 00 00	 call	 ?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z ; SmPushBackBlock

; 592  : 				break;

  00155	e9 e7 02 00 00	 jmp	 $LN5@SmAssemble
$LN13@SmAssemble:

; 593  : 			}
; 594  : 			case LDIW:
; 595  : 			case EDITSP:
; 596  : 			case LDIWSXD:
; 597  : 			case LDIWSXQ:
; 598  : 			case LDIWZXD:
; 599  : 			case LDIWZXQ:
; 600  : 			case LDBPB:
; 601  : 			case LDBPW:
; 602  : 			case LDBPD:
; 603  : 			case LDBPQ:
; 604  : 			case STBPB:
; 605  : 			case STBPW:
; 606  : 			case STBPD:
; 607  : 			case STBPQ:
; 608  : 			{
; 609  : #pragma pack(push, 1)
; 610  : 				struct
; 611  : 				{
; 612  : 					UCHAR v1;
; 613  : 					SHORT v2;
; 614  : 				}T;
; 615  : #pragma pack(pop)
; 616  : 				T.v1 = Instruction->OpCode;

  0015a	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  0015f	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00163	88 84 24 bc 00
	00 00		 mov	 BYTE PTR T$12[rsp], al

; 617  : 				T.v2 = std::stoi(Instruction->Ele[1]);

  0016a	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  0016f	48 83 c0 30	 add	 rax, 48			; 00000030H
  00173	48 89 44 24 68	 mov	 QWORD PTR tv135[rsp], rax
  00178	ba 01 00 00 00	 mov	 edx, 1
  0017d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv135[rsp]
  00182	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  00187	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0018d	33 d2		 xor	 edx, edx
  0018f	48 8b c8	 mov	 rcx, rax
  00192	e8 00 00 00 00	 call	 ?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
  00197	66 89 84 24 bd
	00 00 00	 mov	 WORD PTR T$12[rsp+1], ax

; 618  : 				SmPushBackBlock(Block, &T, 3);

  0019f	41 b8 03 00 00
	00		 mov	 r8d, 3
  001a5	48 8d 94 24 bc
	00 00 00	 lea	 rdx, QWORD PTR T$12[rsp]
  001ad	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  001b5	e8 00 00 00 00	 call	 ?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z ; SmPushBackBlock

; 619  : 				break;

  001ba	e9 82 02 00 00	 jmp	 $LN5@SmAssemble
$LN14@SmAssemble:

; 620  : 			}
; 621  : 			case LDID:
; 622  : 			case LDIDSXQ:
; 623  : 			case LDIDZXQ:
; 624  : 			{
; 625  : #pragma pack(push, 1)
; 626  : 				struct
; 627  : 				{
; 628  : 					UCHAR v1;
; 629  : 					INT v2;
; 630  : 				}T;
; 631  : #pragma pack(pop)
; 632  : 				T.v1 = Instruction->OpCode;

  001bf	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  001c4	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001c8	88 84 24 c0 00
	00 00		 mov	 BYTE PTR T$13[rsp], al

; 633  : 				T.v2 = std::stoi(Instruction->Ele[1]);

  001cf	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  001d4	48 83 c0 30	 add	 rax, 48			; 00000030H
  001d8	48 89 44 24 70	 mov	 QWORD PTR tv150[rsp], rax
  001dd	ba 01 00 00 00	 mov	 edx, 1
  001e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv150[rsp]
  001e7	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  001ec	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001f2	33 d2		 xor	 edx, edx
  001f4	48 8b c8	 mov	 rcx, rax
  001f7	e8 00 00 00 00	 call	 ?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
  001fc	89 84 24 c1 00
	00 00		 mov	 DWORD PTR T$13[rsp+1], eax

; 634  : 				SmPushBackBlock(Block, &T, 5);

  00203	41 b8 05 00 00
	00		 mov	 r8d, 5
  00209	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR T$13[rsp]
  00211	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  00219	e8 00 00 00 00	 call	 ?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z ; SmPushBackBlock

; 635  : 				break;

  0021e	e9 1e 02 00 00	 jmp	 $LN5@SmAssemble
$LN15@SmAssemble:

; 636  : 			}
; 637  : 			case LDIQ:
; 638  : 			case LDSB:
; 639  : 			case LDSW:
; 640  : 			case LDSD:
; 641  : 			case LDSQ:
; 642  : 			case STSB:
; 643  : 			case STSW:
; 644  : 			case STSD:
; 645  : 			case STSQ:
; 646  : 			{
; 647  : #pragma pack(push, 1)
; 648  : 				struct
; 649  : 				{
; 650  : 					UCHAR v1;
; 651  : 					LONG64 v2;
; 652  : 				}T;
; 653  : #pragma pack(pop)
; 654  : 				T.v1 = Instruction->OpCode;

  00223	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  00228	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0022c	88 84 24 c8 00
	00 00		 mov	 BYTE PTR T$14[rsp], al

; 655  : 				T.v2 = std::stoll(Instruction->Ele[1]);

  00233	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  00238	48 83 c0 30	 add	 rax, 48			; 00000030H
  0023c	48 89 44 24 78	 mov	 QWORD PTR tv164[rsp], rax
  00241	ba 01 00 00 00	 mov	 edx, 1
  00246	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv164[rsp]
  0024b	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  00250	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00256	33 d2		 xor	 edx, edx
  00258	48 8b c8	 mov	 rcx, rax
  0025b	e8 00 00 00 00	 call	 ?stoll@std@@YA_JAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoll
  00260	48 89 84 24 c9
	00 00 00	 mov	 QWORD PTR T$14[rsp+1], rax

; 656  : 				SmPushBackBlock(Block, &T, 9);

  00268	41 b8 09 00 00
	00		 mov	 r8d, 9
  0026e	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR T$14[rsp]
  00276	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  0027e	e8 00 00 00 00	 call	 ?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z ; SmPushBackBlock

; 657  : 				break;

  00283	e9 b9 01 00 00	 jmp	 $LN5@SmAssemble
$LN16@SmAssemble:

; 658  : 			}
; 659  : 			case POPB:
; 660  : 			case POPW:
; 661  : 			case POPD:
; 662  : 			case POPQ:
; 663  : 			case PUSHB:
; 664  : 			case PUSHW:
; 665  : 			case PUSHD:
; 666  : 			case PUSHQ:
; 667  : 			case STSP:
; 668  : 			case LDSP:
; 669  : 			case STIP:
; 670  : 			case LDIP:
; 671  : 			{
; 672  : #pragma pack(push, 1)
; 673  : 				struct
; 674  : 				{
; 675  : 					UCHAR v1;
; 676  : 					UCHAR v2;
; 677  : 				}T;
; 678  : #pragma pack(pop)
; 679  : 				T.v1 = Instruction->OpCode;

  00288	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  0028d	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00291	88 84 24 b8 00
	00 00		 mov	 BYTE PTR T$11[rsp], al

; 680  : 				//Instruction->Ele[1].erase(0, 1);
; 681  : 				//std::cout << "\n\n\n\n breaking \n\'" << Instruction->Ele[1] << "\'\n\n\n\n\n";
; 682  : 				if (!SmGetRegisterId(Instruction->Ele[1], &T.v2)) // T.v2 = (UCHAR)std::stoi(Instruction->Ele[1]);

  00298	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  0029d	48 83 c0 30	 add	 rax, 48			; 00000030H
  002a1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  002a9	ba 01 00 00 00	 mov	 edx, 1
  002ae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv177[rsp]
  002b6	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  002bb	48 8d 94 24 b9
	00 00 00	 lea	 rdx, QWORD PTR T$11[rsp+1]
  002c3	48 8b c8	 mov	 rcx, rax
  002c6	e8 00 00 00 00	 call	 ?SmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ; SmGetRegisterId
  002cb	85 c0		 test	 eax, eax
  002cd	75 6f		 jne	 SHORT $LN17@SmAssemble

; 683  : 				{
; 684  : 					std::cout << "bad register \"" << Instruction->Ele[1] << "\"\n";

  002cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG134124
  002d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002dd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002e2	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv195[rsp], rax
  002ea	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  002ef	48 83 c0 30	 add	 rax, 48			; 00000030H
  002f3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv188[rsp], rax
  002fb	ba 01 00 00 00	 mov	 edx, 1
  00300	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv188[rsp]
  00308	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  0030d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv197[rsp], rax
  00315	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv197[rsp]
  0031d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv195[rsp]
  00325	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  0032a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG134123
  00331	48 8b c8	 mov	 rcx, rax
  00334	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 685  : 					return;

  00339	e9 08 01 00 00	 jmp	 $LN1@SmAssemble
$LN17@SmAssemble:

; 686  : 				}
; 687  : 				SmPushBackBlock(Block, &T, 2);

  0033e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00344	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR T$11[rsp]
  0034c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  00354	e8 00 00 00 00	 call	 ?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z ; SmPushBackBlock

; 688  : 				break;

  00359	e9 e3 00 00 00	 jmp	 $LN5@SmAssemble
$LN18@SmAssemble:

; 689  : 			}
; 690  : 			case JMPI:
; 691  : 			case JL:
; 692  : 			case JLE:
; 693  : 			case JG:
; 694  : 			case JGE:
; 695  : 			case JZ:
; 696  : 			case JNZ:
; 697  : 			case CALL:
; 698  : 			{
; 699  : #pragma pack(push, 1)
; 700  : 				struct
; 701  : 				{
; 702  : 					UCHAR v1;
; 703  : 					LONG64 v2;
; 704  : 				}T;
; 705  : #pragma pack(pop)
; 706  : 				T.v1 = Instruction->OpCode;

  0035e	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  00363	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00367	88 84 24 d8 00
	00 00		 mov	 BYTE PTR T$15[rsp], al

; 707  : 
; 708  : 				for (PSYMBOL Label : Labels)

  0036e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?Labels@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Labels
  00375	48 89 44 24 48	 mov	 QWORD PTR <range>$L1$5[rsp], rax
  0037a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR <range>$L1$5[rsp]
  0037f	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_begin
  00384	48 89 44 24 38	 mov	 QWORD PTR <begin>$L1$3[rsp], rax
  00389	48 8b 4c 24 48	 mov	 rcx, QWORD PTR <range>$L1$5[rsp]
  0038e	e8 00 00 00 00	 call	 ?_Unchecked_end@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_end
  00393	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR <end>$L1$8[rsp], rax
  0039b	eb 0e		 jmp	 SHORT $LN9@SmAssemble
$LN7@SmAssemble:
  0039d	48 8b 44 24 38	 mov	 rax, QWORD PTR <begin>$L1$3[rsp]
  003a2	48 83 c0 08	 add	 rax, 8
  003a6	48 89 44 24 38	 mov	 QWORD PTR <begin>$L1$3[rsp], rax
$LN9@SmAssemble:
  003ab	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR <end>$L1$8[rsp]
  003b3	48 39 44 24 38	 cmp	 QWORD PTR <begin>$L1$3[rsp], rax
  003b8	74 6c		 je	 SHORT $LN8@SmAssemble
  003ba	48 8b 44 24 38	 mov	 rax, QWORD PTR <begin>$L1$3[rsp]
  003bf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c2	48 89 44 24 50	 mov	 QWORD PTR Label$6[rsp], rax

; 709  : 				{
; 710  : 					if (Label->Line == Instruction->Ele[1])

  003c7	48 8b 44 24 20	 mov	 rax, QWORD PTR Instruction$1[rsp]
  003cc	48 83 c0 30	 add	 rax, 48			; 00000030H
  003d0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
  003d8	ba 01 00 00 00	 mov	 edx, 1
  003dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv214[rsp]
  003e5	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  003ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Label$6[rsp]
  003ef	48 83 c1 10	 add	 rcx, 16
  003f3	48 8b d0	 mov	 rdx, rax
  003f6	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003fb	0f b6 c0	 movzx	 eax, al
  003fe	85 c0		 test	 eax, eax
  00400	74 1f		 je	 SHORT $LN19@SmAssemble

; 711  : 					{
; 712  : 						T.v2 = (LONG64)Label->Offset - (LONG64)Instruction->Offset;

  00402	48 8b 44 24 50	 mov	 rax, QWORD PTR Label$6[rsp]
  00407	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  0040b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Instruction$1[rsp]
  00410	48 63 49 08	 movsxd	 rcx, DWORD PTR [rcx+8]
  00414	48 2b c1	 sub	 rax, rcx
  00417	48 89 84 24 d9
	00 00 00	 mov	 QWORD PTR T$15[rsp+1], rax

; 713  : 						//std::cout << (LONG64)Label->Offset - (LONG64)Instruction->Offset << " IS THE VALUE\n";
; 714  : 						break;

  0041f	eb 05		 jmp	 SHORT $LN8@SmAssemble
$LN19@SmAssemble:

; 715  : 					}
; 716  : 				}

  00421	e9 77 ff ff ff	 jmp	 $LN7@SmAssemble
$LN8@SmAssemble:

; 717  : 
; 718  : 				SmPushBackBlock(Block, &T, 9);

  00426	41 b8 09 00 00
	00		 mov	 r8d, 9
  0042c	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR T$15[rsp]
  00434	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Block$[rsp]
  0043c	e8 00 00 00 00	 call	 ?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z ; SmPushBackBlock
$LN20@SmAssemble:
$LN5@SmAssemble:
$LN11@SmAssemble:

; 719  : 				break;
; 720  : 			}
; 721  : 			default:
; 722  : 				break;
; 723  : 			}
; 724  : 		}
; 725  : 	}

  00441	e9 04 fc ff ff	 jmp	 $LN2@SmAssemble
$LN3@SmAssemble:
$LN1@SmAssemble:

; 726  : }

  00446	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0044e	48 33 cc	 xor	 rcx, rsp
  00451	e8 00 00 00 00	 call	 __security_check_cookie
  00456	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0045d	c3		 ret	 0
  0045e	66 90		 npad	 2
$LN23@SmAssemble:
  00460	00 00 00 00	 DD	 $LN12@SmAssemble
  00464	00 00 00 00	 DD	 $LN13@SmAssemble
  00468	00 00 00 00	 DD	 $LN14@SmAssemble
  0046c	00 00 00 00	 DD	 $LN15@SmAssemble
  00470	00 00 00 00	 DD	 $LN16@SmAssemble
  00474	00 00 00 00	 DD	 $LN18@SmAssemble
  00478	00 00 00 00	 DD	 $LN20@SmAssemble
$LN22@SmAssemble:
  0047c	00		 DB	 0
  0047d	01		 DB	 1
  0047e	02		 DB	 2
  0047f	03		 DB	 3
  00480	00		 DB	 0
  00481	00		 DB	 0
  00482	00		 DB	 0
  00483	01		 DB	 1
  00484	01		 DB	 1
  00485	02		 DB	 2
  00486	00		 DB	 0
  00487	00		 DB	 0
  00488	00		 DB	 0
  00489	01		 DB	 1
  0048a	01		 DB	 1
  0048b	02		 DB	 2
  0048c	06		 DB	 6
  0048d	06		 DB	 6
  0048e	06		 DB	 6
  0048f	06		 DB	 6
  00490	06		 DB	 6
  00491	06		 DB	 6
  00492	06		 DB	 6
  00493	06		 DB	 6
  00494	06		 DB	 6
  00495	06		 DB	 6
  00496	06		 DB	 6
  00497	06		 DB	 6
  00498	06		 DB	 6
  00499	06		 DB	 6
  0049a	06		 DB	 6
  0049b	06		 DB	 6
  0049c	06		 DB	 6
  0049d	06		 DB	 6
  0049e	06		 DB	 6
  0049f	06		 DB	 6
  004a0	04		 DB	 4
  004a1	04		 DB	 4
  004a2	04		 DB	 4
  004a3	04		 DB	 4
  004a4	04		 DB	 4
  004a5	04		 DB	 4
  004a6	04		 DB	 4
  004a7	04		 DB	 4
  004a8	06		 DB	 6
  004a9	06		 DB	 6
  004aa	06		 DB	 6
  004ab	06		 DB	 6
  004ac	06		 DB	 6
  004ad	06		 DB	 6
  004ae	06		 DB	 6
  004af	06		 DB	 6
  004b0	06		 DB	 6
  004b1	06		 DB	 6
  004b2	06		 DB	 6
  004b3	06		 DB	 6
  004b4	06		 DB	 6
  004b5	06		 DB	 6
  004b6	06		 DB	 6
  004b7	06		 DB	 6
  004b8	06		 DB	 6
  004b9	06		 DB	 6
  004ba	06		 DB	 6
  004bb	06		 DB	 6
  004bc	06		 DB	 6
  004bd	06		 DB	 6
  004be	06		 DB	 6
  004bf	06		 DB	 6
  004c0	06		 DB	 6
  004c1	06		 DB	 6
  004c2	06		 DB	 6
  004c3	06		 DB	 6
  004c4	06		 DB	 6
  004c5	06		 DB	 6
  004c6	06		 DB	 6
  004c7	06		 DB	 6
  004c8	06		 DB	 6
  004c9	06		 DB	 6
  004ca	06		 DB	 6
  004cb	06		 DB	 6
  004cc	06		 DB	 6
  004cd	06		 DB	 6
  004ce	06		 DB	 6
  004cf	06		 DB	 6
  004d0	06		 DB	 6
  004d1	06		 DB	 6
  004d2	06		 DB	 6
  004d3	06		 DB	 6
  004d4	06		 DB	 6
  004d5	05		 DB	 5
  004d6	05		 DB	 5
  004d7	05		 DB	 5
  004d8	05		 DB	 5
  004d9	05		 DB	 5
  004da	05		 DB	 5
  004db	05		 DB	 5
  004dc	05		 DB	 5
  004dd	06		 DB	 6
  004de	06		 DB	 6
  004df	01		 DB	 1
  004e0	04		 DB	 4
  004e1	04		 DB	 4
  004e2	04		 DB	 4
  004e3	04		 DB	 4
  004e4	06		 DB	 6
  004e5	06		 DB	 6
  004e6	06		 DB	 6
  004e7	06		 DB	 6
  004e8	06		 DB	 6
  004e9	06		 DB	 6
  004ea	06		 DB	 6
  004eb	06		 DB	 6
  004ec	06		 DB	 6
  004ed	06		 DB	 6
  004ee	06		 DB	 6
  004ef	06		 DB	 6
  004f0	06		 DB	 6
  004f1	06		 DB	 6
  004f2	06		 DB	 6
  004f3	03		 DB	 3
  004f4	03		 DB	 3
  004f5	03		 DB	 3
  004f6	03		 DB	 3
  004f7	03		 DB	 3
  004f8	03		 DB	 3
  004f9	03		 DB	 3
  004fa	03		 DB	 3
  004fb	01		 DB	 1
  004fc	01		 DB	 1
  004fd	01		 DB	 1
  004fe	01		 DB	 1
  004ff	01		 DB	 1
  00500	01		 DB	 1
  00501	01		 DB	 1
  00502	01		 DB	 1
?SmAssembleToBlock@@YAXPEAU_SMCB@@@Z ENDP		; SmAssembleToBlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmParseLoadedFile@@YAXXZ
_TEXT	SEGMENT
i$1 = 32
Offset$ = 36
tv167 = 40
tv67 = 48
tv138 = 56
tv143 = 64
tv141 = 72
$T2 = 80
$T3 = 88
?SmParseLoadedFile@@YAXXZ PROC				; SmParseLoadedFile, COMDAT

; 533  : {

$LN10:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 534  : 	Labels.clear();

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Labels@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Labels
  0000b	e8 00 00 00 00	 call	 ?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::clear

; 535  : 	Instructions.clear();

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Instructions@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Instructions
  00017	e8 00 00 00 00	 call	 ?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::clear

; 536  : 	INT Offset = 0;

  0001c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR Offset$[rsp], 0

; 537  : 	for (INT i = 0; i < Symbols.size(); i++)

  00024	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0002c	eb 0a		 jmp	 SHORT $LN4@SmParseLoa
$LN2@SmParseLoa:
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00032	ff c0		 inc	 eax
  00034	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@SmParseLoa:
  00038	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0003d	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  00049	e8 00 00 00 00	 call	 ?size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::size
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv67[rsp]
  00053	48 3b c8	 cmp	 rcx, rax
  00056	0f 83 a9 01 00
	00		 jae	 $LN3@SmParseLoa

; 538  : 	{
; 539  : 		/*std::cout << Offset << "\t" << Symbols[i].Line << '\n';
; 540  : 		for (std::string str : Symbols[i].Ele)
; 541  : 			std::cout << '\'' << str << '\'' << '\n';*/
; 542  : 		Symbols[i].Offset = Offset;

  0005c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  0006b	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  00070	8b 4c 24 24	 mov	 ecx, DWORD PTR Offset$[rsp]
  00074	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 543  : 		if (!Symbols[i].IsLabel)

  00077	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0007c	48 8b d0	 mov	 rdx, rax
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  00086	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  0008b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0008e	0f 85 42 01 00
	00		 jne	 $LN5@SmParseLoa

; 544  : 		{
; 545  : 			if (!Symbols[i].Ele.size() || !SmGetOpCode(Symbols[i].Ele[0], &Symbols[i].OpCode))

  00094	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00099	48 8b d0	 mov	 rdx, rax
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  000a3	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  000a8	48 83 c0 30	 add	 rax, 48			; 00000030H
  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  000b4	48 85 c0	 test	 rax, rax
  000b7	74 5e		 je	 SHORT $LN8@SmParseLoa
  000b9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  000be	48 8b d0	 mov	 rdx, rax
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  000c8	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  000cd	48 83 c0 04	 add	 rax, 4
  000d1	48 89 44 24 40	 mov	 QWORD PTR tv143[rsp], rax
  000d6	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  000db	48 8b d0	 mov	 rdx, rax
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  000e5	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  000ea	48 83 c0 30	 add	 rax, 48			; 00000030H
  000ee	48 89 44 24 38	 mov	 QWORD PTR tv138[rsp], rax
  000f3	33 d2		 xor	 edx, edx
  000f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv138[rsp]
  000fa	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  000ff	48 89 44 24 48	 mov	 QWORD PTR tv141[rsp], rax
  00104	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv143[rsp]
  00109	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv141[rsp]
  0010e	e8 00 00 00 00	 call	 ?SmGetOpCode@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ; SmGetOpCode
  00113	85 c0		 test	 eax, eax
  00115	75 34		 jne	 SHORT $LN7@SmParseLoa
$LN8@SmParseLoa:

; 546  : 			{
; 547  : 				printf("Failed to get opcode for line %s.\n", Symbols[i].Line.c_str());

  00117	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0011c	48 8b d0	 mov	 rdx, rax
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  00126	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  0012b	48 83 c0 10	 add	 rax, 16
  0012f	48 8b c8	 mov	 rcx, rax
  00132	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00137	48 8b d0	 mov	 rdx, rax
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG133954
  00141	e8 00 00 00 00	 call	 printf

; 548  : 				return;

  00146	e9 ba 00 00 00	 jmp	 $LN1@SmParseLoa
$LN7@SmParseLoa:

; 549  : 			}
; 550  : 			Symbols[i].InstructionSize = SmGetInstructionSize(Symbols[i].OpCode);

  0014b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00150	48 8b d0	 mov	 rdx, rax
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  0015a	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  0015f	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00163	e8 00 00 00 00	 call	 ?SmGetInstructionSize@@YAHE@Z ; SmGetInstructionSize
  00168	89 44 24 28	 mov	 DWORD PTR tv167[rsp], eax
  0016c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00171	48 8b d0	 mov	 rdx, rax
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  0017b	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  00180	8b 4c 24 28	 mov	 ecx, DWORD PTR tv167[rsp]
  00184	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 551  : 			Instructions.push_back(&Symbols[i]);

  00187	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0018c	48 8b d0	 mov	 rdx, rax
  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  00196	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  0019b	48 89 44 24 50	 mov	 QWORD PTR $T2[rsp], rax
  001a0	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Instructions@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Instructions
  001ac	e8 00 00 00 00	 call	 ?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::push_back

; 552  : 			Offset += Symbols[i].InstructionSize;

  001b1	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  001b6	48 8b d0	 mov	 rdx, rax
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  001c0	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  001c5	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  001c8	8b 4c 24 24	 mov	 ecx, DWORD PTR Offset$[rsp]
  001cc	03 c8		 add	 ecx, eax
  001ce	8b c1		 mov	 eax, ecx
  001d0	89 44 24 24	 mov	 DWORD PTR Offset$[rsp], eax

; 553  : 		}

  001d4	eb 2a		 jmp	 SHORT $LN6@SmParseLoa
$LN5@SmParseLoa:

; 554  : 		else
; 555  : 		{
; 556  : 			Labels.push_back(&Symbols[i]);

  001d6	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  001db	48 8b d0	 mov	 rdx, rax
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  001e5	e8 00 00 00 00	 call	 ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
  001ea	48 89 44 24 58	 mov	 QWORD PTR $T3[rsp], rax
  001ef	48 8d 54 24 58	 lea	 rdx, QWORD PTR $T3[rsp]
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Labels@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Labels
  001fb	e8 00 00 00 00	 call	 ?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::push_back
$LN6@SmParseLoa:

; 557  : 		}
; 558  : 	}

  00200	e9 29 fe ff ff	 jmp	 $LN2@SmParseLoa
$LN3@SmParseLoa:
$LN1@SmParseLoa:

; 559  : }

  00205	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00209	c3		 ret	 0
?SmParseLoadedFile@@YAXXZ ENDP				; SmParseLoadedFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv139 = 120
tv137 = 128
tv135 = 136
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
<_Val_1>$ = 184
??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_reallocate<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  0001b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00023	e8 00 00 00 00	 call	 ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
  00028	48 89 44 24 48	 mov	 QWORD PTR _Al$[rsp], rax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  0002d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 89 44 24 58	 mov	 QWORD PTR _My_data$[rsp], rax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  0003a	48 8b 44 24 58	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003f	48 89 44 24 30	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  00044	48 8b 44 24 58	 mov	 rax, QWORD PTR _My_data$[rsp]
  00049	48 83 c0 08	 add	 rax, 8
  0004d	48 89 44 24 38	 mov	 QWORD PTR _Mylast$[rsp], rax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00057	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _Whereptr$[rsp]
  00062	48 2b c8	 sub	 rcx, rax
  00065	48 8b c1	 mov	 rax, rcx
  00068	48 99		 cdq
  0006a	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0006f	48 f7 f9	 idiv	 rcx
  00072	48 89 44 24 28	 mov	 QWORD PTR _Whereoff$[rsp], rax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00077	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00081	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00084	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00087	48 2b c1	 sub	 rax, rcx
  0008a	48 99		 cdq
  0008c	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00091	48 f7 f9	 idiv	 rcx
  00094	48 89 44 24 60	 mov	 QWORD PTR _Oldsize$[rsp], rax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00099	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000a1	e8 00 00 00 00	 call	 ?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::max_size
  000a6	48 39 44 24 60	 cmp	 QWORD PTR _Oldsize$[rsp], rax
  000ab	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000ad	e8 00 00 00 00	 call	 ?_Xlength@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@CAXXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000b2	48 8b 44 24 60	 mov	 rax, QWORD PTR _Oldsize$[rsp]
  000b7	48 ff c0	 inc	 rax
  000ba	48 89 44 24 70	 mov	 QWORD PTR _Newsize$[rsp], rax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000bf	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Newsize$[rsp]
  000c4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000cc	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBA_K_K@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Calculate_growth
  000d1	48 89 44 24 50	 mov	 QWORD PTR _Newcapacity$[rsp], rax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000d6	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Newcapacity$[rsp]
  000db	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Al$[rsp]
  000e0	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_SYMBOL@@@std@@QEAAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL>::allocate
  000e5	48 89 44 24 20	 mov	 QWORD PTR _Newvec$[rsp], rax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000ea	48 6b 44 24 28
	48		 imul	 rax, QWORD PTR _Whereoff$[rsp], 72 ; 00000048H
  000f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  000f5	48 8d 44 01 48	 lea	 rax, QWORD PTR [rcx+rax+72]
  000fa	48 89 44 24 68	 mov	 QWORD PTR _Constructed_last$[rsp], rax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000ff	48 8b 44 24 68	 mov	 rax, QWORD PTR _Constructed_last$[rsp]
  00104	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 747  : 
; 748  :         _TRY_BEGIN
; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00109	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR <_Val_1>$[rsp]
  00111	e8 00 00 00 00	 call	 ??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00116	48 89 44 24 78	 mov	 QWORD PTR tv139[rsp], rax
  0011b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  00123	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QEAHAEAH@Z ; std::forward<int>
  00128	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv137[rsp], rax
  00130	48 6b 44 24 28
	48		 imul	 rax, QWORD PTR _Whereoff$[rsp], 72 ; 00000048H
  00136	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  0013b	48 03 c8	 add	 rcx, rax
  0013e	48 8b c1	 mov	 rax, rcx
  00141	48 8b c8	 mov	 rcx, rax
  00144	e8 00 00 00 00	 call	 ??$_Unfancy@U_SYMBOL@@@std@@YAPEAU_SYMBOL@@PEAU1@@Z ; std::_Unfancy<_SYMBOL>
  00149	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  00151	4c 8b 4c 24 78	 mov	 r9, QWORD PTR tv139[rsp]
  00156	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR tv137[rsp]
  0015e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv135[rsp]
  00166	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Al$[rsp]
  0016b	e8 00 00 00 00	 call	 ??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00170	48 6b 44 24 28
	48		 imul	 rax, QWORD PTR _Whereoff$[rsp], 72 ; 00000048H
  00176	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  0017b	48 03 c8	 add	 rcx, rax
  0017e	48 8b c1	 mov	 rax, rcx
  00181	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00186	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0018b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0018e	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR _Whereptr$[rsp], rax
  00196	75 24		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00198	4c 8b 4c 24 20	 mov	 r9, QWORD PTR _Newvec$[rsp]
  0019d	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  001a2	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  001aa	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001b5	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  001ba	eb 5d		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001bc	4c 8b 4c 24 20	 mov	 r9, QWORD PTR _Newvec$[rsp]
  001c1	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR _Whereptr$[rsp]
  001c9	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  001ce	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001d9	e8 00 00 00 00	 call	 ?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove

; 756  :             _Constructed_first = _Newvec;

  001de	48 8b 44 24 20	 mov	 rax, QWORD PTR _Newvec$[rsp]
  001e3	48 89 44 24 40	 mov	 QWORD PTR _Constructed_first$[rsp], rax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e8	48 6b 44 24 28
	48		 imul	 rax, QWORD PTR _Whereoff$[rsp], 72 ; 00000048H
  001ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  001f3	48 8d 44 01 48	 lea	 rax, QWORD PTR [rcx+rax+72]
  001f8	4c 8b c8	 mov	 r9, rax
  001fb	48 8b 44 24 38	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00200	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00203	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR _Whereptr$[rsp]
  0020b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00213	e8 00 00 00 00	 call	 ?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove
  00218	90		 npad	 1
$LN5@Emplace_re:
  00219	eb 00		 jmp	 SHORT $LN9@Emplace_re
$LN10@Emplace_re:
$LN9@Emplace_re:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  0021b	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Newcapacity$[rsp]
  00220	4c 8b 44 24 70	 mov	 r8, QWORD PTR _Newsize$[rsp]
  00225	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Newvec$[rsp]
  0022a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00232	e8 00 00 00 00	 call	 ?_Change_array@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXQEAU_SYMBOL@@_K1@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00237	48 6b 44 24 28
	48		 imul	 rax, QWORD PTR _Whereoff$[rsp], 72 ; 00000048H
  0023d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  00242	48 03 c8	 add	 rcx, rax
  00245	48 8b c1	 mov	 rax, rcx

; 767  :     }

  00248	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0024f	c3		 ret	 0
$LN11@Emplace_re:
??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_reallocate<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv139 = 120
tv137 = 128
tv135 = 136
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
<_Val_1>$ = 184
?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_reallocate<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::catch$0

; 758  :         }
; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 45 68	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00011	48 8b 55 40	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00015	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Destroy

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00021	4c 8b 45 50	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00025	48 8b 55 20	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00029	48 8b 4d 48	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL>::deallocate

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;

  00032	33 d2		 xor	 edx, edx
  00034	33 c9		 xor	 ecx, ecx
  00036	e8 00 00 00 00	 call	 _CxxThrowException
  0003b	90		 npad	 1

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, $LN10@catch$0
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
  00049	cc		 int	 3
?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_reallocate<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Whereoff$ = 40
_Myfirst$ = 48
_Mylast$ = 56
_Constructed_first$ = 64
_Al$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv139 = 120
tv137 = 128
tv135 = 136
this$ = 160
_Whereptr$ = 168
<_Val_0>$ = 176
<_Val_1>$ = 184
?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_reallocate<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::catch$0

; 759  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:

; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 45 68	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00011	48 8b 55 40	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00015	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00021	4c 8b 45 50	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00025	48 8b 55 20	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00029	48 8b 4d 48	 mov	 rcx, QWORD PTR _Al$[rbp]
  0002d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL>::deallocate

; 762  :         _RERAISE;

  00032	33 d2		 xor	 edx, edx
  00034	33 c9		 xor	 ecx, ecx
  00036	e8 00 00 00 00	 call	 _CxxThrowException
  0003b	90		 npad	 1

; 763  :         _CATCH_END

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, $LN10@catch$0
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
  00049	cc		 int	 3
?catch$0@?0???$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_reallocate<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv79 = 32
tv81 = 40
$T1 = 48
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
<_Args_1>$ = 104
??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  0001d	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00027	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  0002c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR <_Args_1>$[rsp]
  00031	e8 00 00 00 00	 call	 ??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00036	48 89 44 24 28	 mov	 QWORD PTR tv81[rsp], rax
  0003b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  00040	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QEAHAEAH@Z ; std::forward<int>
  00045	8b 00		 mov	 eax, DWORD PTR [rax]
  00047	89 44 24 20	 mov	 DWORD PTR tv79[rsp], eax
  0004b	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv81[rsp]
  00050	8b 54 24 20	 mov	 edx, DWORD PTR tv79[rsp]
  00054	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
  00059	e8 00 00 00 00	 call	 ??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; _SYMBOL::_SYMBOL

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 695  :     }

  0005e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00062	c3		 ret	 0
??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@U_SYMBOL@@@std@@YAPEAU_SYMBOL@@PEAU1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@U_SYMBOL@@@std@@YAPEAU_SYMBOL@@PEAU1@@Z PROC ; std::_Unfancy<_SYMBOL>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 289  :     return _Ptr;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 290  : }

  0000a	c3		 ret	 0
??$_Unfancy@U_SYMBOL@@@std@@YAPEAU_SYMBOL@@PEAU1@@Z ENDP ; std::_Unfancy<_SYMBOL>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv86 = 48
tv84 = 56
tv82 = 64
tv80 = 72
_Result$ = 80
this$ = 112
<_Val_0>$ = 120
<_Val_1>$ = 128
??$_Emplace_back_with_unused_capacity@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_back_with_unused_capacity<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00022	48 83 c0 08	 add	 rax, 8
  00026	48 89 44 24 20	 mov	 QWORD PTR _Mylast$[rsp], rax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0002b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR <_Val_1>$[rsp]
  00033	e8 00 00 00 00	 call	 ??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00038	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
  0003d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  00042	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QEAHAEAH@Z ; std::forward<int>
  00047	48 89 44 24 38	 mov	 QWORD PTR tv84[rsp], rax
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00051	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00054	e8 00 00 00 00	 call	 ??$_Unfancy@U_SYMBOL@@@std@@YAPEAU_SYMBOL@@PEAU1@@Z ; std::_Unfancy<_SYMBOL>
  00059	48 89 44 24 40	 mov	 QWORD PTR tv82[rsp], rax
  0005e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00063	e8 00 00 00 00	 call	 ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
  00068	48 89 44 24 48	 mov	 QWORD PTR tv80[rsp], rax
  0006d	4c 8b 4c 24 30	 mov	 r9, QWORD PTR tv86[rsp]
  00072	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv84[rsp]
  00077	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv82[rsp]
  0007c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv80[rsp]
  00081	e8 00 00 00 00	 call	 ??$construct@U_SYMBOL@@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SAXAEAV?$allocator@U_SYMBOL@@@1@QEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::construct<_SYMBOL,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>

; 688  :         _Orphan_range(_Mylast, _Mylast);

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0008b	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00093	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00096	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0009b	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAXPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  000a5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a8	48 89 44 24 50	 mov	 QWORD PTR _Result$[rsp], rax

; 690  :         ++_Mylast;

  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR _Mylast$[rsp]
  000b2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b5	48 83 c0 48	 add	 rax, 72			; 00000048H
  000b9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Mylast$[rsp]
  000be	48 89 01	 mov	 QWORD PTR [rcx], rax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;

  000c1	48 8b 44 24 50	 mov	 rax, QWORD PTR _Result$[rsp]

; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  000c6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ca	c3		 ret	 0
??$_Emplace_back_with_unused_capacity@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_back_with_unused_capacity<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@H@std@@YA$$QEAHAEAH@Z PROC			; std::forward<int>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1456 : }

  0000a	c3		 ret	 0
??$forward@H@std@@YA$$QEAHAEAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv80 = 48
tv78 = 56
tv95 = 64
tv93 = 72
tv91 = 80
_Result$ = 88
this$ = 112
<_Val_0>$ = 120
<_Val_1>$ = 128
??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::emplace_back<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR _My_data$[rsp], rax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  00022	48 83 c0 08	 add	 rax, 8
  00026	48 89 44 24 28	 mov	 QWORD PTR _Mylast$[rsp], rax

; 704  :         if (_Mylast != _My_data._Myend) {

  0002b	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00035	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00039	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0003c	74 37		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0003e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR <_Val_1>$[rsp]
  00046	e8 00 00 00 00	 call	 ??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  0004b	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
  00050	48 8b 4c 24 78	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  00055	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QEAHAEAH@Z ; std::forward<int>
  0005a	48 89 44 24 38	 mov	 QWORD PTR tv78[rsp], rax
  0005f	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv80[rsp]
  00064	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv78[rsp]
  00069	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0006e	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_back_with_unused_capacity<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00073	eb 51		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00075	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR <_Val_1>$[rsp]
  0007d	e8 00 00 00 00	 call	 ??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00082	48 89 44 24 40	 mov	 QWORD PTR tv95[rsp], rax
  00087	48 8b 4c 24 78	 mov	 rcx, QWORD PTR <_Val_0>$[rsp]
  0008c	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QEAHAEAH@Z ; std::forward<int>
  00091	48 89 44 24 48	 mov	 QWORD PTR tv93[rsp], rax
  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0009b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009e	48 89 44 24 50	 mov	 QWORD PTR tv91[rsp], rax
  000a3	4c 8b 4c 24 40	 mov	 r9, QWORD PTR tv95[rsp]
  000a8	4c 8b 44 24 48	 mov	 r8, QWORD PTR tv93[rsp]
  000ad	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv91[rsp]
  000b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  000b7	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAPEAU_SYMBOL@@QEAU2@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Emplace_reallocate<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  000bc	48 89 44 24 58	 mov	 QWORD PTR _Result$[rsp], rax

; 709  : #if _HAS_CXX17
; 710  :         return _Result;

  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR _Result$[rsp]
$LN1@emplace_ba:

; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000c6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ca	c3		 ret	 0
??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::emplace_back<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv88 = 32
tv79 = 40
tv86 = 48
_Istr$ = 80
_Str$ = 88
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 83   :     basic_string<_Elem, _Traits, _Alloc>& _Str) { // get characters into string, discard newline

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 84   :     return getline(_STD move(_Istr), _Str, _Istr.widen('\n'));

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR _Istr$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Istr$[rsp]
  0001f	48 03 c8	 add	 rcx, rax
  00022	48 8b c1	 mov	 rax, rcx
  00025	48 89 44 24 28	 mov	 QWORD PTR tv79[rsp], rax
  0002a	b2 0a		 mov	 dl, 10
  0002c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv79[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  00037	88 44 24 20	 mov	 BYTE PTR tv88[rsp], al
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Istr$[rsp]
  00040	e8 00 00 00 00	 call	 ??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
  00045	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
  0004a	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR tv88[rsp]
  00050	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Str$[rsp]
  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv86[rsp]
  0005a	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >

; 85   : }

  0005f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00063	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  00014	48 8b c8	 mov	 rcx, rax
  00017	e8 00 00 00 00	 call	 ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  00027	48 8b c8	 mov	 rcx, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	48 2d b0 00 00
	00		 sub	 rax, 176		; 000000b0H
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00020	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  00024	83 e0 01	 and	 eax, 1
  00027	85 c0		 test	 eax, eax
  00029	74 18		 je	 SHORT $LN2@scalar
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 2d b0 00 00
	00		 sub	 rax, 176		; 000000b0H
  00036	ba 10 01 00 00	 mov	 edx, 272		; 00000110H
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00048	48 2d b0 00 00
	00		 sub	 rax, 176		; 000000b0H
  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT

; 779  :     void _Set_back() { // set up putback area

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 780  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00019	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0001d	48 3b c1	 cmp	 rax, rcx
  00020	74 2e		 je	 SHORT $LN2@Set_back

; 781  :             _Set_eback = _Mysb::eback();

  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00032	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 782  :             _Set_egptr = _Mysb::egptr();

  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00049	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax
$LN2@Set_back:

; 783  :         }
; 784  :         _Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00055	48 83 c0 71	 add	 rax, 113		; 00000071H
  00059	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0005e	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00062	48 8b 54 24 30	 mov	 rdx, QWORD PTR this$[rsp]
  00067	48 83 c2 70	 add	 rdx, 112		; 00000070H
  0006b	4c 8b c8	 mov	 r9, rax
  0006e	4c 8b c1	 mov	 r8, rcx
  00071	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 785  :     }

  0007c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00080	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT

; 773  :     void _Reset_back() { // restore buffer after putback

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 774  :         if (_Mysb::eback() == &_Mychar) {

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00019	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0001d	48 3b c1	 cmp	 rax, rcx
  00020	75 2f		 jne	 SHORT $LN2@Reset_back

; 775  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00027	4c 8b 88 90 00
	00 00		 mov	 r9, QWORD PTR [rax+144]
  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00033	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003f	48 8b 90 88 00
	00 00		 mov	 rdx, QWORD PTR [rax+136]
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN2@Reset_back:

; 776  :         }
; 777  :     }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Newcvt$ = 56
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT

; 756  :     void _Initcvt(const _Cvt& _Newcvt) { // initialize codecvt pointer

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 757  :         if (_Newcvt.always_noconv()) {

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Newcvt$[rsp]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00019	0f b6 c0	 movzx	 eax, al
  0001c	85 c0		 test	 eax, eax
  0001e	74 0f		 je	 SHORT $LN2@Initcvt

; 758  :             _Pcvt = nullptr; // nothing to do

  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00025	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 759  :         } else { // set up for nontrivial codecvt facet

  0002d	eb 1e		 jmp	 SHORT $LN3@Initcvt
$LN2@Initcvt:

; 760  :             _Pcvt = _STD addressof(_Newcvt);

  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Newcvt$[rsp]
  00034	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0003e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 761  :             _Mysb::_Init(); // reset any buffering

  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
$LN3@Initcvt:

; 762  :         }
; 763  :     }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
_TEXT	SEGMENT
tv132 = 48
tv146 = 52
tv81 = 56
$T1 = 60
$T2 = 64
_Count$3 = 72
tv83 = 80
tv131 = 88
_Codecvt_temp_buf$ = 96
_Dest$ = 104
_Str$ = 112
__$ArrayPad$ = 152
this$ = 176
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 720  :     bool _Endwrite() { // put shift to initial conversion state, as needed

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 721  :         if (!_Pcvt || !_Wrotesome) {

  0001e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00026	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0002b	74 10		 je	 SHORT $LN5@Endwrite
  0002d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00035	0f b6 40 71	 movzx	 eax, BYTE PTR [rax+113]
  00039	85 c0		 test	 eax, eax
  0003b	75 07		 jne	 SHORT $LN4@Endwrite
$LN5@Endwrite:

; 722  :             return true;

  0003d	b0 01		 mov	 al, 1
  0003f	e9 5a 01 00 00	 jmp	 $LN1@Endwrite
$LN4@Endwrite:

; 723  :         }
; 724  : 
; 725  :         // may have to put
; 726  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00044	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0004c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00053	48 89 44 24 50	 mov	 QWORD PTR tv83[rsp], rax
  00058	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0005d	89 44 24 38	 mov	 DWORD PTR tv81[rsp], eax
  00061	8b 54 24 38	 mov	 edx, DWORD PTR tv81[rsp]
  00065	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0006d	ff 54 24 50	 call	 QWORD PTR tv83[rsp]
  00071	89 44 24 3c	 mov	 DWORD PTR $T1[rsp], eax
  00075	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0007a	89 44 24 40	 mov	 DWORD PTR $T2[rsp], eax
  0007e	48 8d 54 24 3c	 lea	 rdx, QWORD PTR $T1[rsp]
  00083	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00088	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0008d	0f b6 c0	 movzx	 eax, al
  00090	85 c0		 test	 eax, eax
  00092	74 07		 je	 SHORT $LN6@Endwrite

; 727  :             return false;

  00094	32 c0		 xor	 al, al
  00096	e9 03 01 00 00	 jmp	 $LN1@Endwrite
$LN6@Endwrite:

; 728  :         }
; 729  : 
; 730  :         constexpr size_t _Codecvt_temp_buf = 32;

  0009b	48 c7 44 24 60
	20 00 00 00	 mov	 QWORD PTR _Codecvt_temp_buf$[rsp], 32 ; 00000020H

; 731  :         char _Str[_Codecvt_temp_buf];
; 732  :         char* _Dest;
; 733  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  000a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ac	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b0	48 89 44 24 58	 mov	 QWORD PTR tv131[rsp], rax
  000b5	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR _Str$[rsp+32]
  000bd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000c5	48 83 c1 74	 add	 rcx, 116		; 00000074H
  000c9	48 8d 54 24 68	 lea	 rdx, QWORD PTR _Dest$[rsp]
  000ce	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000d3	4c 8b c8	 mov	 r9, rax
  000d6	4c 8d 44 24 70	 lea	 r8, QWORD PTR _Str$[rsp]
  000db	48 8b d1	 mov	 rdx, rcx
  000de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv131[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z
  000e9	89 44 24 30	 mov	 DWORD PTR tv132[rsp], eax
  000ed	83 7c 24 30 00	 cmp	 DWORD PTR tv132[rsp], 0
  000f2	74 17		 je	 SHORT $LN7@Endwrite
  000f4	83 7c 24 30 01	 cmp	 DWORD PTR tv132[rsp], 1
  000f9	74 1c		 je	 SHORT $LN8@Endwrite
  000fb	83 7c 24 30 03	 cmp	 DWORD PTR tv132[rsp], 3
  00100	0f 84 86 00 00
	00		 je	 $LN10@Endwrite
  00106	e9 91 00 00 00	 jmp	 $LN11@Endwrite
$LN7@Endwrite:

; 734  :         case codecvt_base::ok:
; 735  :             _Wrotesome = false; // homed successfully

  0010b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00113	c6 40 71 00	 mov	 BYTE PTR [rax+113], 0
$LN8@Endwrite:

; 736  : 
; 737  :         case codecvt_base::partial: // fall through
; 738  :         { // put any generated bytes
; 739  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

  00117	48 8d 44 24 70	 lea	 rax, QWORD PTR _Str$[rsp]
  0011c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Dest$[rsp]
  00121	48 2b c8	 sub	 rcx, rax
  00124	48 8b c1	 mov	 rax, rcx
  00127	48 89 44 24 48	 mov	 QWORD PTR _Count$3[rsp], rax

; 740  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  0012c	48 83 7c 24 48
	00		 cmp	 QWORD PTR _Count$3[rsp], 0
  00132	76 2f		 jbe	 SHORT $LN9@Endwrite
  00134	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0013c	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  00143	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Count$3[rsp]
  00148	ba 01 00 00 00	 mov	 edx, 1
  0014d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR _Str$[rsp]
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00158	48 39 44 24 48	 cmp	 QWORD PTR _Count$3[rsp], rax
  0015d	74 04		 je	 SHORT $LN9@Endwrite

; 741  :                 return false; // write failed

  0015f	32 c0		 xor	 al, al
  00161	eb 3b		 jmp	 SHORT $LN1@Endwrite
$LN9@Endwrite:

; 742  :             }
; 743  : 
; 744  :             return !_Wrotesome;

  00163	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0016b	0f b6 40 71	 movzx	 eax, BYTE PTR [rax+113]
  0016f	85 c0		 test	 eax, eax
  00171	75 0a		 jne	 SHORT $LN13@Endwrite
  00173	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
  0017b	eb 08		 jmp	 SHORT $LN14@Endwrite
$LN13@Endwrite:
  0017d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
$LN14@Endwrite:
  00185	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv146[rsp]
  0018a	eb 12		 jmp	 SHORT $LN1@Endwrite
$LN10@Endwrite:

; 745  :         }
; 746  : 
; 747  :         case codecvt_base::noconv:
; 748  :             _Wrotesome = false; // homed successfully

  0018c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00194	c6 40 71 00	 mov	 BYTE PTR [rax+113], 0

; 749  :             return true; // nothing else to do

  00198	b0 01		 mov	 al, 1
  0019a	eb 02		 jmp	 SHORT $LN1@Endwrite
$LN11@Endwrite:

; 750  : 
; 751  :         default:
; 752  :             return false; // conversion failed

  0019c	32 c0		 xor	 al, al
$LN1@Endwrite:

; 753  :         }
; 754  :     }

  0019e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a6	48 33 cc	 xor	 rcx, rsp
  001a9	e8 00 00 00 00	 call	 __security_check_cookie
  001ae	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001b5	c3		 ret	 0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
tv66 = 64
_Nw$1 = 72
_Nr$2 = 80
_Pn$3 = 88
_Pb$4 = 96
__$ArrayPad$ = 104
this$ = 128
_File$ = 136
_Which$ = 144
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT

; 693  :     void _Init(FILE* _File, _Initfl _Which) { // initialize to C stream _File after {new, open, close}

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 694  :         using _State_type = typename _Traits::state_type;
; 695  : 
; 696  :         __PURE_APPDOMAIN_GLOBAL static _State_type _Stinit; // initial state
; 697  : 
; 698  :         _Closef    = _Which == _Openfl;

  00022	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR _Which$[rsp], 1
  0002a	75 0a		 jne	 SHORT $LN4@Init
  0002c	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00034	eb 08		 jmp	 SHORT $LN5@Init
$LN4@Init:
  00036	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN5@Init:
  0003e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00046	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv66[rsp]
  0004b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 699  :         _Wrotesome = false;

  0004e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00056	c6 40 71 00	 mov	 BYTE PTR [rax+113], 0

; 700  : 
; 701  :         _Mysb::_Init(); // initialize stream buffer base object

  0005a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 702  : 
; 703  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  00068	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR _File$[rsp], 0
  00071	0f 84 84 00 00
	00		 je	 $LN2@Init
  00077	33 c0		 xor	 eax, eax
  00079	83 f8 01	 cmp	 eax, 1
  0007c	74 7d		 je	 SHORT $LN2@Init

; 704  :             _Elem** _Pb = nullptr;

  0007e	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR _Pb$4[rsp], 0

; 705  :             _Elem** _Pn = nullptr;

  00087	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR _Pn$3[rsp], 0

; 706  :             int* _Nr    = nullptr;

  00090	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR _Nr$2[rsp], 0

; 707  : 
; 708  :             ::_get_stream_buffer_pointers(

  00099	4c 8d 4c 24 50	 lea	 r9, QWORD PTR _Nr$2[rsp]
  0009e	4c 8d 44 24 58	 lea	 r8, QWORD PTR _Pn$3[rsp]
  000a3	48 8d 54 24 60	 lea	 rdx, QWORD PTR _Pb$4[rsp]
  000a8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _File$[rsp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers

; 709  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 710  :             int* _Nw = _Nr;

  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR _Nr$2[rsp]
  000bb	48 89 44 24 48	 mov	 QWORD PTR _Nw$1[rsp], rax

; 711  : 
; 712  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

  000c0	48 8b 44 24 48	 mov	 rax, QWORD PTR _Nw$1[rsp]
  000c5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000ca	48 8b 44 24 58	 mov	 rax, QWORD PTR _Pn$3[rsp]
  000cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d4	48 8b 44 24 60	 mov	 rax, QWORD PTR _Pb$4[rsp]
  000d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000de	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Nr$2[rsp]
  000e3	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Pn$3[rsp]
  000e8	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Pb$4[rsp]
  000ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAPEAD0PEAH001@Z
$LN2@Init:

; 713  :         }
; 714  : 
; 715  :         _Myfile = _File;

  000fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00103	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _File$[rsp]
  0010b	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 716  :         _State  = _Stinit;

  00112	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0011a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00121	48 89 48 74	 mov	 QWORD PTR [rax+116], rcx

; 717  :         _Pcvt   = nullptr; // pointer to codecvt facet

  00125	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0012d	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 718  :     }

  00135	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0013a	48 33 cc	 xor	 rcx, rsp
  0013d	e8 00 00 00 00	 call	 __security_check_cookie
  00142	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00146	c3		 ret	 0
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 48
_Loc$ = 56
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT

; 688  :     virtual void __CLR_OR_THIS_CALL imbue(const locale& _Loc) override {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 689  :         // set locale to argument (capture nontrivial codecvt facet)
; 690  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Loc$[rsp]
  00013	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  00018	48 8b d0	 mov	 rdx, rax
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00020	e8 00 00 00 00	 call	 ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt

; 691  :     }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
tv78 = 32
$T1 = 36
$T2 = 40
tv80 = 48
this$ = 80
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT

; 680  :     virtual int __CLR_OR_THIS_CALL sync() override { // synchronize C stream with external file

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 681  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	74 60		 je	 SHORT $LN3@sync
  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00024	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
  00029	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0002e	89 44 24 20	 mov	 DWORD PTR tv78[rsp], eax
  00032	8b 54 24 20	 mov	 edx, DWORD PTR tv78[rsp]
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	ff 54 24 30	 call	 QWORD PTR tv80[rsp]
  0003f	89 44 24 24	 mov	 DWORD PTR $T1[rsp], eax
  00043	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00048	89 44 24 28	 mov	 DWORD PTR $T2[rsp], eax
  0004c	48 8d 54 24 24	 lea	 rdx, QWORD PTR $T1[rsp]
  00051	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  00056	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	85 c0		 test	 eax, eax
  00060	75 16		 jne	 SHORT $LN3@sync
  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00067	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
  00074	85 c0		 test	 eax, eax
  00076	7c 04		 jl	 SHORT $LN2@sync
$LN3@sync:

; 682  :             return 0;

  00078	33 c0		 xor	 eax, eax
  0007a	eb 05		 jmp	 SHORT $LN1@sync
$LN2@sync:

; 683  :         }
; 684  : 
; 685  :         return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1
$LN1@sync:

; 686  :     }

  00081	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00085	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
_TEXT	SEGMENT
_Mode$ = 32
_Size$ = 40
this$ = 64
_Buffer$ = 72
_Count$ = 80
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT

; 661  :     virtual _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) override { // offer _Buffer to C stream

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 662  :         int _Mode;
; 663  :         if (!_Buffer && _Count == 0) {

  00013	48 83 7c 24 48
	00		 cmp	 QWORD PTR _Buffer$[rsp], 0
  00019	75 12		 jne	 SHORT $LN2@setbuf
  0001b	48 83 7c 24 50
	00		 cmp	 QWORD PTR _Count$[rsp], 0
  00021	75 0a		 jne	 SHORT $LN2@setbuf

; 664  :             _Mode = _IONBF;

  00023	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR _Mode$[rsp], 4

; 665  :         } else {

  0002b	eb 08		 jmp	 SHORT $LN3@setbuf
$LN2@setbuf:

; 666  :             _Mode = _IOFBF;

  0002d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _Mode$[rsp], 0
$LN3@setbuf:

; 667  :         }
; 668  : 
; 669  :         const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count$[rsp]
  0003a	48 89 44 24 28	 mov	 QWORD PTR _Size$[rsp], rax

; 670  : 
; 671  :         if (!_Myfile || _CSTD setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00044	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0004c	74 25		 je	 SHORT $LN5@setbuf
  0004e	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _Size$[rsp]
  00053	44 8b 44 24 20	 mov	 r8d, DWORD PTR _Mode$[rsp]
  00058	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00062	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
  0006f	85 c0		 test	 eax, eax
  00071	74 04		 je	 SHORT $LN4@setbuf
$LN5@setbuf:

; 672  :             return nullptr; // failed

  00073	33 c0		 xor	 eax, eax
  00075	eb 21		 jmp	 SHORT $LN1@setbuf
$LN4@setbuf:

; 673  :         }
; 674  : 
; 675  :         // new buffer, reinitialize pointers
; 676  :         _Init(_Myfile, _Openfl);

  00077	41 b8 01 00 00
	00		 mov	 r8d, 1
  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00082	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0008e	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 677  :         return this;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@setbuf:

; 678  :     }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
$T1 = 32
_Off$ = 40
__$ArrayPad$ = 48
this$ = 80
__$ReturnUdt$ = 88
_Pos$ = 96
__formal$ = 104
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT

; 648  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 649  :         // change position to _Pos
; 650  :         off_type _Off = static_cast<off_type>(_Pos);

  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Pos$[rsp]
  0002c	e8 00 00 00 00	 call	 ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ; std::fpos<_Mbstatet>::operator __int64
  00031	48 89 44 24 28	 mov	 QWORD PTR _Off$[rsp], rax

; 651  : 
; 652  :         if (!_Myfile || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00043	74 2c		 je	 SHORT $LN3@seekpos
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004a	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0004f	0f b6 c0	 movzx	 eax, al
  00052	85 c0		 test	 eax, eax
  00054	74 1b		 je	 SHORT $LN3@seekpos
  00056	48 8d 54 24 28	 lea	 rdx, QWORD PTR _Off$[rsp]
  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00060	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fsetpos
  0006d	85 c0		 test	 eax, eax
  0006f	74 18		 je	 SHORT $LN2@seekpos
$LN3@seekpos:

; 653  :             return pos_type(-1); // report failure

  00071	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00078	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0007d	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  00082	48 8b 44 24 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  00087	eb 42		 jmp	 SHORT $LN1@seekpos
$LN2@seekpos:

; 654  :         }
; 655  : 
; 656  :         _State = _Pos.state();

  00089	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0008e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Pos$[rsp]
  00093	e8 00 00 00 00	 call	 ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
  00098	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000a0	48 89 41 74	 mov	 QWORD PTR [rcx+116], rax

; 657  :         _Reset_back(); // revert from _Mychar buffer, discarding any putback

  000a4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000a9	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 658  :         return pos_type(_State, _Off); // return new position

  000ae	4c 8b 44 24 28	 mov	 r8, QWORD PTR _Off$[rsp]
  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000b8	48 8b 50 74	 mov	 rdx, QWORD PTR [rax+116]
  000bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000c1	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@seekpos:

; 659  :     }

  000cb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d0	48 33 cc	 xor	 rcx, rsp
  000d3	e8 00 00 00 00	 call	 __security_check_cookie
  000d8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000dc	c3		 ret	 0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Fileposition$ = 32
__$ArrayPad$ = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
_Way$ = 88
__formal$ = 96
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT

; 628  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 629  :         fpos_t _Fileposition;
; 630  : 
; 631  :         if (_Mysb::gptr() == &_Mychar // something putback
; 632  :             && _Way == ios_base::cur // a relative seek
; 633  :             && !_Pcvt) { // not converting

  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0003b	48 3b c1	 cmp	 rax, rcx
  0003e	75 20		 jne	 SHORT $LN2@seekoff
  00040	83 7c 24 58 01	 cmp	 DWORD PTR _Way$[rsp], 1
  00045	75 19		 jne	 SHORT $LN2@seekoff
  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004c	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00051	75 0d		 jne	 SHORT $LN2@seekoff

; 634  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR _Off$[rsp]
  00058	48 ff c8	 dec	 rax
  0005b	48 89 44 24 50	 mov	 QWORD PTR _Off$[rsp], rax
$LN2@seekoff:

; 635  :         }
; 636  : 
; 637  :         if (!_Myfile || !_Endwrite()
; 638  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 639  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00065	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0006d	74 5b		 je	 SHORT $LN4@seekoff
  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00074	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00079	0f b6 c0	 movzx	 eax, al
  0007c	85 c0		 test	 eax, eax
  0007e	74 4a		 je	 SHORT $LN4@seekoff
  00080	48 83 7c 24 50
	00		 cmp	 QWORD PTR _Off$[rsp], 0
  00086	75 07		 jne	 SHORT $LN6@seekoff
  00088	83 7c 24 58 01	 cmp	 DWORD PTR _Way$[rsp], 1
  0008d	74 20		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  0008f	44 8b 44 24 58	 mov	 r8d, DWORD PTR _Way$[rsp]
  00094	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Off$[rsp]
  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009e	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  000ab	85 c0		 test	 eax, eax
  000ad	75 1b		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  000af	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  000b4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000b9	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  000c6	85 c0		 test	 eax, eax
  000c8	74 18		 je	 SHORT $LN3@seekoff
$LN4@seekoff:

; 640  :             return pos_type(-1); // report failure

  000ca	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  000d1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000d6	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  000db	48 8b 44 24 48	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  000e0	eb 27		 jmp	 SHORT $LN1@seekoff
$LN3@seekoff:

; 641  :         }
; 642  : 
; 643  :         _Reset_back(); // revert from _Mychar buffer, discarding any putback

  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e7	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 644  :         return pos_type(_State, _Fileposition); // return new position

  000ec	4c 8b 44 24 20	 mov	 r8, QWORD PTR _Fileposition$[rsp]
  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000f6	48 8b 50 74	 mov	 rdx, QWORD PTR [rax+116]
  000fa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000ff	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@seekoff:

; 645  :     }

  00109	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0010e	48 33 cc	 xor	 rcx, rsp
  00111	e8 00 00 00 00	 call	 __security_check_cookie
  00116	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011a	c3		 ret	 0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
_TEXT	SEGMENT
_Size$1 = 32
_Start_count$2 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT

; 596  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) override {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 597  :         // put _Count characters to stream
; 598  :         if _CONSTEXPR_IF (sizeof(_Elem) == 1) {
; 599  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001d	74 1a		 je	 SHORT $LN2@xsputn

; 600  :                 return _Mysb::xsputn(_Ptr, _Count);

  0001f	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Count$[rsp]
  00024	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
  00034	e9 ee 00 00 00	 jmp	 $LN1@xsputn
$LN2@xsputn:

; 601  :             }
; 602  : 
; 603  :             const streamsize _Start_count = _Count;

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count$[rsp]
  0003e	48 89 44 24 28	 mov	 QWORD PTR _Start_count$2[rsp], rax

; 604  :             streamsize _Size              = _Mysb::_Pnavail();

  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
  0004e	48 89 44 24 20	 mov	 QWORD PTR _Size$1[rsp], rax

; 605  :             if (0 < _Count && 0 < _Size) { // copy to write buffer

  00053	48 83 7c 24 50
	00		 cmp	 QWORD PTR _Count$[rsp], 0
  00059	7e 74		 jle	 SHORT $LN3@xsputn
  0005b	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Size$1[rsp], 0
  00061	7e 6c		 jle	 SHORT $LN3@xsputn

; 606  :                 if (_Count < _Size) {

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR _Size$1[rsp]
  00068	48 39 44 24 50	 cmp	 QWORD PTR _Count$[rsp], rax
  0006d	7d 0a		 jge	 SHORT $LN4@xsputn

; 607  :                     _Size = _Count;

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count$[rsp]
  00074	48 89 44 24 20	 mov	 QWORD PTR _Size$1[rsp], rax
$LN4@xsputn:

; 608  :                 }
; 609  : 
; 610  :                 _Traits::copy(_Mysb::pptr(), _Ptr, static_cast<size_t>(_Size));

  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00084	4c 8b 44 24 20	 mov	 r8, QWORD PTR _Size$1[rsp]
  00089	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 611  :                 _Ptr += _Size;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR _Size$1[rsp]
  0009b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  000a0	48 03 c8	 add	 rcx, rax
  000a3	48 8b c1	 mov	 rax, rcx
  000a6	48 89 44 24 48	 mov	 QWORD PTR _Ptr$[rsp], rax

; 612  :                 _Count -= _Size;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR _Size$1[rsp]
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Count$[rsp]
  000b5	48 2b c8	 sub	 rcx, rax
  000b8	48 8b c1	 mov	 rax, rcx
  000bb	48 89 44 24 50	 mov	 QWORD PTR _Count$[rsp], rax

; 613  :                 _Mysb::pbump(static_cast<int>(_Size));

  000c0	8b 54 24 20	 mov	 edx, DWORD PTR _Size$1[rsp]
  000c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
$LN3@xsputn:

; 614  :             }
; 615  : 
; 616  :             if (0 < _Count && _Myfile) { // open C stream, attempt write

  000cf	48 83 7c 24 50
	00		 cmp	 QWORD PTR _Count$[rsp], 0
  000d5	7e 40		 jle	 SHORT $LN5@xsputn
  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000dc	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000e4	74 31		 je	 SHORT $LN5@xsputn

; 617  :                 _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

  000e6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000eb	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  000f2	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Count$[rsp]
  000f7	ba 01 00 00 00	 mov	 edx, 1
  000fc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00107	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Count$[rsp]
  0010c	48 2b c8	 sub	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	48 89 44 24 50	 mov	 QWORD PTR _Count$[rsp], rax
$LN5@xsputn:

; 618  :             }
; 619  : 
; 620  :             return _Start_count - _Count;

  00117	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count$[rsp]
  0011c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Start_count$2[rsp]
  00121	48 2b c8	 sub	 rcx, rax
  00124	48 8b c1	 mov	 rax, rcx
$LN1@xsputn:

; 621  :         } else { // non-chars always get element-by-element processing
; 622  :             return _Mysb::xsputn(_Ptr, _Count);
; 623  :         }
; 624  :     }

  00127	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012b	c3		 ret	 0
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
_TEXT	SEGMENT
_Read_size$1 = 32
_Actual_read$2 = 40
_Start_count$3 = 48
tv158 = 56
tv156 = 64
_Read_size$4 = 72
_Count_s$5 = 80
_Available$6 = 88
__$ArrayPad$ = 96
this$ = 128
_Ptr$ = 136
_Count$ = 144
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT

; 548  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) override {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 549  :         // get _Count characters from stream
; 550  :         if _CONSTEXPR_IF (sizeof(_Elem) == 1) {
; 551  :             if (_Count <= 0) {

  00022	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR _Count$[rsp], 0
  0002b	7f 07		 jg	 SHORT $LN4@xsgetn

; 552  :                 return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 fc 01 00 00	 jmp	 $LN1@xsgetn
$LN4@xsgetn:

; 553  :             }
; 554  : 
; 555  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  00034	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0003c	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00041	74 23		 je	 SHORT $LN5@xsgetn

; 556  :                 return _Mysb::xsgetn(_Ptr, _Count);

  00043	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR _Count$[rsp]
  0004b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00053	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
  00061	e9 ca 01 00 00	 jmp	 $LN1@xsgetn
$LN5@xsgetn:

; 557  :             }
; 558  : 
; 559  :             // assuming this is OK because _Ptr + _Count must be valid
; 560  :             auto _Count_s           = static_cast<size_t>(_Count);

  00066	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR _Count$[rsp]
  0006e	48 89 44 24 50	 mov	 QWORD PTR _Count_s$5[rsp], rax

; 561  :             const auto _Start_count = _Count;

  00073	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR _Count$[rsp]
  0007b	48 89 44 24 30	 mov	 QWORD PTR _Start_count$3[rsp], rax

; 562  :             const auto _Available   = static_cast<size_t>(_Mysb::_Gnavail());

  00080	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
  0008e	48 89 44 24 58	 mov	 QWORD PTR _Available$6[rsp], rax

; 563  :             if (0 < _Available) { // copy from get area

  00093	48 83 7c 24 58
	00		 cmp	 QWORD PTR _Available$6[rsp], 0
  00099	76 7c		 jbe	 SHORT $LN6@xsgetn

; 564  :                 const auto _Read_size = (_STD min)(_Count_s, _Available);

  0009b	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Available$6[rsp]
  000a0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Count_s$5[rsp]
  000a5	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  000aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ad	48 89 44 24 20	 mov	 QWORD PTR _Read_size$1[rsp], rax

; 565  :                 _Traits::copy(_Ptr, _Mysb::gptr(), _Read_size);

  000b2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000c0	4c 8b 44 24 20	 mov	 r8, QWORD PTR _Read_size$1[rsp]
  000c5	48 8b d0	 mov	 rdx, rax
  000c8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  000d0	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 566  :                 _Ptr += _Read_size;

  000d5	48 8b 44 24 20	 mov	 rax, QWORD PTR _Read_size$1[rsp]
  000da	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  000e2	48 03 c8	 add	 rcx, rax
  000e5	48 8b c1	 mov	 rax, rcx
  000e8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR _Ptr$[rsp], rax

; 567  :                 _Count_s -= _Read_size;

  000f0	48 8b 44 24 20	 mov	 rax, QWORD PTR _Read_size$1[rsp]
  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Count_s$5[rsp]
  000fa	48 2b c8	 sub	 rcx, rax
  000fd	48 8b c1	 mov	 rax, rcx
  00100	48 89 44 24 50	 mov	 QWORD PTR _Count_s$5[rsp], rax

; 568  :                 _Mysb::gbump(static_cast<int>(_Read_size));

  00105	8b 54 24 20	 mov	 edx, DWORD PTR _Read_size$1[rsp]
  00109	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
$LN6@xsgetn:

; 569  :             }
; 570  : 
; 571  :             if (_Myfile) { // open C stream, attempt read

  00117	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0011f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00127	0f 84 f3 00 00
	00		 je	 $LN7@xsgetn

; 572  :                 _Reset_back(); // revert from _Mychar buffer

  0012d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00135	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 573  :                 // process in 4k - 1 chunks to avoid tripping over fread's clobber-the-end behavior when
; 574  :                 // doing \r\n -> \n translation
; 575  :                 constexpr size_t _Read_size = 4095; // _INTERNAL_BUFSIZ - 1

  0013a	48 c7 44 24 48
	ff 0f 00 00	 mov	 QWORD PTR _Read_size$4[rsp], 4095 ; 00000fffH
$LN2@xsgetn:

; 576  :                 while (_Read_size < _Count_s) {

  00143	48 81 7c 24 50
	ff 0f 00 00	 cmp	 QWORD PTR _Count_s$5[rsp], 4095 ; 00000fffH
  0014c	76 7f		 jbe	 SHORT $LN3@xsgetn

; 577  :                     const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);

  0014e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00156	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  0015d	41 b8 ff 0f 00
	00		 mov	 r8d, 4095		; 00000fffH
  00163	ba 01 00 00 00	 mov	 edx, 1
  00168	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00176	48 89 44 24 28	 mov	 QWORD PTR _Actual_read$2[rsp], rax

; 578  :                     _Ptr += _Actual_read;

  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR _Actual_read$2[rsp]
  00180	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00188	48 03 c8	 add	 rcx, rax
  0018b	48 8b c1	 mov	 rax, rcx
  0018e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR _Ptr$[rsp], rax

; 579  :                     _Count_s -= _Actual_read;

  00196	48 8b 44 24 28	 mov	 rax, QWORD PTR _Actual_read$2[rsp]
  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Count_s$5[rsp]
  001a0	48 2b c8	 sub	 rcx, rax
  001a3	48 8b c1	 mov	 rax, rcx
  001a6	48 89 44 24 50	 mov	 QWORD PTR _Count_s$5[rsp], rax

; 580  :                     if (_Actual_read != _Read_size) {

  001ab	48 81 7c 24 28
	ff 0f 00 00	 cmp	 QWORD PTR _Actual_read$2[rsp], 4095 ; 00000fffH
  001b4	74 12		 je	 SHORT $LN8@xsgetn

; 581  :                         return static_cast<streamsize>(_Start_count - _Count_s);

  001b6	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count_s$5[rsp]
  001bb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Start_count$3[rsp]
  001c0	48 2b c8	 sub	 rcx, rax
  001c3	48 8b c1	 mov	 rax, rcx
  001c6	eb 68		 jmp	 SHORT $LN1@xsgetn
$LN8@xsgetn:

; 582  :                     }
; 583  :                 }

  001c8	e9 76 ff ff ff	 jmp	 $LN2@xsgetn
$LN3@xsgetn:

; 584  : 
; 585  :                 if (0 < _Count_s) {

  001cd	48 83 7c 24 50
	00		 cmp	 QWORD PTR _Count_s$5[rsp], 0
  001d3	76 4b		 jbe	 SHORT $LN9@xsgetn

; 586  :                     _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);

  001d5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001dd	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  001e4	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Count_s$5[rsp]
  001e9	ba 01 00 00 00	 mov	 edx, 1
  001ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  001fc	48 89 44 24 38	 mov	 QWORD PTR tv158[rsp], rax
  00201	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count_s$5[rsp]
  00206	48 89 44 24 40	 mov	 QWORD PTR tv156[rsp], rax
  0020b	48 8b 44 24 38	 mov	 rax, QWORD PTR tv158[rsp]
  00210	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv156[rsp]
  00215	48 2b c8	 sub	 rcx, rax
  00218	48 8b c1	 mov	 rax, rcx
  0021b	48 89 44 24 50	 mov	 QWORD PTR _Count_s$5[rsp], rax
$LN9@xsgetn:
$LN7@xsgetn:

; 587  :                 }
; 588  :             }
; 589  : 
; 590  :             return static_cast<streamsize>(_Start_count - _Count_s);

  00220	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count_s$5[rsp]
  00225	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Start_count$3[rsp]
  0022a	48 2b c8	 sub	 rcx, rax
  0022d	48 8b c1	 mov	 rax, rcx
$LN1@xsgetn:

; 591  :         } else { // non-chars always get element-by-element processing
; 592  :             return _Mysb::xsgetn(_Ptr, _Count);
; 593  :         }
; 594  :     }

  00230	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00235	48 33 cc	 xor	 rcx, rsp
  00238	e8 00 00 00 00	 call	 __security_check_cookie
  0023d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00241	c3		 ret	 0
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
tv175 = 64
tv139 = 68
_Meta$1 = 72
_Nleft$2 = 80
$T3 = 88
$T4 = 92
$T5 = 96
$T6 = 100
tv76 = 104
tv159 = 112
tv172 = 120
tv170 = 128
tv174 = 136
tv178 = 144
_Src$7 = 152
_Dest$8 = 160
_Ch$9 = 168
_Ch$10 = 169
_Str$ = 176
__$ArrayPad$ = 208
this$ = 240
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT

; 490  :     virtual int_type __CLR_OR_THIS_CALL uflow() override { // get an element from stream, point past it

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0001e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 46		 je	 SHORT $LN9@uflow
  00031	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0003f	48 89 44 24 68	 mov	 QWORD PTR tv76[rsp], rax
  00044	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv76[rsp]
  00057	48 3b c8	 cmp	 rcx, rax
  0005a	73 1b		 jae	 SHORT $LN9@uflow

; 492  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

  0005c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00072	e9 fe 02 00 00	 jmp	 $LN1@uflow
$LN9@uflow:

; 493  :         }
; 494  : 
; 495  :         if (!_Myfile) {

  00077	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0007f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00087	75 0a		 jne	 SHORT $LN10@uflow

; 496  :             return _Traits::eof(); // no open C stream, fail

  00089	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0008e	e9 e2 02 00 00	 jmp	 $LN1@uflow
$LN10@uflow:

; 497  :         }
; 498  : 
; 499  :         _Reset_back(); // revert from _Mychar buffer

  00093	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0009b	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 500  :         if (!_Pcvt) { // no codecvt facet, just get it

  000a0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000a8	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000ad	75 48		 jne	 SHORT $LN11@uflow

; 501  :             _Elem _Ch;
; 502  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  000af	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000b7	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  000be	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Ch$9[rsp]
  000c6	e8 00 00 00 00	 call	 ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ; std::_Fgetc<char>
  000cb	0f b6 c0	 movzx	 eax, al
  000ce	85 c0		 test	 eax, eax
  000d0	74 13		 je	 SHORT $LN18@uflow
  000d2	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Ch$9[rsp]
  000da	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  000df	89 44 24 44	 mov	 DWORD PTR tv139[rsp], eax
  000e3	eb 09		 jmp	 SHORT $LN19@uflow
$LN18@uflow:
  000e5	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000ea	89 44 24 44	 mov	 DWORD PTR tv139[rsp], eax
$LN19@uflow:
  000ee	8b 44 24 44	 mov	 eax, DWORD PTR tv139[rsp]
  000f2	e9 7e 02 00 00	 jmp	 $LN1@uflow
$LN11@uflow:

; 503  :         }
; 504  : 
; 505  :         // build string until codecvt succeeds
; 506  :         string _Str;

  000f7	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  000ff	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00104	90		 npad	 1
$LN2@uflow:

; 507  : 
; 508  :         for (;;) { // get using codecvt facet
; 509  :             const char* _Src;
; 510  :             int _Meta = _CSTD fgetc(_Myfile);

  00105	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0010d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  0011a	89 44 24 48	 mov	 DWORD PTR _Meta$1[rsp], eax

; 511  : 
; 512  :             if (_Meta == EOF) {

  0011e	83 7c 24 48 ff	 cmp	 DWORD PTR _Meta$1[rsp], -1
  00123	75 1f		 jne	 SHORT $LN12@uflow

; 513  :                 return _Traits::eof(); // partial char?

  00125	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0012a	89 44 24 58	 mov	 DWORD PTR $T3[rsp], eax
  0012e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00136	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0013b	8b 44 24 58	 mov	 eax, DWORD PTR $T3[rsp]
  0013f	e9 31 02 00 00	 jmp	 $LN1@uflow
$LN12@uflow:

; 514  :             }
; 515  : 
; 516  :             _Str.push_back(static_cast<char>(_Meta)); // append byte and convert

  00144	0f b6 54 24 48	 movzx	 edx, BYTE PTR _Meta$1[rsp]
  00149	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00151	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 517  : 
; 518  :             _Elem _Ch;
; 519  :             _Elem* _Dest;
; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  00156	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0015e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00162	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  0016a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00172	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00177	48 89 44 24 70	 mov	 QWORD PTR tv159[rsp], rax
  0017c	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00184	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00189	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv159[rsp]
  0018e	48 03 c8	 add	 rcx, rax
  00191	48 8b c1	 mov	 rax, rcx
  00194	48 89 44 24 78	 mov	 QWORD PTR tv172[rsp], rax
  00199	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  001a1	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  001a6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv170[rsp], rax
  001ae	48 8d 84 24 aa
	00 00 00	 lea	 rax, QWORD PTR _Ch$10[rsp+1]
  001b6	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001be	48 83 c1 74	 add	 rcx, 116		; 00000074H
  001c2	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR _Dest$8[rsp]
  001ca	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  001cf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001d4	48 8d 84 24 a9
	00 00 00	 lea	 rax, QWORD PTR _Ch$10[rsp]
  001dc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e1	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR _Src$7[rsp]
  001e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ee	4c 8b 4c 24 78	 mov	 r9, QWORD PTR tv172[rsp]
  001f3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR tv170[rsp]
  001fb	48 8b d1	 mov	 rdx, rcx
  001fe	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv174[rsp]
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  0020c	89 44 24 40	 mov	 DWORD PTR tv175[rsp], eax
  00210	83 7c 24 40 00	 cmp	 DWORD PTR tv175[rsp], 0
  00215	0f 8c 2b 01 00
	00		 jl	 $LN16@uflow
  0021b	83 7c 24 40 01	 cmp	 DWORD PTR tv175[rsp], 1
  00220	7e 10		 jle	 SHORT $LN13@uflow
  00222	83 7c 24 40 03	 cmp	 DWORD PTR tv175[rsp], 3
  00227	0f 84 f2 00 00
	00		 je	 $LN15@uflow
  0022d	e9 14 01 00 00	 jmp	 $LN16@uflow
$LN13@uflow:

; 521  :                 _Dest)) { // test result of converting one element
; 522  :             case codecvt_base::partial:
; 523  :             case codecvt_base::ok:
; 524  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

  00232	48 8d 84 24 a9
	00 00 00	 lea	 rax, QWORD PTR _Ch$10[rsp]
  0023a	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR _Dest$8[rsp], rax
  00242	0f 84 a8 00 00
	00		 je	 $LN14@uflow

; 525  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

  00248	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00250	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00255	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv178[rsp], rax
  0025d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00265	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0026a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv178[rsp]
  00272	48 03 c8	 add	 rcx, rax
  00275	48 8b c1	 mov	 rax, rcx
  00278	48 2b 84 24 98
	00 00 00	 sub	 rax, QWORD PTR _Src$7[rsp]
  00280	48 89 44 24 50	 mov	 QWORD PTR _Nleft$2[rsp], rax
$LN7@uflow:

; 526  :                     while (0 < _Nleft) {

  00285	48 83 7c 24 50
	00		 cmp	 QWORD PTR _Nleft$2[rsp], 0
  0028b	7e 3c		 jle	 SHORT $LN8@uflow

; 527  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

  0028d	48 8b 44 24 50	 mov	 rax, QWORD PTR _Nleft$2[rsp]
  00292	48 ff c8	 dec	 rax
  00295	48 89 44 24 50	 mov	 QWORD PTR _Nleft$2[rsp], rax
  0029a	48 8b 44 24 50	 mov	 rax, QWORD PTR _Nleft$2[rsp]
  0029f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _Src$7[rsp]
  002a7	48 03 c8	 add	 rcx, rax
  002aa	48 8b c1	 mov	 rax, rcx
  002ad	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002b0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002b8	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  002bf	8b c8		 mov	 ecx, eax
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc

; 528  :                     }

  002c7	eb bc		 jmp	 SHORT $LN7@uflow
$LN8@uflow:

; 529  : 
; 530  :                     return _Traits::to_int_type(_Ch);

  002c9	48 8d 8c 24 a9
	00 00 00	 lea	 rcx, QWORD PTR _Ch$10[rsp]
  002d1	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  002d6	89 44 24 5c	 mov	 DWORD PTR $T4[rsp], eax
  002da	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  002e2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002e7	8b 44 24 5c	 mov	 eax, DWORD PTR $T4[rsp]
  002eb	e9 85 00 00 00	 jmp	 $LN1@uflow
$LN14@uflow:

; 531  :                 }
; 532  : 
; 533  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

  002f0	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  002f8	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  002fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _Src$7[rsp]
  00305	48 2b c8	 sub	 rcx, rax
  00308	48 8b c1	 mov	 rax, rcx
  0030b	4c 8b c0	 mov	 r8, rax
  0030e	33 d2		 xor	 edx, edx
  00310	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00318	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 534  :                 break;

  0031d	eb 43		 jmp	 SHORT $LN5@uflow
$LN15@uflow:

; 535  : 
; 536  :             case codecvt_base::noconv:
; 537  :                 // noconv is only possible if _Elem is char, so we can use it directly
; 538  :                 return static_cast<int_type>(_Str.front());

  0031f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00327	e8 00 00 00 00	 call	 ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
  0032c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0032f	89 44 24 60	 mov	 DWORD PTR $T5[rsp], eax
  00333	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  0033b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00340	8b 44 24 60	 mov	 eax, DWORD PTR $T5[rsp]
  00344	eb 2f		 jmp	 SHORT $LN1@uflow
$LN16@uflow:

; 539  : 
; 540  :             default:
; 541  :                 return _Traits::eof(); // conversion failed

  00346	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0034b	89 44 24 64	 mov	 DWORD PTR $T6[rsp], eax
  0034f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  00357	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0035c	8b 44 24 64	 mov	 eax, DWORD PTR $T6[rsp]
  00360	eb 13		 jmp	 SHORT $LN1@uflow
$LN5@uflow:

; 542  :             }
; 543  :         }

  00362	e9 9e fd ff ff	 jmp	 $LN2@uflow

; 544  :     }

  00367	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  0036f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00374	90		 npad	 1
$LN1@uflow:
  00375	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0037d	48 33 cc	 xor	 rcx, rsp
  00380	e8 00 00 00 00	 call	 __security_check_cookie
  00385	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0038c	c3		 ret	 0
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv175 = 64
tv139 = 68
_Meta$1 = 72
_Nleft$2 = 80
$T3 = 88
$T4 = 92
$T5 = 96
$T6 = 100
tv76 = 104
tv159 = 112
tv172 = 120
tv170 = 128
tv174 = 136
tv178 = 144
_Src$7 = 152
_Dest$8 = 160
_Ch$9 = 168
_Ch$10 = 169
_Str$ = 176
__$ArrayPad$ = 208
this$ = 240
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR _Str$[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv175 = 64
tv139 = 68
_Meta$1 = 72
_Nleft$2 = 80
$T3 = 88
$T4 = 92
$T5 = 96
$T6 = 100
tv76 = 104
tv159 = 112
tv172 = 120
tv170 = 128
tv174 = 136
tv178 = 144
_Src$7 = 152
_Dest$8 = 160
_Ch$9 = 168
_Ch$10 = 169
_Str$ = 176
__$ArrayPad$ = 208
this$ = 240
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR _Str$[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
$T1 = 32
tv76 = 40
tv148 = 48
_Meta$ = 56
__$ArrayPad$ = 64
this$ = 96
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT

; 478  :     virtual int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 479  :         int_type _Meta;
; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00023	48 85 c0	 test	 rax, rax
  00026	74 3c		 je	 SHORT $LN2@underflow
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00033	48 89 44 24 28	 mov	 QWORD PTR tv76[rsp], rax
  00038	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00043	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv76[rsp]
  00048	48 3b c8	 cmp	 rcx, rax
  0004b	73 17		 jae	 SHORT $LN2@underflow

; 481  :             return _Traits::to_int_type(*_Mysb::gptr()); // return buffered

  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00060	eb 5f		 jmp	 SHORT $LN1@underflow
  00062	eb 5d		 jmp	 SHORT $LN3@underflow
$LN2@underflow:

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00069	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00071	ff 50 38	 call	 QWORD PTR [rax+56]
  00074	89 44 24 38	 mov	 DWORD PTR _Meta$[rsp], eax
  00078	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0007d	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
  00081	48 8d 54 24 38	 lea	 rdx, QWORD PTR _Meta$[rsp]
  00086	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0008b	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00090	0f b6 c0	 movzx	 eax, al
  00093	85 c0		 test	 eax, eax
  00095	74 08		 je	 SHORT $LN4@underflow

; 483  :             return _Meta; // uflow failed, return EOF

  00097	8b 44 24 38	 mov	 eax, DWORD PTR _Meta$[rsp]
  0009b	eb 24		 jmp	 SHORT $LN1@underflow

; 484  :         } else { // get a char, don't point past it

  0009d	eb 22		 jmp	 SHORT $LN5@underflow
$LN4@underflow:

; 485  :             pbackfail(_Meta);

  0009f	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000ab	48 89 44 24 30	 mov	 QWORD PTR tv148[rsp], rax
  000b0	8b 54 24 38	 mov	 edx, DWORD PTR _Meta$[rsp]
  000b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000b9	ff 54 24 30	 call	 QWORD PTR tv148[rsp]

; 486  :             return _Meta;

  000bd	8b 44 24 38	 mov	 eax, DWORD PTR _Meta$[rsp]
$LN5@underflow:
$LN3@underflow:
$LN1@underflow:

; 487  :         }
; 488  :     }

  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c6	48 33 cc	 xor	 rcx, rsp
  000c9	e8 00 00 00 00	 call	 __security_check_cookie
  000ce	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d2	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
tv76 = 48
tv162 = 56
this$ = 80
_Meta$ = 88
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 457  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

$LN13:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 458  :         // put an element back to stream
; 459  :         if (_Mysb::gptr() && _Mysb::eback() < _Mysb::gptr()
; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0000d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00018	48 85 c0	 test	 rax, rax
  0001b	0f 84 9c 00 00
	00		 je	 $LN2@pbackfail
  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0002c	48 89 44 24 30	 mov	 QWORD PTR tv76[rsp], rax
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv76[rsp]
  00041	48 3b c8	 cmp	 rcx, rax
  00044	73 77		 jae	 SHORT $LN2@pbackfail
  00046	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0004b	89 44 24 24	 mov	 DWORD PTR $T2[rsp], eax
  0004f	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Meta$[rsp]
  00054	48 8d 4c 24 24	 lea	 rcx, QWORD PTR $T2[rsp]
  00059	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0005e	0f b6 c0	 movzx	 eax, al
  00061	85 c0		 test	 eax, eax
  00063	75 39		 jne	 SHORT $LN4@pbackfail
  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00070	b9 01 00 00 00	 mov	 ecx, 1
  00075	48 6b c9 ff	 imul	 rcx, rcx, -1
  00079	48 03 c1	 add	 rax, rcx
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00084	89 44 24 28	 mov	 DWORD PTR $T3[rsp], eax
  00088	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Meta$[rsp]
  0008d	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T3[rsp]
  00092	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00097	0f b6 c0	 movzx	 eax, al
  0009a	85 c0		 test	 eax, eax
  0009c	74 1f		 je	 SHORT $LN2@pbackfail
$LN4@pbackfail:

; 461  :                 || _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
; 462  :                     _Meta))) { // just back up position
; 463  :             _Mysb::_Gndec();

  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ

; 464  :             return _Traits::not_eof(_Meta);

  000a9	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  000ae	e8 00 00 00 00	 call	 ?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ; std::_Narrow_char_traits<char,int>::not_eof
  000b3	e9 cd 00 00 00	 jmp	 $LN1@pbackfail
  000b8	e9 c8 00 00 00	 jmp	 $LN3@pbackfail
$LN2@pbackfail:

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  000bd	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000c2	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000ca	74 1f		 je	 SHORT $LN7@pbackfail
  000cc	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000d1	89 44 24 2c	 mov	 DWORD PTR $T4[rsp], eax
  000d5	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Meta$[rsp]
  000da	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR $T4[rsp]
  000df	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  000e4	0f b6 c0	 movzx	 eax, al
  000e7	85 c0		 test	 eax, eax
  000e9	74 0f		 je	 SHORT $LN5@pbackfail
$LN7@pbackfail:

; 466  :             return _Traits::eof(); // no open C stream or EOF, fail

  000eb	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000f0	e9 90 00 00 00	 jmp	 $LN1@pbackfail
  000f5	e9 8b 00 00 00	 jmp	 $LN6@pbackfail
$LN5@pbackfail:

; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  000fa	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000ff	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00104	75 3d		 jne	 SHORT $LN8@pbackfail
  00106	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0010b	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00112	48 89 44 24 38	 mov	 QWORD PTR tv162[rsp], rax
  00117	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  0011c	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00121	88 44 24 20	 mov	 BYTE PTR $T1[rsp], al
  00125	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv162[rsp]
  0012a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0012f	e8 00 00 00 00	 call	 ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ; std::_Ungetc<char>
  00134	0f b6 c0	 movzx	 eax, al
  00137	85 c0		 test	 eax, eax
  00139	74 08		 je	 SHORT $LN8@pbackfail

; 468  :             return _Meta; // no facet and unget succeeded, return

  0013b	8b 44 24 58	 mov	 eax, DWORD PTR _Meta$[rsp]
  0013f	eb 44		 jmp	 SHORT $LN1@pbackfail
  00141	eb 42		 jmp	 SHORT $LN9@pbackfail
$LN8@pbackfail:

; 469  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0014e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00153	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00157	48 3b c1	 cmp	 rax, rcx
  0015a	74 24		 je	 SHORT $LN10@pbackfail

; 470  :             _Mychar = _Traits::to_char_type(_Meta);

  0015c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  00161	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00166	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0016b	88 41 70	 mov	 BYTE PTR [rcx+112], al

; 471  :             _Set_back(); // switch to _Mychar buffer

  0016e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00173	e8 00 00 00 00	 call	 ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back

; 472  :             return _Meta;

  00178	8b 44 24 58	 mov	 eax, DWORD PTR _Meta$[rsp]
  0017c	eb 07		 jmp	 SHORT $LN1@pbackfail

; 473  :         } else {

  0017e	eb 05		 jmp	 SHORT $LN11@pbackfail
$LN10@pbackfail:

; 474  :             return _Traits::eof(); // nowhere to put back

  00180	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
$LN11@pbackfail:
$LN9@pbackfail:
$LN6@pbackfail:
$LN3@pbackfail:
$LN1@pbackfail:

; 475  :         }
; 476  :     }

  00185	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00189	c3		 ret	 0
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
tv133 = 64
tv147 = 65
tv171 = 68
tv153 = 72
tv192 = 76
$T1 = 80
_Count$2 = 88
tv84 = 96
tv149 = 104
tv170 = 112
_Codecvt_temp_buf$ = 120
_Dest$ = 128
_Src$ = 136
_Ch$ = 144
_Str$ = 152
__$ArrayPad$ = 192
this$ = 224
_Meta$ = 232
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT

; 406  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

$LN18:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 407  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00022	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00027	89 44 24 50	 mov	 DWORD PTR $T1[rsp], eax
  0002b	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR _Meta$[rsp]
  00033	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T1[rsp]
  00038	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0003d	0f b6 c0	 movzx	 eax, al
  00040	85 c0		 test	 eax, eax
  00042	74 12		 je	 SHORT $LN4@overflow

; 408  :             return _Traits::not_eof(_Meta); // EOF, return success code

  00044	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  0004c	e8 00 00 00 00	 call	 ?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ; std::_Narrow_char_traits<char,int>::not_eof
  00051	e9 7e 02 00 00	 jmp	 $LN1@overflow
$LN4@overflow:

; 409  :         }
; 410  : 
; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  00056	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00064	48 85 c0	 test	 rax, rax
  00067	74 5d		 je	 SHORT $LN5@overflow
  00069	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00077	48 89 44 24 60	 mov	 QWORD PTR tv84[rsp], rax
  0007c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0008a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv84[rsp]
  0008f	48 3b c8	 cmp	 rcx, rax
  00092	73 32		 jae	 SHORT $LN5@overflow

; 412  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00094	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  0009c	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  000a1	88 44 24 40	 mov	 BYTE PTR tv133[rsp], al
  000a5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  000b3	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv133[rsp]
  000b8	88 08		 mov	 BYTE PTR [rax], cl

; 413  :             return _Meta;

  000ba	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _Meta$[rsp]
  000c1	e9 0e 02 00 00	 jmp	 $LN1@overflow
$LN5@overflow:

; 414  :         }
; 415  : 
; 416  :         if (!_Myfile) {

  000c6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ce	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000d6	75 0a		 jne	 SHORT $LN6@overflow

; 417  :             return _Traits::eof(); // no open C stream, fail

  000d8	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000dd	e9 f2 01 00 00	 jmp	 $LN1@overflow
$LN6@overflow:

; 418  :         }
; 419  : 
; 420  :         _Reset_back(); // revert from _Mychar buffer

  000e2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000ea	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 421  :         if (!_Pcvt) { // no codecvt facet, put as is

  000ef	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000f7	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000fc	75 5a		 jne	 SHORT $LN7@overflow

; 422  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  000fe	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00106	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0010d	48 89 44 24 68	 mov	 QWORD PTR tv149[rsp], rax
  00112	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  0011a	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  0011f	88 44 24 41	 mov	 BYTE PTR tv147[rsp], al
  00123	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv149[rsp]
  00128	0f b6 4c 24 41	 movzx	 ecx, BYTE PTR tv147[rsp]
  0012d	e8 00 00 00 00	 call	 ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ; std::_Fputc<char>
  00132	0f b6 c0	 movzx	 eax, al
  00135	85 c0		 test	 eax, eax
  00137	74 0d		 je	 SHORT $LN14@overflow
  00139	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _Meta$[rsp]
  00140	89 44 24 48	 mov	 DWORD PTR tv153[rsp], eax
  00144	eb 09		 jmp	 SHORT $LN15@overflow
$LN14@overflow:
  00146	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0014b	89 44 24 48	 mov	 DWORD PTR tv153[rsp], eax
$LN15@overflow:
  0014f	8b 44 24 48	 mov	 eax, DWORD PTR tv153[rsp]
  00153	e9 7c 01 00 00	 jmp	 $LN1@overflow
$LN7@overflow:

; 423  :         }
; 424  : 
; 425  :         // put using codecvt facet
; 426  :         constexpr size_t _Codecvt_temp_buf = 32;

  00158	48 c7 44 24 78
	20 00 00 00	 mov	 QWORD PTR _Codecvt_temp_buf$[rsp], 32 ; 00000020H

; 427  :         char _Str[_Codecvt_temp_buf];
; 428  :         const _Elem _Ch = _Traits::to_char_type(_Meta);

  00161	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  00169	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  0016e	88 84 24 90 00
	00 00		 mov	 BYTE PTR _Ch$[rsp], al

; 429  :         const _Elem* _Src;
; 430  :         char* _Dest;
; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

  00175	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0017d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00181	48 89 44 24 70	 mov	 QWORD PTR tv170[rsp], rax
  00186	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR _Str$[rsp+32]
  0018e	48 8d 8c 24 91
	00 00 00	 lea	 rcx, QWORD PTR _Ch$[rsp+1]
  00196	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR this$[rsp]
  0019e	48 83 c2 74	 add	 rdx, 116		; 00000074H
  001a2	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR _Dest$[rsp]
  001aa	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  001af	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001b4	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR _Str$[rsp]
  001bc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c1	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR _Src$[rsp]
  001c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ce	4c 8b c9	 mov	 r9, rcx
  001d1	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR _Ch$[rsp]
  001d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv170[rsp]
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  001e4	89 44 24 44	 mov	 DWORD PTR tv171[rsp], eax
  001e8	83 7c 24 44 00	 cmp	 DWORD PTR tv171[rsp], 0
  001ed	0f 8c dc 00 00
	00		 jl	 $LN12@overflow
  001f3	83 7c 24 44 01	 cmp	 DWORD PTR tv171[rsp], 1
  001f8	7e 10		 jle	 SHORT $LN8@overflow
  001fa	83 7c 24 44 03	 cmp	 DWORD PTR tv171[rsp], 3
  001ff	0f 84 8b 00 00
	00		 je	 $LN11@overflow
  00205	e9 c5 00 00 00	 jmp	 $LN12@overflow
$LN8@overflow:

; 432  :             _Dest)) { // test result of converting one element
; 433  :         case codecvt_base::partial:
; 434  :         case codecvt_base::ok: { // converted something, try to put it out
; 435  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

  0020a	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR _Str$[rsp]
  00212	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Dest$[rsp]
  0021a	48 2b c8	 sub	 rcx, rax
  0021d	48 8b c1	 mov	 rax, rcx
  00220	48 89 44 24 58	 mov	 QWORD PTR _Count$2[rsp], rax

; 436  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  00225	48 83 7c 24 58
	00		 cmp	 QWORD PTR _Count$2[rsp], 0
  0022b	76 35		 jbe	 SHORT $LN9@overflow
  0022d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00235	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  0023c	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Count$2[rsp]
  00241	ba 01 00 00 00	 mov	 edx, 1
  00246	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR _Str$[rsp]
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00254	48 39 44 24 58	 cmp	 QWORD PTR _Count$2[rsp], rax
  00259	74 07		 je	 SHORT $LN9@overflow

; 437  :                 return _Traits::eof(); // write failed

  0025b	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00260	eb 72		 jmp	 SHORT $LN1@overflow
$LN9@overflow:

; 438  :             }
; 439  : 
; 440  :             _Wrotesome = true; // write succeeded

  00262	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0026a	c6 40 71 01	 mov	 BYTE PTR [rax+113], 1

; 441  :             if (_Src != &_Ch) {

  0026e	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR _Ch$[rsp]
  00276	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR _Src$[rsp], rax
  0027e	74 09		 je	 SHORT $LN10@overflow

; 442  :                 return _Meta; // converted whole element

  00280	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _Meta$[rsp]
  00287	eb 4b		 jmp	 SHORT $LN1@overflow
$LN10@overflow:

; 443  :             }
; 444  : 
; 445  :             return _Traits::eof(); // conversion failed

  00289	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0028e	eb 44		 jmp	 SHORT $LN1@overflow
$LN11@overflow:

; 446  :         }
; 447  : 
; 448  :         case codecvt_base::noconv:
; 449  :             // no conversion, put as is
; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  00290	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00298	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  0029f	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR _Ch$[rsp]
  002a7	e8 00 00 00 00	 call	 ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ; std::_Fputc<char>
  002ac	0f b6 c0	 movzx	 eax, al
  002af	85 c0		 test	 eax, eax
  002b1	74 0d		 je	 SHORT $LN16@overflow
  002b3	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _Meta$[rsp]
  002ba	89 44 24 4c	 mov	 DWORD PTR tv192[rsp], eax
  002be	eb 09		 jmp	 SHORT $LN17@overflow
$LN16@overflow:
  002c0	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  002c5	89 44 24 4c	 mov	 DWORD PTR tv192[rsp], eax
$LN17@overflow:
  002c9	8b 44 24 4c	 mov	 eax, DWORD PTR tv192[rsp]
  002cd	eb 05		 jmp	 SHORT $LN1@overflow
$LN12@overflow:

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed

  002cf	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
$LN1@overflow:

; 454  :         }
; 455  :     }

  002d4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002dc	48 33 cc	 xor	 rcx, rsp
  002df	e8 00 00 00 00	 call	 __security_check_cookie
  002e4	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  002eb	c3		 ret	 0
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 399  :     virtual void __CLR_OR_THIS_CALL _Unlock() override { // unlock file instead of stream buffer

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 400  :         if (_Myfile) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	74 12		 je	 SHORT $LN2@Unlock

; 401  :             _CSTD _unlock_file(_Myfile);

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__unlock_file
$LN2@Unlock:

; 402  :         }
; 403  :     }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT

; 393  :     virtual void __CLR_OR_THIS_CALL _Lock() override { // lock file instead of stream buffer

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 394  :         if (_Myfile) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	74 12		 je	 SHORT $LN2@Lock

; 395  :             _CSTD _lock_file(_Myfile);

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lock_file
$LN2@Lock:

; 396  :         }
; 397  :     }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
_TEXT	SEGMENT
_Ans$ = 32
this$ = 64
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT

; 374  :     basic_filebuf* close() {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 375  :         basic_filebuf* _Ans;
; 376  :         if (_Myfile) { // put any homing sequence and close file

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	74 45		 je	 SHORT $LN2@close

; 377  :             _Ans = this;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR _Ans$[rsp], rax

; 378  :             if (!_Endwrite()) {

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	85 c0		 test	 eax, eax
  00031	75 09		 jne	 SHORT $LN4@close

; 379  :                 _Ans = nullptr;

  00033	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR _Ans$[rsp], 0
$LN4@close:

; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  0004e	85 c0		 test	 eax, eax
  00050	74 09		 je	 SHORT $LN5@close

; 383  :                 _Ans = nullptr;

  00052	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR _Ans$[rsp], 0
$LN5@close:

; 384  :             }
; 385  :         } else {

  0005b	eb 09		 jmp	 SHORT $LN3@close
$LN2@close:

; 386  :             _Ans = nullptr;

  0005d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR _Ans$[rsp], 0
$LN3@close:

; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);

  00066	41 b8 02 00 00
	00		 mov	 r8d, 2
  0006c	33 d2		 xor	 edx, edx
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00073	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 390  :         return _Ans;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR _Ans$[rsp]

; 391  :     }

  0007d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00081	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
_TEXT	SEGMENT
_File$ = 32
tv89 = 40
tv88 = 48
$T1 = 56
this$ = 96
_Filename$ = 104
_Mode$ = 112
_Prot$ = 120
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT

; 275  :     basic_filebuf* open(const char* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 276  :         // _Prot is an extension
; 277  :         if (_Myfile) {

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00025	74 04		 je	 SHORT $LN2@open

; 278  :             return nullptr;

  00027	33 c0		 xor	 eax, eax
  00029	eb 7f		 jmp	 SHORT $LN1@open
$LN2@open:

; 279  :         }
; 280  : 
; 281  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

  0002b	44 8b 44 24 78	 mov	 r8d, DWORD PTR _Prot$[rsp]
  00030	8b 54 24 70	 mov	 edx, DWORD PTR _Mode$[rsp]
  00034	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Filename$[rsp]
  00039	e8 00 00 00 00	 call	 ?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z ; std::_Fiopen
  0003e	48 89 44 24 20	 mov	 QWORD PTR _File$[rsp], rax

; 282  :         if (!_File) {

  00043	48 83 7c 24 20
	00		 cmp	 QWORD PTR _File$[rsp], 0
  00049	75 04		 jne	 SHORT $LN3@open

; 283  :             return nullptr; // open failed

  0004b	33 c0		 xor	 eax, eax
  0004d	eb 5b		 jmp	 SHORT $LN1@open
$LN3@open:

; 284  :         }
; 285  : 
; 286  :         _Init(_File, _Openfl);

  0004f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00055	48 8b 54 24 20	 mov	 rdx, QWORD PTR _File$[rsp]
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0005f	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  00064	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T1[rsp]
  00069	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
  00074	48 89 44 24 28	 mov	 QWORD PTR tv89[rsp], rax
  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR tv89[rsp]
  0007e	48 89 44 24 30	 mov	 QWORD PTR tv88[rsp], rax
  00083	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv88[rsp]
  00088	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  0008d	48 8b d0	 mov	 rdx, rax
  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00095	e8 00 00 00 00	 call	 ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
  0009a	90		 npad	 1
  0009b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T1[rsp]
  000a0	e8 00 00 00 00	 call	 ??1locale@std@@QEAA@XZ	; std::locale::~locale

; 288  :         return this; // open succeeded

  000a5	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
$LN1@open:

; 289  :     }

  000aa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ae	c3		 ret	 0
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_File$ = 32
tv89 = 40
tv88 = 48
$T1 = 56
this$ = 96
_Filename$ = 104
_Mode$ = 112
_Prot$ = 120
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR $T1[rbp]
  0000d	e8 00 00 00 00	 call	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_File$ = 32
tv89 = 40
tv88 = 48
$T1 = 56
this$ = 96
_Filename$ = 104
_Mode$ = 112
_Prot$ = 120
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR $T1[rbp]
  0000d	e8 00 00 00 00	 call	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT

; 170  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx

; 171  :         if (_Myfile) {

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00025	74 0a		 je	 SHORT $LN2@basic_file

; 172  :             _Reset_back(); // revert from _Mychar buffer

  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
$LN2@basic_file:

; 173  :         }
; 174  : 
; 175  :         if (_Closef) {

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  0003a	85 c0		 test	 eax, eax
  0003c	74 0a		 je	 SHORT $LN3@basic_file

; 176  :             close();

  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00043	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN3@basic_file:

; 177  :         }
; 178  :     }

  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00053	90		 npad	 1
  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT

; 162  :     basic_filebuf() : _Mysb() {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00014	90		 npad	 1
  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00021	48 89 08	 mov	 QWORD PTR [rax], rcx

; 163  :         _Init(nullptr, _Newfl);

  00024	45 33 c0	 xor	 r8d, r8d
  00027	33 d2		 xor	 edx, edx
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002e	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
  00033	90		 npad	 1

; 164  :     }

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 30	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 30	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT

; 944  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 80 50 ff
	ff ff		 mov	 rax, QWORD PTR [rax-176]
  00015	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00025	48 89 94 01 50
	ff ff ff	 mov	 QWORD PTR [rcx+rax-176], rdx
  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 8b 80 50 ff
	ff ff		 mov	 rax, QWORD PTR [rax-176]
  00039	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003d	48 2d b0 00 00
	00		 sub	 rax, 176		; 000000b0H
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00048	48 8b 89 50 ff
	ff ff		 mov	 rcx, QWORD PTR [rcx-176]
  0004f	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00053	48 8b 54 24 30	 mov	 rdx, QWORD PTR this$[rsp]
  00058	89 84 0a 4c ff
	ff ff		 mov	 DWORD PTR [rdx+rcx-180], eax
  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00064	48 2d a0 00 00
	00		 sub	 rax, 160		; 000000a0H
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00072	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00077	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  0007d	48 8b c8	 mov	 rcx, rax
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00086	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008a	c3		 ret	 0
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
_TEXT	SEGMENT
this$ = 64
_Str$ = 72
_Mode$ = 80
_Prot$ = 88
$initVBases$ = 96
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 815  :     explicit basic_ifstream(

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 816  :         const string& _Str, ios_base::openmode _Mode = ios_base::in, int _Prot = ios_base::_Default_open_prot)
; 817  :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Str$[rsp]
  0001d	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00022	8b 4c 24 60	 mov	 ecx, DWORD PTR $initVBases$[rsp]
  00026	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0002a	44 8b 4c 24 58	 mov	 r9d, DWORD PTR _Prot$[rsp]
  0002f	44 8b 44 24 50	 mov	 r8d, DWORD PTR _Mode$[rsp]
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003c	e8 00 00 00 00	 call	 ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00059	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00062	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00065	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00069	48 2d b0 00 00
	00		 sub	 rax, 176		; 000000b0H
  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00074	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00077	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  0007b	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  00080	89 44 0a fc	 mov	 DWORD PTR [rdx+rcx-4], eax
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
_TEXT	SEGMENT
$T1 = 32
tv171 = 40
tv187 = 48
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
$initVBases$ = 112
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 806  :     explicit basic_ifstream(

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 807  :         const char* _Filename, ios_base::openmode _Mode = ios_base::in, int _Prot = ios_base::_Default_open_prot)
; 808  :         : _Mybase(_STD addressof(_Filebuffer)) {

  00020	83 7c 24 70 00	 cmp	 DWORD PTR $initVBases$[rsp], 0
  00025	74 2f		 je	 SHORT $LN2@basic_ifst
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  00033	48 89 08	 mov	 QWORD PTR [rax], rcx
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  00041	48 8b c8	 mov	 rcx, rax
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0004a	90		 npad	 1
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  0004f	83 c8 01	 or	 eax, 1
  00052	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
$LN2@basic_ifst:
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0005b	48 83 c0 10	 add	 rax, 16
  0005f	48 8b c8	 mov	 rcx, rax
  00062	e8 00 00 00 00	 call	 ??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	45 33 c0	 xor	 r8d, r8d
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0007b	90		 npad	 1
  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00081	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00084	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00088	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00094	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0009d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000a4	48 2d b0 00 00
	00		 sub	 rax, 176		; 000000b0H
  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000af	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b2	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  000b6	48 8b 54 24 50	 mov	 rdx, QWORD PTR this$[rsp]
  000bb	89 44 0a fc	 mov	 DWORD PTR [rdx+rcx-4], eax
  000bf	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000c4	48 83 c0 10	 add	 rax, 16
  000c8	48 8b c8	 mov	 rcx, rax
  000cb	e8 00 00 00 00	 call	 ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
  000d0	90		 npad	 1

; 809  :         // _Prot is an extension
; 810  :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot)) {

  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000d6	48 83 c0 10	 add	 rax, 16
  000da	48 89 44 24 28	 mov	 QWORD PTR tv171[rsp], rax
  000df	8b 44 24 60	 mov	 eax, DWORD PTR _Mode$[rsp]
  000e3	83 c8 01	 or	 eax, 1
  000e6	44 8b 4c 24 68	 mov	 r9d, DWORD PTR _Prot$[rsp]
  000eb	44 8b c0	 mov	 r8d, eax
  000ee	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Filename$[rsp]
  000f3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv171[rsp]
  000f8	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000fd	48 85 c0	 test	 rax, rax
  00100	75 30		 jne	 SHORT $LN3@basic_ifst

; 811  :             _Myios::setstate(ios_base::failbit);

  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00107	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0010e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00113	48 03 c8	 add	 rcx, rax
  00116	48 8b c1	 mov	 rax, rcx
  00119	48 89 44 24 30	 mov	 QWORD PTR tv187[rsp], rax
  0011e	45 33 c0	 xor	 r8d, r8d
  00121	ba 02 00 00 00	 mov	 edx, 2
  00126	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv187[rsp]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00131	90		 npad	 1
$LN3@basic_ifst:

; 812  :         }
; 813  :     }

  00132	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00137	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013b	c3		 ret	 0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv171 = 40
tv187 = 48
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
$initVBases$ = 112
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN6@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN6@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv171 = 40
tv187 = 48
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
$initVBases$ = 112
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 18	 add	 rcx, 24
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv171 = 40
tv187 = 48
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
$initVBases$ = 112
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 10	 add	 rcx, 16
  00011	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv171 = 40
tv187 = 48
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
$initVBases$ = 112
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN6@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN6@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv171 = 40
tv187 = 48
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
$initVBases$ = 112
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 18	 add	 rcx, 24
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv171 = 40
tv187 = 48
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
$initVBases$ = 112
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 10	 add	 rcx, 16
  00011	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
i$1 = 48
$T2 = 52
$T3 = 56
$T4 = 64
tv149 = 72
$T5 = 80
$T6 = 88
$T7 = 96
InputFile$ = 112
Line$8 = 384
__$ArrayPad$ = 416
File$ = 448
?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; SmLoadFromFile, COMDAT

; 497  : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 498  : 	Symbols.clear();

  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  00025	e8 00 00 00 00	 call	 ?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::clear

; 499  : 	std::ifstream InputFile(File);

  0002a	ba 10 01 00 00	 mov	 edx, 272		; 00000110H
  0002f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR InputFile$[rsp]
  00034	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
  00039	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00041	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00047	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004d	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR File$[rsp]
  00055	48 8d 4c 24 70	 lea	 rcx, QWORD PTR InputFile$[rsp]
  0005a	e8 00 00 00 00	 call	 ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
  0005f	90		 npad	 1

; 500  : 
; 501  : 	if (InputFile.bad())

  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR InputFile$[rsp]
  00065	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00069	48 8d 44 04 70	 lea	 rax, QWORD PTR InputFile$[rsp+rax]
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?bad@ios_base@std@@QEBA_NXZ
  00077	0f b6 c0	 movzx	 eax, al
  0007a	85 c0		 test	 eax, eax
  0007c	74 1c		 je	 SHORT $LN14@SmLoadFrom

; 502  : 	{
; 503  : 		printf("Bad File.\n");

  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG133928
  00085	e8 00 00 00 00	 call	 printf
  0008a	90		 npad	 1

; 504  : 		return;

  0008b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR InputFile$[rsp]
  00090	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00095	e9 63 02 00 00	 jmp	 $LN1@SmLoadFrom
$LN14@SmLoadFrom:

; 505  : 	}
; 506  : 	for (std::string Line; std::getline(InputFile, Line); )

  0009a	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  000a2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000a7	90		 npad	 1
$LN2@SmLoadFrom:
  000a8	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR Line$8[rsp]
  000b0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR InputFile$[rsp]
  000b5	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  000ba	48 89 44 24 40	 mov	 QWORD PTR $T4[rsp], rax
  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR $T4[rsp]
  000c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T4[rsp]
  000d0	48 03 c8	 add	 rcx, rax
  000d3	48 8b c1	 mov	 rax, rcx
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bios_base@std@@QEBA_NXZ
  000df	0f b6 c0	 movzx	 eax, al
  000e2	85 c0		 test	 eax, eax
  000e4	0f 84 fb 01 00
	00		 je	 $LN3@SmLoadFrom

; 507  : 	{
; 508  : 		if (Line.length() < 1)

  000ea	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  000f2	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  000f7	48 83 f8 01	 cmp	 rax, 1
  000fb	73 02		 jae	 SHORT $LN15@SmLoadFrom

; 509  : 			continue;

  000fd	eb a9		 jmp	 SHORT $LN2@SmLoadFrom
$LN15@SmLoadFrom:

; 510  : 
; 511  : 		ULONG i;
; 512  : 		for (i = 0; i < Line.length(); i++) if (Line[i] == ';') break; //REMOVE COMMENTS

  000ff	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00107	eb 0a		 jmp	 SHORT $LN7@SmLoadFrom
$LN5@SmLoadFrom:
  00109	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0010d	ff c0		 inc	 eax
  0010f	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN7@SmLoadFrom:
  00113	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00117	48 89 44 24 48	 mov	 QWORD PTR tv149[rsp], rax
  0011c	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00124	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00129	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv149[rsp]
  0012e	48 3b c8	 cmp	 rcx, rax
  00131	73 1f		 jae	 SHORT $LN8@SmLoadFrom
  00133	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00137	8b d0		 mov	 edx, eax
  00139	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00141	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00146	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00149	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  0014c	75 02		 jne	 SHORT $LN16@SmLoadFrom
  0014e	eb 02		 jmp	 SHORT $LN8@SmLoadFrom
$LN16@SmLoadFrom:
  00150	eb b7		 jmp	 SHORT $LN5@SmLoadFrom
$LN8@SmLoadFrom:

; 513  : 		while (Line.length() > i) Line.pop_back();

  00152	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  0015a	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  0015f	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00163	48 3b c1	 cmp	 rax, rcx
  00166	76 0f		 jbe	 SHORT $LN10@SmLoadFrom
  00168	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00170	e8 00 00 00 00	 call	 ?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back
  00175	eb db		 jmp	 SHORT $LN8@SmLoadFrom
$LN10@SmLoadFrom:

; 514  : 		while (!Line.empty() && (Line[Line.length() - 1] == (CHAR)9 || Line[Line.length() - 1] == ' ')) Line.pop_back();

  00177	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  0017f	e8 00 00 00 00	 call	 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
  00184	0f b6 c0	 movzx	 eax, al
  00187	85 c0		 test	 eax, eax
  00189	75 5f		 jne	 SHORT $LN12@SmLoadFrom
  0018b	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00193	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00198	48 ff c8	 dec	 rax
  0019b	48 8b d0	 mov	 rdx, rax
  0019e	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  001a6	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  001ab	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ae	83 f8 09	 cmp	 eax, 9
  001b1	74 28		 je	 SHORT $LN17@SmLoadFrom
  001b3	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  001bb	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  001c0	48 ff c8	 dec	 rax
  001c3	48 8b d0	 mov	 rdx, rax
  001c6	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  001ce	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  001d3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001d6	83 f8 20	 cmp	 eax, 32			; 00000020H
  001d9	75 0f		 jne	 SHORT $LN12@SmLoadFrom
$LN17@SmLoadFrom:
  001db	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  001e3	e8 00 00 00 00	 call	 ?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back
  001e8	eb 8d		 jmp	 SHORT $LN10@SmLoadFrom
$LN12@SmLoadFrom:

; 515  : 		while (!Line.empty() && !std::isalpha(Line[0])) Line.erase(Line.begin());

  001ea	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  001f2	e8 00 00 00 00	 call	 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
  001f7	0f b6 c0	 movzx	 eax, al
  001fa	85 c0		 test	 eax, eax
  001fc	75 51		 jne	 SHORT $LN13@SmLoadFrom
  001fe	33 d2		 xor	 edx, edx
  00200	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00208	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0020d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00210	8b c8		 mov	 ecx, eax
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalpha
  00218	85 c0		 test	 eax, eax
  0021a	75 33		 jne	 SHORT $LN13@SmLoadFrom
  0021c	48 8d 54 24 58	 lea	 rdx, QWORD PTR $T6[rsp]
  00221	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00229	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  0022e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00231	48 89 44 24 50	 mov	 QWORD PTR $T5[rsp], rax
  00236	4c 8b 44 24 50	 mov	 r8, QWORD PTR $T5[rsp]
  0023b	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T7[rsp]
  00240	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00248	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0024d	eb 9b		 jmp	 SHORT $LN12@SmLoadFrom
$LN13@SmLoadFrom:

; 516  : 
; 517  : 		if (Line.length() < 1)

  0024f	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00257	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  0025c	48 83 f8 01	 cmp	 rax, 1
  00260	73 05		 jae	 SHORT $LN18@SmLoadFrom

; 518  : 			continue;

  00262	e9 41 fe ff ff	 jmp	 $LN2@SmLoadFrom
$LN18@SmLoadFrom:

; 519  : 
; 520  : 		if (Line[Line.length() - 1] == ':') // IS LABEL

  00267	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  0026f	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00274	48 ff c8	 dec	 rax
  00277	48 8b d0	 mov	 rdx, rax
  0027a	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00282	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00287	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0028a	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0028d	75 30		 jne	 SHORT $LN19@SmLoadFrom

; 521  : 		{
; 522  : 			Line.pop_back();

  0028f	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  00297	e8 00 00 00 00	 call	 ?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back

; 523  : 			Symbols.emplace_back(TRUE, Line);

  0029c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR $T2[rsp], 1
  002a4	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR Line$8[rsp]
  002ac	48 8d 54 24 34	 lea	 rdx, QWORD PTR $T2[rsp]
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  002b8	e8 00 00 00 00	 call	 ??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::emplace_back<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>

; 524  : 		}

  002bd	eb 21		 jmp	 SHORT $LN20@SmLoadFrom
$LN19@SmLoadFrom:

; 525  : 		else
; 526  : 		{
; 527  : 			Symbols.emplace_back(FALSE, Line);

  002bf	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR $T3[rsp], 0
  002c7	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR Line$8[rsp]
  002cf	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T3[rsp]
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  002db	e8 00 00 00 00	 call	 ??$emplace_back@HAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@$$QEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::emplace_back<int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
$LN20@SmLoadFrom:

; 528  : 		}

  002e0	e9 c3 fd ff ff	 jmp	 $LN2@SmLoadFrom
$LN3@SmLoadFrom:

; 529  : 	}

  002e5	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Line$8[rsp]
  002ed	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002f2	90		 npad	 1

; 530  : }

  002f3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR InputFile$[rsp]
  002f8	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
$LN1@SmLoadFrom:
  002fd	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00305	48 33 cc	 xor	 rcx, rsp
  00308	e8 00 00 00 00	 call	 __security_check_cookie
  0030d	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  00314	c3		 ret	 0
?SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; SmLoadFromFile
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 48
$T2 = 52
$T3 = 56
$T4 = 64
tv149 = 72
$T5 = 80
$T6 = 88
$T7 = 96
InputFile$ = 112
Line$8 = 384
__$ArrayPad$ = 416
File$ = 448
?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `SmLoadFromFile'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 70	 lea	 rcx, QWORD PTR InputFile$[rbp]
  0000d	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `SmLoadFromFile'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1 = 48
$T2 = 52
$T3 = 56
$T4 = 64
tv149 = 72
$T5 = 80
$T6 = 88
$T7 = 96
InputFile$ = 112
Line$8 = 384
__$ArrayPad$ = 416
File$ = 448
?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `SmLoadFromFile'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 80 01
	00 00		 lea	 rcx, QWORD PTR Line$8[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `SmLoadFromFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 48
$T2 = 52
$T3 = 56
$T4 = 64
tv149 = 72
$T5 = 80
$T6 = 88
$T7 = 96
InputFile$ = 112
Line$8 = 384
__$ArrayPad$ = 416
File$ = 448
?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `SmLoadFromFile'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 70	 lea	 rcx, QWORD PTR InputFile$[rbp]
  0000d	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `SmLoadFromFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$1 = 48
$T2 = 52
$T3 = 56
$T4 = 64
tv149 = 72
$T5 = 80
$T6 = 88
$T7 = 96
InputFile$ = 112
Line$8 = 384
__$ArrayPad$ = 416
File$ = 448
?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `SmLoadFromFile'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 80 01
	00 00		 lea	 rcx, QWORD PTR Line$8[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$1@?0??SmLoadFromFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `SmLoadFromFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iomanip
;	COMDAT ??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z
_TEXT	SEGMENT
tv79 = 32
_Ostr$ = 64
_Manip$ = 72
??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,char>, COMDAT

; 49   :     const _Fillobj<_Elem2>& _Manip) { // set fill character in output stream

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 50   :     static_assert(is_same_v<_Elem, _Elem2>, "wrong character type for setfill");
; 51   : 
; 52   :     _Ostr.fill(_Manip._Fill);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0001f	48 03 c8	 add	 rcx, rax
  00022	48 8b c1	 mov	 rax, rcx
  00025	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR _Manip$[rsp]
  0002f	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv79[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z

; 53   :     return _Ostr;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR _Ostr$[rsp]

; 54   : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iomanip
;	COMDAT ??0?$_Fillobj@D@std@@QEAA@D@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
??0?$_Fillobj@D@std@@QEAA@D@Z PROC			; std::_Fillobj<char>::_Fillobj<char>, COMDAT

; 27   :     _Fillobj(_Elem _Ch) : _Fill(_Ch) {}

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR _Ch$[rsp]
  00013	88 08		 mov	 BYTE PTR [rax], cl
  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001a	c3		 ret	 0
??0?$_Fillobj@D@std@@QEAA@D@Z ENDP			; std::_Fillobj<char>::_Fillobj<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iomanip
;	COMDAT ??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Ch$ = 56
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z PROC		; std::setfill<char>, COMDAT

; 34   : _NODISCARD _Fillobj<_Elem> setfill(_Elem _Ch) {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 35   :     return _Fillobj<_Elem>(_Ch);

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR _Ch$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00017	e8 00 00 00 00	 call	 ??0?$_Fillobj@D@std@@QEAA@D@Z ; std::_Fillobj<char>::_Fillobj<char>
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 36   : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z ENDP		; std::setfill<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iomanip
;	COMDAT ??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z
_TEXT	SEGMENT
tv79 = 32
_Ostr$ = 64
_Manip$ = 72
??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,__int64>, COMDAT

; 423  :     const _Smanip<_Arg>& _Manip) { // insert by calling function with output stream and argument

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 424  :     (*_Manip._Pfun)(_Ostr, _Manip._Manarg);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR _Manip$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00020	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00023	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0002c	48 03 c8	 add	 rcx, rax
  0002f	48 8b c1	 mov	 rax, rcx
  00032	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Manip$[rsp]
  00037	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 54 24 20	 call	 QWORD PTR tv79[rsp]

; 425  :     return _Ostr;

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR _Ostr$[rsp]

; 426  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_State$ = 32
tv311 = 36
tv192 = 37
tv316 = 38
tv254 = 39
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv312 = 60
$T1 = 64
$T2 = 68
tv317 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv310 = 96
tv194 = 104
tv313 = 112
tv219 = 120
tv314 = 128
tv315 = 136
tv256 = 144
tv277 = 152
tv291 = 160
tv306 = 168
$T5 = 176
_Ok$ = 184
__$ArrayPad$ = 200
_Ostr$ = 224
_Val$ = 232
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 735  :     const char* _Val) { // insert NTBS into char stream

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 736  :     using _Elem = char;
; 737  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 738  : 
; 739  :     ios_base::iostate _State = ios_base::goodbit;

  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _State$[rsp], 0

; 740  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  0002b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR _Val$[rsp]
  00033	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00038	48 89 44 24 30	 mov	 QWORD PTR _Count$[rsp], rax

; 741  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  0003d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0004c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00054	48 03 c8	 add	 rcx, rax
  00057	48 8b c1	 mov	 rax, rcx
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00063	48 85 c0	 test	 rax, rax
  00066	7e 5f		 jle	 SHORT $LN17@operator
  00068	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00070	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00073	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00077	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0007f	48 03 c8	 add	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 8b c8	 mov	 rcx, rax
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  0008e	48 3b 44 24 30	 cmp	 rax, QWORD PTR _Count$[rsp]
  00093	7e 32		 jle	 SHORT $LN17@operator
  00095	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0009d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000a4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  000bb	48 2b 44 24 30	 sub	 rax, QWORD PTR _Count$[rsp]
  000c0	48 89 44 24 58	 mov	 QWORD PTR tv137[rsp], rax
  000c5	eb 09		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000c7	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv137[rsp], 0
$LN18@operator:
  000d0	48 8b 44 24 58	 mov	 rax, QWORD PTR tv137[rsp]
  000d5	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax

; 742  :     const typename _Myos::sentry _Ok(_Ostr);

  000da	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR _Ostr$[rsp]
  000e2	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  000ea	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000ef	90		 npad	 1

; 743  : 
; 744  :     if (!_Ok) {

  000f0	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  000f8	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000fd	0f b6 c0	 movzx	 eax, al
  00100	85 c0		 test	 eax, eax
  00102	75 10		 jne	 SHORT $LN8@operator

; 745  :         _State |= ios_base::badbit;

  00104	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  00108	83 c8 04	 or	 eax, 4
  0010b	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 746  :     } else { // state okay, insert

  0010f	e9 a1 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 747  :         _TRY_IO_BEGIN
; 748  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00114	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0011c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011f	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00123	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0012b	48 03 c8	 add	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
  0013a	89 44 24 38	 mov	 DWORD PTR tv139[rsp], eax
  0013e	8b 44 24 38	 mov	 eax, DWORD PTR tv139[rsp]
  00142	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00147	83 f8 40	 cmp	 eax, 64			; 00000040H
  0014a	0f 84 d0 00 00
	00		 je	 $LN11@operator

; 749  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00150	eb 0d		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00152	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pad$[rsp]
  00157	48 ff c8	 dec	 rax
  0015a	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN4@operator:
  0015f	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pad$[rsp], 0
  00165	0f 8e b5 00 00
	00		 jle	 $LN11@operator

; 750  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0016b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00173	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00176	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0017a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00182	48 03 c8	 add	 rcx, rax
  00185	48 8b c1	 mov	 rax, rcx
  00188	48 8b c8	 mov	 rcx, rax
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00191	48 89 44 24 60	 mov	 QWORD PTR tv310[rsp], rax
  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR tv310[rsp]
  0019b	48 89 44 24 68	 mov	 QWORD PTR tv194[rsp], rax
  001a0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  001a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ab	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  001af	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  001b7	48 03 c8	 add	 rcx, rax
  001ba	48 8b c1	 mov	 rax, rcx
  001bd	48 8b c8	 mov	 rcx, rax
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  001c6	88 44 24 24	 mov	 BYTE PTR tv311[rsp], al
  001ca	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv311[rsp]
  001cf	88 44 24 25	 mov	 BYTE PTR tv192[rsp], al
  001d3	0f b6 54 24 25	 movzx	 edx, BYTE PTR tv192[rsp]
  001d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv194[rsp]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  001e3	89 44 24 3c	 mov	 DWORD PTR tv312[rsp], eax
  001e7	8b 44 24 3c	 mov	 eax, DWORD PTR tv312[rsp]
  001eb	89 44 24 40	 mov	 DWORD PTR $T1[rsp], eax
  001ef	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  001f4	89 44 24 44	 mov	 DWORD PTR $T2[rsp], eax
  001f8	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T1[rsp]
  001fd	48 8d 4c 24 44	 lea	 rcx, QWORD PTR $T2[rsp]
  00202	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00207	0f b6 c0	 movzx	 eax, al
  0020a	85 c0		 test	 eax, eax
  0020c	74 0d		 je	 SHORT $LN12@operator

; 751  :                     _State |= ios_base::badbit; // insertion failed, quit

  0020e	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  00212	83 c8 04	 or	 eax, 4
  00215	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 752  :                     break;

  00219	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 753  :                 }
; 754  :             }

  0021b	e9 32 ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 755  :         }
; 756  : 
; 757  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00220	83 7c 24 20 00	 cmp	 DWORD PTR _State$[rsp], 0
  00225	75 6f		 jne	 SHORT $LN13@operator
  00227	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0022f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00232	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00236	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0023e	48 03 c8	 add	 rcx, rax
  00241	48 8b c1	 mov	 rax, rcx
  00244	48 8b c8	 mov	 rcx, rax
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0024d	48 89 44 24 70	 mov	 QWORD PTR tv313[rsp], rax
  00252	48 8b 44 24 70	 mov	 rax, QWORD PTR tv313[rsp]
  00257	48 89 44 24 78	 mov	 QWORD PTR tv219[rsp], rax
  0025c	4c 8b 44 24 30	 mov	 r8, QWORD PTR _Count$[rsp]
  00261	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR _Val$[rsp]
  00269	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv219[rsp]
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00274	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv314[rsp], rax
  0027c	48 8b 44 24 30	 mov	 rax, QWORD PTR _Count$[rsp]
  00281	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR tv314[rsp], rax
  00289	74 0b		 je	 SHORT $LN13@operator

; 758  :             _State |= ios_base::badbit;

  0028b	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  0028f	83 c8 04	 or	 eax, 4
  00292	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax
$LN13@operator:

; 759  :         }
; 760  : 
; 761  :         if (_State == ios_base::goodbit) {

  00296	83 7c 24 20 00	 cmp	 DWORD PTR _State$[rsp], 0
  0029b	0f 85 dc 00 00
	00		 jne	 $LN14@operator

; 762  :             for (; 0 < _Pad; --_Pad) { // pad on right

  002a1	eb 0d		 jmp	 SHORT $LN7@operator
$LN5@operator:
  002a3	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pad$[rsp]
  002a8	48 ff c8	 dec	 rax
  002ab	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN7@operator:
  002b0	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pad$[rsp], 0
  002b6	0f 8e c1 00 00
	00		 jle	 $LN14@operator

; 763  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  002bc	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  002c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002cb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  002d3	48 03 c8	 add	 rcx, rax
  002d6	48 8b c1	 mov	 rax, rcx
  002d9	48 8b c8	 mov	 rcx, rax
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002e2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv315[rsp], rax
  002ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv315[rsp]
  002f2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv256[rsp], rax
  002fa	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00302	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00305	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00309	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00311	48 03 c8	 add	 rcx, rax
  00314	48 8b c1	 mov	 rax, rcx
  00317	48 8b c8	 mov	 rcx, rax
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  00320	88 44 24 26	 mov	 BYTE PTR tv316[rsp], al
  00324	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv316[rsp]
  00329	88 44 24 27	 mov	 BYTE PTR tv254[rsp], al
  0032d	0f b6 54 24 27	 movzx	 edx, BYTE PTR tv254[rsp]
  00332	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv256[rsp]
  0033a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  00340	89 44 24 48	 mov	 DWORD PTR tv317[rsp], eax
  00344	8b 44 24 48	 mov	 eax, DWORD PTR tv317[rsp]
  00348	89 44 24 4c	 mov	 DWORD PTR $T3[rsp], eax
  0034c	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00351	89 44 24 50	 mov	 DWORD PTR $T4[rsp], eax
  00355	48 8d 54 24 4c	 lea	 rdx, QWORD PTR $T3[rsp]
  0035a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  0035f	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00364	0f b6 c0	 movzx	 eax, al
  00367	85 c0		 test	 eax, eax
  00369	74 0d		 je	 SHORT $LN15@operator

; 764  :                     _State |= ios_base::badbit; // insertion failed, quit

  0036b	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  0036f	83 c8 04	 or	 eax, 4
  00372	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 765  :                     break;

  00376	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 766  :                 }
; 767  :             }

  00378	e9 26 ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 768  :         }
; 769  : 
; 770  :         _Ostr.width(0);

  0037d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00385	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00388	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0038c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00394	48 03 c8	 add	 rcx, rax
  00397	48 8b c1	 mov	 rax, rcx
  0039a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv277[rsp], rax
  003a2	33 d2		 xor	 edx, edx
  003a4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv277[rsp]
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
  003b2	90		 npad	 1
  003b3	eb 00		 jmp	 SHORT $LN9@operator
$LN23@operator:
$LN9@operator:

; 771  :         _CATCH_IO_(ios_base, _Ostr)
; 772  :     }
; 773  : 
; 774  :     _Ostr.setstate(_State);

  003b5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  003bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  003c4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  003cc	48 03 c8	 add	 rcx, rax
  003cf	48 8b c1	 mov	 rax, rcx
  003d2	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv306[rsp], rax
  003da	45 33 c0	 xor	 r8d, r8d
  003dd	8b 54 24 20	 mov	 edx, DWORD PTR _State$[rsp]
  003e1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv306[rsp]
  003e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 775  :     return _Ostr;

  003ef	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  003f7	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  003ff	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  00407	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  0040c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]

; 776  : }

  00414	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0041c	48 33 cc	 xor	 rcx, rsp
  0041f	e8 00 00 00 00	 call	 __security_check_cookie
  00424	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0042b	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv311 = 36
tv192 = 37
tv316 = 38
tv254 = 39
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv312 = 60
$T1 = 64
$T2 = 68
tv317 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv310 = 96
tv194 = 104
tv313 = 112
tv219 = 120
tv314 = 128
tv315 = 136
tv256 = 144
tv277 = 152
tv291 = 160
tv306 = 168
$T5 = 176
_Ok$ = 184
__$ArrayPad$ = 200
_Ostr$ = 224
_Val$ = 232
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d b8 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rbp]
  00010	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv311 = 36
tv192 = 37
tv316 = 38
tv254 = 39
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv312 = 60
$T1 = 64
$T2 = 68
tv317 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv310 = 96
tv194 = 104
tv313 = 112
tv219 = 120
tv314 = 128
tv315 = 136
tv256 = 144
tv277 = 152
tv291 = 160
tv306 = 168
$T5 = 176
_Ok$ = 184
__$ArrayPad$ = 200
_Ostr$ = 224
_Val$ = 232
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1

; 771  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 89 85 a0 00
	00 00		 mov	 QWORD PTR tv291[rbp], rax
  0002f	41 b0 01	 mov	 r8b, 1
  00032	ba 04 00 00 00	 mov	 edx, 4
  00037	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR tv291[rbp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00044	90		 npad	 1
  00045	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$1
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
  00052	cc		 int	 3
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv311 = 36
tv192 = 37
tv316 = 38
tv254 = 39
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv312 = 60
$T1 = 64
$T2 = 68
tv317 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv310 = 96
tv194 = 104
tv313 = 112
tv219 = 120
tv314 = 128
tv315 = 136
tv256 = 144
tv277 = 152
tv291 = 160
tv306 = 168
$T5 = 176
_Ok$ = 184
__$ArrayPad$ = 200
_Ostr$ = 224
_Val$ = 232
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d b8 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rbp]
  00010	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv311 = 36
tv192 = 37
tv316 = 38
tv254 = 39
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv312 = 60
$T1 = 64
$T2 = 68
tv317 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv310 = 96
tv194 = 104
tv313 = 112
tv219 = 120
tv314 = 128
tv315 = 136
tv256 = 144
tv277 = 152
tv291 = 160
tv306 = 168
$T5 = 176
_Ok$ = 184
__$ArrayPad$ = 200
_Ostr$ = 224
_Val$ = 232
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1

; 771  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 89 85 a0 00
	00 00		 mov	 QWORD PTR tv291[rbp], rax
  0002f	41 b0 01	 mov	 r8b, 1
  00032	ba 04 00 00 00	 mov	 edx, 4
  00037	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR tv291[rbp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00044	90		 npad	 1
  00045	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$1
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
  00052	cc		 int	 3
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00014	48 8b c8	 mov	 rcx, rax
  00017	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00027	48 8b c8	 mov	 rcx, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  00020	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  00024	83 e0 01	 and	 eax, 1
  00027	85 c0		 test	 eax, eax
  00029	74 18		 je	 SHORT $LN2@scalar
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  00036	ba f8 00 00 00	 mov	 edx, 248		; 000000f8H
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00048	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z
_TEXT	SEGMENT
_State$ = 0
_Mode$ = 32
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT

; 349  :     static int _Getstate(ios_base::openmode _Mode) { // convert open mode to stream state bits

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 350  :         int _State = 0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR _State$[rsp], 0

; 351  :         if (!(_Mode & ios_base::in)) {

  0000f	8b 44 24 20	 mov	 eax, DWORD PTR _Mode$[rsp]
  00013	83 e0 01	 and	 eax, 1
  00016	85 c0		 test	 eax, eax
  00018	75 09		 jne	 SHORT $LN2@Getstate

; 352  :             _State |= _Noread;

  0001a	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]
  0001d	83 c8 04	 or	 eax, 4
  00020	89 04 24	 mov	 DWORD PTR _State$[rsp], eax
$LN2@Getstate:

; 353  :         }
; 354  : 
; 355  :         if (!(_Mode & ios_base::out)) {

  00023	8b 44 24 20	 mov	 eax, DWORD PTR _Mode$[rsp]
  00027	83 e0 02	 and	 eax, 2
  0002a	85 c0		 test	 eax, eax
  0002c	75 09		 jne	 SHORT $LN3@Getstate

; 356  :             _State |= _Constant;

  0002e	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]
  00031	83 c8 02	 or	 eax, 2
  00034	89 04 24	 mov	 DWORD PTR _State$[rsp], eax
$LN3@Getstate:

; 357  :         }
; 358  : 
; 359  :         if (_Mode & ios_base::app) {

  00037	8b 44 24 20	 mov	 eax, DWORD PTR _Mode$[rsp]
  0003b	83 e0 08	 and	 eax, 8
  0003e	85 c0		 test	 eax, eax
  00040	74 09		 je	 SHORT $LN4@Getstate

; 360  :             _State |= _Append;

  00042	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]
  00045	83 c8 08	 or	 eax, 8
  00048	89 04 24	 mov	 DWORD PTR _State$[rsp], eax
$LN4@Getstate:

; 361  :         }
; 362  : 
; 363  :         if (_Mode & ios_base::ate) {

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Mode$[rsp]
  0004f	83 e0 04	 and	 eax, 4
  00052	85 c0		 test	 eax, eax
  00054	74 09		 je	 SHORT $LN5@Getstate

; 364  :             _State |= _Atend;

  00056	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]
  00059	83 c8 10	 or	 eax, 16
  0005c	89 04 24	 mov	 DWORD PTR _State$[rsp], eax
$LN5@Getstate:

; 365  :         }
; 366  : 
; 367  :         return _State;

  0005f	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]

; 368  :     }

  00062	48 83 c4 18	 add	 rsp, 24
  00066	c3		 ret	 0
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
_TEXT	SEGMENT
tv88 = 32
tv141 = 40
tv139 = 48
tv143 = 56
this$ = 80
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT

; 329  :     void _Tidy() noexcept { // discard any allocated buffer and clear pointers

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 330  :         if (_Mystate & _Allocated) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00011	83 e0 01	 and	 eax, 1
  00014	85 c0		 test	 eax, eax
  00016	0f 84 87 00 00
	00		 je	 $LN2@Tidy

; 331  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 83 c0 74	 add	 rax, 116		; 00000074H
  00025	48 89 44 24 38	 mov	 QWORD PTR tv143[rsp], rax
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00035	48 85 c0	 test	 rax, rax
  00038	74 12		 je	 SHORT $LN4@Tidy
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00045	48 89 44 24 20	 mov	 QWORD PTR tv88[rsp], rax
  0004a	eb 10		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00057	48 89 44 24 20	 mov	 QWORD PTR tv88[rsp], rax
$LN5@Tidy:
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00067	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv88[rsp]
  0006c	48 2b c8	 sub	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	48 89 44 24 28	 mov	 QWORD PTR tv141[rsp], rax
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
  0008a	48 89 44 24 30	 mov	 QWORD PTR tv139[rsp], rax
  0008f	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv141[rsp]
  00094	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv139[rsp]
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv143[rsp]
  0009e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN2@Tidy:

; 332  :                 static_cast<typename allocator_traits<allocator_type>::size_type>(
; 333  :                     (_Mysb::pptr() ? _Mysb::epptr() : _Mysb::egptr()) - _Mysb::eback()));
; 334  :         }
; 335  : 
; 336  :         _Mysb::setg(nullptr, nullptr, nullptr);

  000a3	45 33 c9	 xor	 r9d, r9d
  000a6	45 33 c0	 xor	 r8d, r8d
  000a9	33 d2		 xor	 edx, edx
  000ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 337  :         _Mysb::setp(nullptr, nullptr);

  000b6	45 33 c0	 xor	 r8d, r8d
  000b9	33 d2		 xor	 edx, edx
  000bb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z

; 338  :         _Seekhigh = nullptr;

  000c6	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000cb	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 339  :         _Mystate &= ~_Allocated;

  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000d8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000db	83 e0 fe	 and	 eax, -2
  000de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000e3	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 340  :     }

  000e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ea	c3		 ret	 0
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Pptr_old$ = 32
_Seeklow$ = 40
_Off$ = 48
_Gptr_old$ = 56
_Newptr$ = 64
_Seekdist$ = 72
this$ = 96
__$ReturnUdt$ = 104
_Pos$ = 112
_Mode$ = 120
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT

; 264  :     virtual pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out) {

$LN10:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 265  :         // change position to _Pos, according to _Mode
; 266  :         const auto _Off      = static_cast<streamoff>(_Pos);

  00018	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _Pos$[rsp]
  0001d	e8 00 00 00 00	 call	 ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ; std::fpos<_Mbstatet>::operator __int64
  00022	48 89 44 24 30	 mov	 QWORD PTR _Off$[rsp], rax

; 267  :         const auto _Gptr_old = _Mysb::gptr();

  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00032	48 89 44 24 38	 mov	 QWORD PTR _Gptr_old$[rsp], rax

; 268  :         const auto _Pptr_old = _Mysb::pptr();

  00037	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00042	48 89 44 24 20	 mov	 QWORD PTR _Pptr_old$[rsp], rax

; 269  :         if (_Pptr_old && _Seekhigh < _Pptr_old) { // update high-water pointer

  00047	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  0004d	74 1e		 je	 SHORT $LN2@seekpos
  0004f	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  00059	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  0005d	73 0e		 jae	 SHORT $LN2@seekpos

; 270  :             _Seekhigh = _Pptr_old;

  0005f	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  00069	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN2@seekpos:

; 271  :         }
; 272  : 
; 273  :         const auto _Seeklow  = _Mysb::eback();

  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00078	48 89 44 24 28	 mov	 QWORD PTR _Seeklow$[rsp], rax

; 274  :         const auto _Seekdist = _Seekhigh - _Seeklow;

  0007d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00082	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Seeklow$[rsp]
  00087	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008b	48 2b c1	 sub	 rax, rcx
  0008e	48 89 44 24 48	 mov	 QWORD PTR _Seekdist$[rsp], rax

; 275  :         if (static_cast<unsigned long long>(_Off) > static_cast<unsigned long long>(_Seekdist)) {

  00093	48 8b 44 24 48	 mov	 rax, QWORD PTR _Seekdist$[rsp]
  00098	48 39 44 24 30	 cmp	 QWORD PTR _Off$[rsp], rax
  0009d	76 1b		 jbe	 SHORT $LN3@seekpos

; 276  :             return pos_type(off_type(-1));

  0009f	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  000a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000ab	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  000b0	48 8b 44 24 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  000b5	e9 d9 00 00 00	 jmp	 $LN1@seekpos
$LN3@seekpos:

; 277  :         }
; 278  : 
; 279  :         if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {

  000ba	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Off$[rsp], 0
  000c0	74 41		 je	 SHORT $LN4@seekpos
  000c2	8b 44 24 78	 mov	 eax, DWORD PTR _Mode$[rsp]
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	74 08		 je	 SHORT $LN6@seekpos
  000cd	48 83 7c 24 38
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  000d3	74 13		 je	 SHORT $LN5@seekpos
$LN6@seekpos:
  000d5	8b 44 24 78	 mov	 eax, DWORD PTR _Mode$[rsp]
  000d9	83 e0 02	 and	 eax, 2
  000dc	85 c0		 test	 eax, eax
  000de	74 23		 je	 SHORT $LN4@seekpos
  000e0	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  000e6	75 1b		 jne	 SHORT $LN4@seekpos
$LN5@seekpos:

; 280  :             return pos_type(off_type(-1));

  000e8	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  000ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000f4	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  000fe	e9 90 00 00 00	 jmp	 $LN1@seekpos
$LN4@seekpos:

; 281  :         }
; 282  : 
; 283  :         const auto _Newptr = _Seeklow + _Off; // may perform nullptr + 0

  00103	48 8b 44 24 30	 mov	 rax, QWORD PTR _Off$[rsp]
  00108	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Seeklow$[rsp]
  0010d	48 03 c8	 add	 rcx, rax
  00110	48 8b c1	 mov	 rax, rcx
  00113	48 89 44 24 40	 mov	 QWORD PTR _Newptr$[rsp], rax

; 284  :         if ((_Mode & ios_base::in) && _Gptr_old) {

  00118	8b 44 24 78	 mov	 eax, DWORD PTR _Mode$[rsp]
  0011c	83 e0 01	 and	 eax, 1
  0011f	85 c0		 test	 eax, eax
  00121	74 26		 je	 SHORT $LN7@seekpos
  00123	48 83 7c 24 38
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  00129	74 1e		 je	 SHORT $LN7@seekpos

; 285  :             _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);

  0012b	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00130	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00134	4c 8b 44 24 40	 mov	 r8, QWORD PTR _Newptr$[rsp]
  00139	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Seeklow$[rsp]
  0013e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN7@seekpos:

; 286  :         }
; 287  : 
; 288  :         if ((_Mode & ios_base::out) && _Pptr_old) {

  00149	8b 44 24 78	 mov	 eax, DWORD PTR _Mode$[rsp]
  0014d	83 e0 02	 and	 eax, 2
  00150	85 c0		 test	 eax, eax
  00152	74 2b		 je	 SHORT $LN8@seekpos
  00154	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  0015a	74 23		 je	 SHORT $LN8@seekpos

; 289  :             _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());

  0015c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00161	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00167	4c 8b c8	 mov	 r9, rax
  0016a	4c 8b 44 24 40	 mov	 r8, QWORD PTR _Newptr$[rsp]
  0016f	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Seeklow$[rsp]
  00174	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN8@seekpos:

; 290  :         }
; 291  : 
; 292  :         return pos_type(_Off);

  0017f	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Off$[rsp]
  00184	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00189	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  0018e	48 8b 44 24 68	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@seekpos:

; 293  :     }

  00193	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00197	c3		 ret	 0
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv88 = 32
_Both$1 = 36
_Seeklow$ = 40
_Pptr_old$ = 48
_Newoff$ = 56
_Gptr_old$ = 64
_Seekdist$ = 72
_Newptr$ = 80
this$ = 112
__$ReturnUdt$ = 120
_Off$ = 128
_Way$ = 136
_Mode$ = 144
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT

; 205  :         off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode = ios_base::in | ios_base::out) {

$LN23:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 206  :         // change position by _Off, according to _Way, _Mode
; 207  :         const auto _Gptr_old = _Mysb::gptr();

  00018	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00023	48 89 44 24 40	 mov	 QWORD PTR _Gptr_old$[rsp], rax

; 208  :         const auto _Pptr_old = _Mysb::pptr();

  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00033	48 89 44 24 30	 mov	 QWORD PTR _Pptr_old$[rsp], rax

; 209  :         if (_Pptr_old && _Seekhigh < _Pptr_old) { // update high-water pointer

  00038	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  0003e	74 1e		 je	 SHORT $LN4@seekoff
  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  0004a	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  0004e	73 0e		 jae	 SHORT $LN4@seekoff

; 210  :             _Seekhigh = _Pptr_old;

  00050	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  0005a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN4@seekoff:

; 211  :         }
; 212  : 
; 213  :         const auto _Seeklow  = _Mysb::eback();

  0005e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00069	48 89 44 24 28	 mov	 QWORD PTR _Seeklow$[rsp], rax

; 214  :         const auto _Seekdist = _Seekhigh - _Seeklow;

  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00073	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Seeklow$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 2b c1	 sub	 rax, rcx
  0007f	48 89 44 24 48	 mov	 QWORD PTR _Seekdist$[rsp], rax

; 215  :         off_type _Newoff;
; 216  :         switch (_Way) {

  00084	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR _Way$[rsp]
  0008b	89 44 24 20	 mov	 DWORD PTR tv88[rsp], eax
  0008f	83 7c 24 20 00	 cmp	 DWORD PTR tv88[rsp], 0
  00094	74 13		 je	 SHORT $LN5@seekoff
  00096	83 7c 24 20 01	 cmp	 DWORD PTR tv88[rsp], 1
  0009b	74 29		 je	 SHORT $LN7@seekoff
  0009d	83 7c 24 20 02	 cmp	 DWORD PTR tv88[rsp], 2
  000a2	74 13		 je	 SHORT $LN6@seekoff
  000a4	e9 a0 00 00 00	 jmp	 $LN15@seekoff
$LN5@seekoff:

; 217  :         case ios_base::beg:
; 218  :             _Newoff = 0;

  000a9	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _Newoff$[rsp], 0

; 219  :             break;

  000b2	e9 ad 00 00 00	 jmp	 $LN2@seekoff
$LN6@seekoff:

; 220  :         case ios_base::end:
; 221  :             _Newoff = _Seekdist;

  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR _Seekdist$[rsp]
  000bc	48 89 44 24 38	 mov	 QWORD PTR _Newoff$[rsp], rax

; 222  :             break;

  000c1	e9 9e 00 00 00	 jmp	 $LN2@seekoff
$LN7@seekoff:

; 223  :         case ios_base::cur: {
; 224  :             constexpr auto _Both = ios_base::in | ios_base::out;

  000c6	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR _Both$1[rsp], 3

; 225  :             if ((_Mode & _Both) != _Both) { // prohibited by N4727 [stringbuf.virtuals] Table 107 "seekoff positioning"

  000ce	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  000d5	83 e0 03	 and	 eax, 3
  000d8	83 f8 03	 cmp	 eax, 3
  000db	74 6c		 je	 SHORT $LN8@seekoff

; 226  :                 if (_Mode & ios_base::in) {

  000dd	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  000e4	83 e0 01	 and	 eax, 1
  000e7	85 c0		 test	 eax, eax
  000e9	74 29		 je	 SHORT $LN9@seekoff

; 227  :                     if (_Gptr_old || !_Seeklow) {

  000eb	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  000f1	75 08		 jne	 SHORT $LN12@seekoff
  000f3	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Seeklow$[rsp], 0
  000f9	75 17		 jne	 SHORT $LN11@seekoff
$LN12@seekoff:

; 228  :                         _Newoff = _Gptr_old - _Seeklow;

  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR _Seeklow$[rsp]
  00100	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Gptr_old$[rsp]
  00105	48 2b c8	 sub	 rcx, rax
  00108	48 8b c1	 mov	 rax, rcx
  0010b	48 89 44 24 38	 mov	 QWORD PTR _Newoff$[rsp], rax

; 229  :                         break;

  00110	eb 52		 jmp	 SHORT $LN2@seekoff
$LN11@seekoff:

; 230  :                     }

  00112	eb 35		 jmp	 SHORT $LN10@seekoff
$LN9@seekoff:

; 231  :                 } else if ((_Mode & ios_base::out) && (_Pptr_old || !_Seeklow)) {

  00114	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  0011b	83 e0 02	 and	 eax, 2
  0011e	85 c0		 test	 eax, eax
  00120	74 27		 je	 SHORT $LN13@seekoff
  00122	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  00128	75 08		 jne	 SHORT $LN14@seekoff
  0012a	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Seeklow$[rsp], 0
  00130	75 17		 jne	 SHORT $LN13@seekoff
$LN14@seekoff:

; 232  :                     _Newoff = _Pptr_old - _Seeklow;

  00132	48 8b 44 24 28	 mov	 rax, QWORD PTR _Seeklow$[rsp]
  00137	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  0013c	48 2b c8	 sub	 rcx, rax
  0013f	48 8b c1	 mov	 rax, rcx
  00142	48 89 44 24 38	 mov	 QWORD PTR _Newoff$[rsp], rax

; 233  :                     break;

  00147	eb 1b		 jmp	 SHORT $LN2@seekoff
$LN13@seekoff:
$LN10@seekoff:
$LN8@seekoff:
$LN15@seekoff:

; 234  :                 }
; 235  :             }
; 236  :         }
; 237  : 
; 238  :             // fallthrough
; 239  :         default:
; 240  :             return pos_type(off_type(-1));

  00149	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00150	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00155	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  0015a	48 8b 44 24 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  0015f	e9 3e 01 00 00	 jmp	 $LN1@seekoff
$LN2@seekoff:

; 241  :         }
; 242  : 
; 243  :         if (static_cast<unsigned long long>(_Off) + _Newoff > static_cast<unsigned long long>(_Seekdist)) {

  00164	48 8b 44 24 38	 mov	 rax, QWORD PTR _Newoff$[rsp]
  00169	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Off$[rsp]
  00171	48 03 c8	 add	 rcx, rax
  00174	48 8b c1	 mov	 rax, rcx
  00177	48 3b 44 24 48	 cmp	 rax, QWORD PTR _Seekdist$[rsp]
  0017c	76 1b		 jbe	 SHORT $LN16@seekoff

; 244  :             return pos_type(off_type(-1));

  0017e	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0018a	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  0018f	48 8b 44 24 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  00194	e9 09 01 00 00	 jmp	 $LN1@seekoff
$LN16@seekoff:

; 245  :         }
; 246  : 
; 247  :         _Off += _Newoff;

  00199	48 8b 44 24 38	 mov	 rax, QWORD PTR _Newoff$[rsp]
  0019e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Off$[rsp]
  001a6	48 03 c8	 add	 rcx, rax
  001a9	48 8b c1	 mov	 rax, rcx
  001ac	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR _Off$[rsp], rax

; 248  :         if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {

  001b4	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR _Off$[rsp], 0
  001bd	74 47		 je	 SHORT $LN17@seekoff
  001bf	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  001c6	83 e0 01	 and	 eax, 1
  001c9	85 c0		 test	 eax, eax
  001cb	74 08		 je	 SHORT $LN19@seekoff
  001cd	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  001d3	74 16		 je	 SHORT $LN18@seekoff
$LN19@seekoff:
  001d5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  001dc	83 e0 02	 and	 eax, 2
  001df	85 c0		 test	 eax, eax
  001e1	74 23		 je	 SHORT $LN17@seekoff
  001e3	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  001e9	75 1b		 jne	 SHORT $LN17@seekoff
$LN18@seekoff:

; 249  :             return pos_type(off_type(-1));

  001eb	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  001f2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  001f7	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  001fc	48 8b 44 24 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  00201	e9 9c 00 00 00	 jmp	 $LN1@seekoff
$LN17@seekoff:

; 250  :         }
; 251  : 
; 252  :         const auto _Newptr = _Seeklow + _Off; // may perform nullptr + 0

  00206	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Off$[rsp]
  0020e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Seeklow$[rsp]
  00213	48 03 c8	 add	 rcx, rax
  00216	48 8b c1	 mov	 rax, rcx
  00219	48 89 44 24 50	 mov	 QWORD PTR _Newptr$[rsp], rax

; 253  :         if ((_Mode & ios_base::in) && _Gptr_old) {

  0021e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  00225	83 e0 01	 and	 eax, 1
  00228	85 c0		 test	 eax, eax
  0022a	74 26		 je	 SHORT $LN20@seekoff
  0022c	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  00232	74 1e		 je	 SHORT $LN20@seekoff

; 254  :             _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);

  00234	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00239	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0023d	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Newptr$[rsp]
  00242	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Seeklow$[rsp]
  00247	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN20@seekoff:

; 255  :         }
; 256  : 
; 257  :         if ((_Mode & ios_base::out) && _Pptr_old) {

  00252	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  00259	83 e0 02	 and	 eax, 2
  0025c	85 c0		 test	 eax, eax
  0025e	74 2b		 je	 SHORT $LN21@seekoff
  00260	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  00266	74 23		 je	 SHORT $LN21@seekoff

; 258  :             _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());

  00268	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00273	4c 8b c8	 mov	 r9, rax
  00276	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Newptr$[rsp]
  0027b	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Seeklow$[rsp]
  00280	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN21@seekoff:

; 259  :         }
; 260  : 
; 261  :         return pos_type(_Off);

  0028b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR _Off$[rsp]
  00293	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00298	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  0029d	48 8b 44 24 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@seekoff:

; 262  :     }

  002a2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002a6	c3		 ret	 0
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
_TEXT	SEGMENT
_Gptr$ = 32
_Local_highwater$ = 40
tv154 = 48
tv152 = 56
_Pptr$ = 64
__$ArrayPad$ = 72
this$ = 96
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT

; 178  :     virtual int_type underflow() { // get an element from stream, but don't point past it

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 179  :         const auto _Gptr = _Mysb::gptr();

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00023	48 89 44 24 20	 mov	 QWORD PTR _Gptr$[rsp], rax

; 180  :         if (!_Gptr) { // no character buffer, fail

  00028	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Gptr$[rsp], 0
  0002e	75 0a		 jne	 SHORT $LN2@underflow

; 181  :             return _Traits::eof();

  00030	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00035	e9 de 00 00 00	 jmp	 $LN1@underflow
$LN2@underflow:

; 182  :         }
; 183  : 
; 184  :         if (_Gptr < _Mysb::egptr()) {

  0003a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00045	48 39 44 24 20	 cmp	 QWORD PTR _Gptr$[rsp], rax
  0004a	73 0f		 jae	 SHORT $LN3@underflow

; 185  :             return _Traits::to_int_type(*_Gptr);

  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Gptr$[rsp]
  00051	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00056	e9 bd 00 00 00	 jmp	 $LN1@underflow
$LN3@underflow:

; 186  :         }
; 187  : 
; 188  :         // try to add initialized characters from the put area into the get area
; 189  :         const auto _Pptr = _Mysb::pptr();

  0005b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00066	48 89 44 24 40	 mov	 QWORD PTR _Pptr$[rsp], rax

; 190  :         if (!_Pptr || (_Mystate & _Noread)) { // no put area or read disallowed

  0006b	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Pptr$[rsp], 0
  00071	74 0f		 je	 SHORT $LN5@underflow
  00073	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00078	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007b	83 e0 04	 and	 eax, 4
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN4@underflow
$LN5@underflow:

; 191  :             return _Traits::eof();

  00082	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00087	e9 8c 00 00 00	 jmp	 $LN1@underflow
$LN4@underflow:

; 192  :         }
; 193  : 
; 194  :         const auto _Local_highwater = (_STD max)(_Seekhigh, _Pptr);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00091	48 83 c0 68	 add	 rax, 104		; 00000068H
  00095	48 8d 54 24 40	 lea	 rdx, QWORD PTR _Pptr$[rsp]
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 ??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z ; std::max<char *>
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 89 44 24 28	 mov	 QWORD PTR _Local_highwater$[rsp], rax

; 195  :         if (_Local_highwater <= _Gptr) { // nothing in the put area to take

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR _Gptr$[rsp]
  000af	48 39 44 24 28	 cmp	 QWORD PTR _Local_highwater$[rsp], rax
  000b4	77 07		 ja	 SHORT $LN6@underflow

; 196  :             return _Traits::eof();

  000b6	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000bb	eb 5b		 jmp	 SHORT $LN1@underflow
$LN6@underflow:

; 197  :         }
; 198  : 
; 199  :         _Seekhigh = _Local_highwater;

  000bd	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Local_highwater$[rsp]
  000c7	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 200  :         _Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Local_highwater);

  000cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000d6	48 89 44 24 30	 mov	 QWORD PTR tv154[rsp], rax
  000db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000e6	48 89 44 24 38	 mov	 QWORD PTR tv152[rsp], rax
  000eb	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _Local_highwater$[rsp]
  000f0	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv154[rsp]
  000f5	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv152[rsp]
  000fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 201  :         return _Traits::to_int_type(*_Mysb::gptr());

  00105	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00110	48 8b c8	 mov	 rcx, rax
  00113	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
$LN1@underflow:

; 202  :     }

  00118	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011d	48 33 cc	 xor	 rcx, rsp
  00120	e8 00 00 00 00	 call	 __security_check_cookie
  00125	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00129	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
$T1 = 32
tv150 = 33
$T2 = 36
$T3 = 40
_Gptr$ = 48
this$ = 80
_Meta$ = 88
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT

; 161  :     virtual int_type pbackfail(int_type _Meta = _Traits::eof()) { // put an element back to stream

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 162  :         const auto _Gptr = _Mysb::gptr();

  0000d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00018	48 89 44 24 30	 mov	 QWORD PTR _Gptr$[rsp], rax

; 163  :         if (!_Gptr || _Gptr <= _Mysb::eback()
; 164  :             || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Gptr$[rsp], 0
  00023	74 76		 je	 SHORT $LN3@pbackfail
  00025	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00030	48 39 44 24 30	 cmp	 QWORD PTR _Gptr$[rsp], rax
  00035	76 64		 jbe	 SHORT $LN3@pbackfail
  00037	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0003c	89 44 24 24	 mov	 DWORD PTR $T2[rsp], eax
  00040	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Meta$[rsp]
  00045	48 8d 4c 24 24	 lea	 rcx, QWORD PTR $T2[rsp]
  0004a	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0004f	0f b6 c0	 movzx	 eax, al
  00052	85 c0		 test	 eax, eax
  00054	75 4c		 jne	 SHORT $LN2@pbackfail
  00056	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  0005b	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00060	88 44 24 20	 mov	 BYTE PTR $T1[rsp], al
  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	48 6b c0 ff	 imul	 rax, rax, -1
  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Gptr$[rsp]
  00072	48 03 c8	 add	 rcx, rax
  00075	48 8b c1	 mov	 rax, rcx
  00078	48 8b d0	 mov	 rdx, rax
  0007b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00080	e8 00 00 00 00	 call	 ?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z ; std::_Narrow_char_traits<char,int>::eq
  00085	0f b6 c0	 movzx	 eax, al
  00088	85 c0		 test	 eax, eax
  0008a	75 16		 jne	 SHORT $LN2@pbackfail
  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00091	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00094	83 e0 02	 and	 eax, 2
  00097	85 c0		 test	 eax, eax
  00099	74 07		 je	 SHORT $LN2@pbackfail
$LN3@pbackfail:

; 165  :                 && (_Mystate & _Constant))) { // can't put back, fail
; 166  :             return _Traits::eof();

  0009b	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000a0	eb 59		 jmp	 SHORT $LN1@pbackfail
$LN2@pbackfail:

; 167  :         }
; 168  : 
; 169  :         // back up one position and store put-back character
; 170  :         _Mysb::gbump(-1);

  000a2	ba ff ff ff ff	 mov	 edx, -1
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z

; 171  :         if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  000b2	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000b7	89 44 24 28	 mov	 DWORD PTR $T3[rsp], eax
  000bb	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Meta$[rsp]
  000c0	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T3[rsp]
  000c5	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  000ca	0f b6 c0	 movzx	 eax, al
  000cd	85 c0		 test	 eax, eax
  000cf	75 20		 jne	 SHORT $LN4@pbackfail

; 172  :             *_Mysb::gptr() = _Traits::to_char_type(_Meta);

  000d1	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  000d6	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  000db	88 44 24 21	 mov	 BYTE PTR tv150[rsp], al
  000df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000ea	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv150[rsp]
  000ef	88 08		 mov	 BYTE PTR [rax], cl
$LN4@pbackfail:

; 173  :         }
; 174  : 
; 175  :         return _Traits::not_eof(_Meta);

  000f1	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  000f6	e8 00 00 00 00	 call	 ?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ; std::_Narrow_char_traits<char,int>::not_eof
$LN1@pbackfail:

; 176  :     }

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
tv131 = 32
tv228 = 33
_Newptr$ = 40
_Oldsize$ = 48
_Pptr$ = 56
_Newsize$ = 64
_Oldptr$ = 72
$T1 = 80
_Epptr$ = 88
_New_pnext$ = 96
tv155 = 104
tv204 = 112
tv202 = 120
tv215 = 128
this$ = 160
_Meta$ = 168
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT

; 104  :     virtual int_type overflow(int_type _Meta = _Traits::eof()) { // put an element to stream

$LN16:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 105  :         if (_Mystate & _Constant) {

  00010	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00018	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0001b	83 e0 02	 and	 eax, 2
  0001e	85 c0		 test	 eax, eax
  00020	74 0a		 je	 SHORT $LN2@overflow

; 106  :             return _Traits::eof(); // array nonmutable, fail

  00022	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00027	e9 da 02 00 00	 jmp	 $LN1@overflow
$LN2@overflow:

; 107  :         }
; 108  : 
; 109  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  0002c	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00031	89 44 24 50	 mov	 DWORD PTR $T1[rsp], eax
  00035	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR _Meta$[rsp]
  0003d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T1[rsp]
  00042	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00047	0f b6 c0	 movzx	 eax, al
  0004a	85 c0		 test	 eax, eax
  0004c	74 12		 je	 SHORT $LN3@overflow

; 110  :             return _Traits::not_eof(_Meta); // EOF, return success code

  0004e	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  00056	e8 00 00 00 00	 call	 ?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ; std::_Narrow_char_traits<char,int>::not_eof
  0005b	e9 a6 02 00 00	 jmp	 $LN1@overflow
$LN3@overflow:

; 111  :         }
; 112  : 
; 113  :         const auto _Pptr  = _Mysb::pptr();

  00060	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0006e	48 89 44 24 38	 mov	 QWORD PTR _Pptr$[rsp], rax

; 114  :         const auto _Epptr = _Mysb::epptr();

  00073	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00081	48 89 44 24 58	 mov	 QWORD PTR _Epptr$[rsp], rax

; 115  :         if (_Pptr && _Pptr < _Epptr) { // room in buffer, store it

  00086	48 83 7c 24 38
	00		 cmp	 QWORD PTR _Pptr$[rsp], 0
  0008c	74 52		 je	 SHORT $LN4@overflow
  0008e	48 8b 44 24 58	 mov	 rax, QWORD PTR _Epptr$[rsp]
  00093	48 39 44 24 38	 cmp	 QWORD PTR _Pptr$[rsp], rax
  00098	73 46		 jae	 SHORT $LN4@overflow

; 116  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0009a	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  000a2	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  000a7	88 44 24 20	 mov	 BYTE PTR tv131[rsp], al
  000ab	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  000b9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv131[rsp]
  000be	88 08		 mov	 BYTE PTR [rax], cl

; 117  :             _Seekhigh        = _Pptr + 1;

  000c0	48 8b 44 24 38	 mov	 rax, QWORD PTR _Pptr$[rsp]
  000c5	48 ff c0	 inc	 rax
  000c8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000d0	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 118  :             return _Meta;

  000d4	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR _Meta$[rsp]
  000db	e9 26 02 00 00	 jmp	 $LN1@overflow
$LN4@overflow:

; 119  :         }
; 120  : 
; 121  :         // grow buffer and store element
; 122  :         size_t _Oldsize    = 0;

  000e0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR _Oldsize$[rsp], 0

; 123  :         const auto _Oldptr = _Mysb::eback();

  000e9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000f7	48 89 44 24 48	 mov	 QWORD PTR _Oldptr$[rsp], rax

; 124  :         if (_Pptr) {

  000fc	48 83 7c 24 38
	00		 cmp	 QWORD PTR _Pptr$[rsp], 0
  00102	74 15		 je	 SHORT $LN5@overflow

; 125  :             _Oldsize = static_cast<size_t>(_Epptr - _Oldptr);

  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR _Oldptr$[rsp]
  00109	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Epptr$[rsp]
  0010e	48 2b c8	 sub	 rcx, rax
  00111	48 8b c1	 mov	 rax, rcx
  00114	48 89 44 24 30	 mov	 QWORD PTR _Oldsize$[rsp], rax
$LN5@overflow:

; 126  :         }
; 127  : 
; 128  :         size_t _Newsize;
; 129  :         if (_Oldsize < _MINSIZE) {

  00119	48 83 7c 24 30
	20		 cmp	 QWORD PTR _Oldsize$[rsp], 32 ; 00000020H
  0011f	73 0b		 jae	 SHORT $LN6@overflow

; 130  :             _Newsize = _MINSIZE;

  00121	48 c7 44 24 40
	20 00 00 00	 mov	 QWORD PTR _Newsize$[rsp], 32 ; 00000020H
  0012a	eb 3a		 jmp	 SHORT $LN7@overflow
$LN6@overflow:

; 131  :         } else if (_Oldsize < INT_MAX / 2) { // grow by 50 percent

  0012c	48 81 7c 24 30
	ff ff ff 3f	 cmp	 QWORD PTR _Oldsize$[rsp], 1073741823 ; 3fffffffH
  00135	73 0f		 jae	 SHORT $LN8@overflow

; 132  :             _Newsize = _Oldsize << 1;

  00137	48 8b 44 24 30	 mov	 rax, QWORD PTR _Oldsize$[rsp]
  0013c	48 d1 e0	 shl	 rax, 1
  0013f	48 89 44 24 40	 mov	 QWORD PTR _Newsize$[rsp], rax
  00144	eb 20		 jmp	 SHORT $LN9@overflow
$LN8@overflow:

; 133  :         } else if (_Oldsize < INT_MAX) {

  00146	48 81 7c 24 30
	ff ff ff 7f	 cmp	 QWORD PTR _Oldsize$[rsp], 2147483647 ; 7fffffffH
  0014f	73 0b		 jae	 SHORT $LN10@overflow

; 134  :             _Newsize = INT_MAX;

  00151	48 c7 44 24 40
	ff ff ff 7f	 mov	 QWORD PTR _Newsize$[rsp], 2147483647 ; 7fffffffH

; 135  :         } else { // buffer can't grow, fail

  0015a	eb 0a		 jmp	 SHORT $LN11@overflow
$LN10@overflow:

; 136  :             return _Traits::eof();

  0015c	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00161	e9 a0 01 00 00	 jmp	 $LN1@overflow
$LN11@overflow:
$LN9@overflow:
$LN7@overflow:

; 137  :         }
; 138  : 
; 139  :         const auto _Newptr = _Unfancy(_Al.allocate(_Newsize));

  00166	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0016e	48 83 c0 74	 add	 rax, 116		; 00000074H
  00172	48 89 44 24 68	 mov	 QWORD PTR tv155[rsp], rax
  00177	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Newsize$[rsp]
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv155[rsp]
  00181	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  00186	48 8b c8	 mov	 rcx, rax
  00189	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0018e	48 89 44 24 28	 mov	 QWORD PTR _Newptr$[rsp], rax

; 140  :         _Traits::copy(_Newptr, _Oldptr, _Oldsize);

  00193	4c 8b 44 24 30	 mov	 r8, QWORD PTR _Oldsize$[rsp]
  00198	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Oldptr$[rsp]
  0019d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Newptr$[rsp]
  001a2	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 141  : 
; 142  :         const auto _New_pnext = _Newptr + _Oldsize;

  001a7	48 8b 44 24 30	 mov	 rax, QWORD PTR _Oldsize$[rsp]
  001ac	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Newptr$[rsp]
  001b1	48 03 c8	 add	 rcx, rax
  001b4	48 8b c1	 mov	 rax, rcx
  001b7	48 89 44 24 60	 mov	 QWORD PTR _New_pnext$[rsp], rax

; 143  :         _Seekhigh             = _New_pnext + 1; // to include _Meta

  001bc	48 8b 44 24 60	 mov	 rax, QWORD PTR _New_pnext$[rsp]
  001c1	48 ff c0	 inc	 rax
  001c4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001cc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 144  : 
; 145  :         _Mysb::setp(_Newptr, _New_pnext, _Newptr + _Newsize);

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR _Newsize$[rsp]
  001d5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Newptr$[rsp]
  001da	48 03 c8	 add	 rcx, rax
  001dd	48 8b c1	 mov	 rax, rcx
  001e0	4c 8b c8	 mov	 r9, rax
  001e3	4c 8b 44 24 60	 mov	 r8, QWORD PTR _New_pnext$[rsp]
  001e8	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Newptr$[rsp]
  001ed	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 146  :         if (_Mystate & _Noread) { // maintain eback() == allocated pointer invariant

  001fb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00203	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00206	83 e0 04	 and	 eax, 4
  00209	85 c0		 test	 eax, eax
  0020b	74 1d		 je	 SHORT $LN12@overflow

; 147  :             _Mysb::setg(_Newptr, nullptr, _Newptr);

  0020d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _Newptr$[rsp]
  00212	45 33 c0	 xor	 r8d, r8d
  00215	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Newptr$[rsp]
  0021a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 148  :         } else { // if readable, set the get area to initialized region

  00228	eb 51		 jmp	 SHORT $LN13@overflow
$LN12@overflow:

; 149  :             _Mysb::setg(_Newptr, _Newptr + (_Mysb::gptr() - _Oldptr), _Seekhigh);

  0022a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00232	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00236	48 89 44 24 70	 mov	 QWORD PTR tv204[rsp], rax
  0023b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00249	48 2b 44 24 48	 sub	 rax, QWORD PTR _Oldptr$[rsp]
  0024e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Newptr$[rsp]
  00253	48 03 c8	 add	 rcx, rax
  00256	48 8b c1	 mov	 rax, rcx
  00259	48 89 44 24 78	 mov	 QWORD PTR tv202[rsp], rax
  0025e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR tv204[rsp]
  00263	4c 8b 44 24 78	 mov	 r8, QWORD PTR tv202[rsp]
  00268	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Newptr$[rsp]
  0026d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN13@overflow:

; 150  :         }
; 151  : 
; 152  :         if (_Mystate & _Allocated) {

  0027b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00283	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00286	83 e0 01	 and	 eax, 1
  00289	85 c0		 test	 eax, eax
  0028b	74 33		 je	 SHORT $LN14@overflow

; 153  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Oldptr), _Oldsize);

  0028d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00295	48 83 c0 74	 add	 rax, 116		; 00000074H
  00299	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  002a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Oldptr$[rsp]
  002a6	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
  002ab	4c 8b 44 24 30	 mov	 r8, QWORD PTR _Oldsize$[rsp]
  002b0	48 8b d0	 mov	 rdx, rax
  002b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  002bb	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN14@overflow:

; 154  :         }
; 155  : 
; 156  :         _Mystate |= _Allocated;

  002c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002c8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002cb	83 c8 01	 or	 eax, 1
  002ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002d6	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 157  :         *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  002d9	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  002e1	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  002e6	88 44 24 21	 mov	 BYTE PTR tv228[rsp], al
  002ea	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  002f8	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv228[rsp]
  002fd	88 08		 mov	 BYTE PTR [rax], cl

; 158  :         return _Meta;

  002ff	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR _Meta$[rsp]
$LN1@overflow:

; 159  :     }

  00306	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0030d	c3		 ret	 0
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
_Base$2 = 40
_Base$3 = 48
$T4 = 56
_Result$ = 64
__$ArrayPad$ = 96
this$ = 128
__$ReturnUdt$ = 136
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 85   :     _NODISCARD _Mystr str() const {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 86   :         _Mystr _Result(_Al);

  00025	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 83 c0 74	 add	 rax, 116		; 00000074H
  00031	48 8b d0	 mov	 rdx, rax
  00034	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Result$[rsp]
  00039	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003e	90		 npad	 1

; 87   :         if (!(_Mystate & _Constant) && _Mysb::pptr()) { // writable, make string from write buffer

  0003f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00047	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0004a	83 e0 02	 and	 eax, 2
  0004d	85 c0		 test	 eax, eax
  0004f	75 71		 jne	 SHORT $LN2@str
  00051	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0005f	48 85 c0	 test	 rax, rax
  00062	74 5e		 je	 SHORT $LN2@str

; 88   :             const auto _Base = _Mysb::pbase();

  00064	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00072	48 89 44 24 28	 mov	 QWORD PTR _Base$2[rsp], rax

; 89   :             _Result.assign(_Base, static_cast<_Mysize_type>((_STD max)(_Mysb::pptr(), _Seekhigh) - _Base));

  00077	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00085	48 89 44 24 38	 mov	 QWORD PTR $T4[rsp], rax
  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00092	48 83 c0 68	 add	 rax, 104		; 00000068H
  00096	48 8b d0	 mov	 rdx, rax
  00099	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T4[rsp]
  0009e	e8 00 00 00 00	 call	 ??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z ; std::max<char *>
  000a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Base$2[rsp]
  000a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ab	48 2b c1	 sub	 rax, rcx
  000ae	4c 8b c0	 mov	 r8, rax
  000b1	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Base$2[rsp]
  000b6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Result$[rsp]
  000bb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000c0	eb 5d		 jmp	 SHORT $LN3@str
$LN2@str:

; 90   :         } else if (!(_Mystate & _Noread) && _Mysb::gptr()) { // readable, make string from read buffer

  000c2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ca	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000cd	83 e0 04	 and	 eax, 4
  000d0	85 c0		 test	 eax, eax
  000d2	75 4b		 jne	 SHORT $LN3@str
  000d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000e2	48 85 c0	 test	 rax, rax
  000e5	74 38		 je	 SHORT $LN3@str

; 91   :             const auto _Base = _Mysb::eback();

  000e7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000f5	48 89 44 24 30	 mov	 QWORD PTR _Base$3[rsp], rax

; 92   :             _Result.assign(_Base, static_cast<_Mysize_type>(_Mysb::egptr() - _Base));

  000fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00108	48 2b 44 24 30	 sub	 rax, QWORD PTR _Base$3[rsp]
  0010d	4c 8b c0	 mov	 r8, rax
  00110	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Base$3[rsp]
  00115	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Result$[rsp]
  0011a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@str:

; 93   :         }
; 94   : 
; 95   :         return _Result;

  0011f	48 8d 54 24 40	 lea	 rdx, QWORD PTR _Result$[rsp]
  00124	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0012c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00131	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00135	83 c8 01	 or	 eax, 1
  00138	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
  0013c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Result$[rsp]
  00141	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00146	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 96   :     }

  0014e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00153	48 33 cc	 xor	 rcx, rsp
  00156	e8 00 00 00 00	 call	 __security_check_cookie
  0015b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0015f	c3		 ret	 0
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Base$2 = 40
_Base$3 = 48
$T4 = 56
_Result$ = 64
__$ArrayPad$ = 96
this$ = 128
__$ReturnUdt$ = 136
?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 40	 lea	 rcx, QWORD PTR _Result$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Base$2 = 40
_Base$3 = 48
$T4 = 56
_Result$ = 64
__$ArrayPad$ = 96
this$ = 128
__$ReturnUdt$ = 136
?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 40	 lea	 rcx, QWORD PTR _Result$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 69   :     virtual ~basic_stringbuf() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx

; 70   :         _Tidy();

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 71   :     }

  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 48
_Mode$ = 56
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 34   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00018	90		 npad	 1
  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00025	48 89 08	 mov	 QWORD PTR [rax], rcx
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  00035	8b 4c 24 38	 mov	 ecx, DWORD PTR _Mode$[rsp]
  00039	e8 00 00 00 00	 call	 ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00043	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 c0 74	 add	 rax, 116		; 00000074H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00057	90		 npad	 1
  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00061	c3		 ret	 0
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Mode$ = 56
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 30	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Mode$ = 56
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 30	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
__$ReturnUdt$ = 72
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 567  :     _NODISCARD _Mystr str() const {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 568  :         return _Stringbuffer.str();

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 83 c0 18	 add	 rax, 24
  0001f	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00024	48 8b 54 24 48	 mov	 rdx, QWORD PTR __$ReturnUdt$[rsp]
  00029	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  0002e	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
  00033	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00037	83 c8 01	 or	 eax, 1
  0003a	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 569  :     }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 561  :     virtual ~basic_stringstream() noexcept {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 80 68 ff
	ff ff		 mov	 rax, QWORD PTR [rax-152]
  00015	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00025	48 89 94 01 68
	ff ff ff	 mov	 QWORD PTR [rcx+rax-152], rdx
  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 8b 80 68 ff
	ff ff		 mov	 rax, QWORD PTR [rax-152]
  00039	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003d	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00048	48 8b 89 68 ff
	ff ff		 mov	 rcx, QWORD PTR [rcx-152]
  0004f	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00053	48 8b 54 24 30	 mov	 rdx, QWORD PTR this$[rsp]
  00058	89 84 0a 64 ff
	ff ff		 mov	 DWORD PTR [rdx+rcx-156], eax
  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00064	48 2d 80 00 00
	00		 sub	 rax, 128		; 00000080H
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00072	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00077	48 83 e8 78	 sub	 rax, 120		; 00000078H
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 527  :     basic_stringstream() : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(ios_base::in | ios_base::out) {}

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00015	83 7c 24 48 00	 cmp	 DWORD PTR $initVBases$[rsp], 0
  0001a	74 3f		 je	 SHORT $LN2@basic_stri
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00037	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00040	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00046	48 8b c8	 mov	 rcx, rax
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0004f	90		 npad	 1
  00050	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00054	83 c8 01	 or	 eax, 1
  00057	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
$LN2@basic_stri:
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00060	48 83 c0 18	 add	 rax, 24
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 ??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
  0006c	45 33 c0	 xor	 r8d, r8d
  0006f	48 8b d0	 mov	 rdx, rax
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0007d	90		 npad	 1
  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00096	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a2	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000a6	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000b1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b4	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  000b8	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  000bd	89 44 0a fc	 mov	 DWORD PTR [rdx+rcx-4], eax
  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c6	48 83 c0 18	 add	 rax, 24
  000ca	48 89 44 24 28	 mov	 QWORD PTR tv163[rsp], rax
  000cf	ba 03 00 00 00	 mov	 edx, 3
  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv163[rsp]
  000d9	e8 00 00 00 00	 call	 ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  000de	90		 npad	 1
  000df	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000e4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e8	c3		 ret	 0
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv80 = 40
tv89 = 48
tv87 = 56
tv94 = 64
tv132 = 72
$T3 = 80
stream$ = 96
__$ArrayPad$ = 352
__$ReturnUdt$ = 384
Byte$ = 392
?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z PROC ; SmPrintByteAsHex, COMDAT

; 490  : {

$LN6:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00022	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T2[rsp], 0

; 491  : 	std::stringstream stream;

  0002a	ba f8 00 00 00	 mov	 edx, 248		; 000000f8H
  0002f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR stream$[rsp]
  00034	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
  00039	ba 01 00 00 00	 mov	 edx, 1
  0003e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR stream$[rsp]
  00043	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  00048	90		 npad	 1

; 492  : 	stream << std::setw(2) << std::setfill('0') << std::hex << (ULONG)Byte;

  00049	48 8d 44 24 70	 lea	 rax, QWORD PTR stream$[rsp+16]
  0004e	48 89 44 24 28	 mov	 QWORD PTR tv80[rsp], rax
  00053	ba 02 00 00 00	 mov	 edx, 2
  00058	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  0005d	e8 00 00 00 00	 call	 ?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z ; std::setw
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR tv80[rsp]
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@_J@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Smanip@_J@0@@Z ; std::operator<<<char,std::char_traits<char>,__int64>
  00072	48 89 44 24 38	 mov	 QWORD PTR tv87[rsp], rax
  00077	b2 30		 mov	 dl, 48			; 00000030H
  00079	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0007e	e8 00 00 00 00	 call	 ??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z ; std::setfill<char>
  00083	48 89 44 24 30	 mov	 QWORD PTR tv89[rsp], rax
  00088	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv89[rsp]
  0008d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv87[rsp]
  00092	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@D@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBU?$_Fillobj@D@0@@Z ; std::operator<<<char,std::char_traits<char>,char>
  00097	48 89 44 24 40	 mov	 QWORD PTR tv94[rsp], rax
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?hex@std@@YAAEAVios_base@1@AEAV21@@Z ; std::hex
  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv94[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
  000ae	48 89 44 24 48	 mov	 QWORD PTR tv132[rsp], rax
  000b3	0f b6 84 24 88
	01 00 00	 movzx	 eax, BYTE PTR Byte$[rsp]
  000bb	8b d0		 mov	 edx, eax
  000bd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv132[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@K@Z

; 493  : 	return stream.str();

  000c8	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR __$ReturnUdt$[rsp]
  000d0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR stream$[rsp]
  000d5	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  000da	8b 44 24 24	 mov	 eax, DWORD PTR $T2[rsp]
  000de	83 c8 01	 or	 eax, 1
  000e1	89 44 24 24	 mov	 DWORD PTR $T2[rsp], eax
  000e5	48 8d 4c 24 60	 lea	 rcx, QWORD PTR stream$[rsp]
  000ea	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  000ef	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 494  : }

  000f7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ff	48 33 cc	 xor	 rcx, rsp
  00102	e8 00 00 00 00	 call	 __security_check_cookie
  00107	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  0010e	c3		 ret	 0
?SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ENDP ; SmPrintByteAsHex
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv80 = 40
tv89 = 48
tv87 = 56
tv94 = 64
tv132 = 72
$T3 = 80
stream$ = 96
__$ArrayPad$ = 352
__$ReturnUdt$ = 384
Byte$ = 392
?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA PROC ; `SmPrintByteAsHex'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 60	 lea	 rcx, QWORD PTR stream$[rbp]
  0000d	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA ENDP ; `SmPrintByteAsHex'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv80 = 40
tv89 = 48
tv87 = 56
tv94 = 64
tv132 = 72
$T3 = 80
stream$ = 96
__$ArrayPad$ = 352
__$ReturnUdt$ = 384
Byte$ = 392
?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA PROC ; `SmPrintByteAsHex'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 60	 lea	 rcx, QWORD PTR stream$[rbp]
  0000d	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??SmPrintByteAsHex@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z@4HA ENDP ; `SmPrintByteAsHex'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z
_TEXT	SEGMENT
i$1 = 32
Register$ = 64
Id$ = 72
?SmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z PROC ; SmGetRegisterId, COMDAT

; 476  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 477  : 	for (INT i = 0; i < 32; i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@SmGetRegis
$LN2@SmGetRegis:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@SmGetRegis:
  00022	83 7c 24 20 20	 cmp	 DWORD PTR i$1[rsp], 32	; 00000020H
  00027	7d 36		 jge	 SHORT $LN3@SmGetRegis

; 478  : 	{
; 479  : 		if (Register == RegisterBindings[i])

  00029	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?RegisterBindings@@3PAPEBDA ; RegisterBindings
  00035	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Register$[rsp]
  0003e	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00043	0f b6 c0	 movzx	 eax, al
  00046	85 c0		 test	 eax, eax
  00048	74 13		 je	 SHORT $LN5@SmGetRegis

; 480  : 		{
; 481  : 			*Id = i;

  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR Id$[rsp]
  0004f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i$1[rsp]
  00054	88 08		 mov	 BYTE PTR [rax], cl

; 482  : 			return TRUE;

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	eb 04		 jmp	 SHORT $LN1@SmGetRegis
$LN5@SmGetRegis:

; 483  : 		}
; 484  : 	}

  0005d	eb b9		 jmp	 SHORT $LN2@SmGetRegis
$LN3@SmGetRegis:

; 485  : 	return FALSE;

  0005f	33 c0		 xor	 eax, eax
$LN1@SmGetRegis:

; 486  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
?SmGetRegisterId@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ENDP ; SmGetRegisterId
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4480 : _NODISCARD bool operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4481 :     return _Left._Equal(_Right);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Left$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal

; 4482 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmGetOpCode@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z
_TEXT	SEGMENT
i$1 = 32
Instruction$ = 64
OpCode$ = 72
?SmGetOpCode@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z PROC ; SmGetOpCode, COMDAT

; 463  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 464  : 	for (INT i = 0; i < ARRAYSIZE(InstructionBindings); i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@SmGetOpCod
$LN2@SmGetOpCod:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@SmGetOpCod:
  00022	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00027	48 3d 8a 00 00
	00		 cmp	 rax, 138		; 0000008aH
  0002d	73 36		 jae	 SHORT $LN3@SmGetOpCod

; 465  : 	{
; 466  : 		if (Instruction == InstructionBindings[i])

  0002f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?InstructionBindings@@3PAPEBDA ; InstructionBindings
  0003b	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Instruction$[rsp]
  00044	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	74 13		 je	 SHORT $LN5@SmGetOpCod

; 467  : 		{
; 468  : 			*OpCode = i;

  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR OpCode$[rsp]
  00055	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i$1[rsp]
  0005a	88 08		 mov	 BYTE PTR [rax], cl

; 469  : 			return TRUE;

  0005c	b8 01 00 00 00	 mov	 eax, 1
  00061	eb 04		 jmp	 SHORT $LN1@SmGetOpCod
$LN5@SmGetOpCod:

; 470  : 		}
; 471  : 	}

  00063	eb b3		 jmp	 SHORT $LN2@SmGetOpCod
$LN3@SmGetOpCod:

; 472  : 	return FALSE;

  00065	33 c0		 xor	 eax, eax
$LN1@SmGetOpCod:

; 473  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
?SmGetOpCode@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAE@Z ENDP ; SmGetOpCode
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmGetInstructionSize@@YAHE@Z
_TEXT	SEGMENT
tv65 = 0
OpCode$ = 32
?SmGetInstructionSize@@YAHE@Z PROC			; SmGetInstructionSize, COMDAT

; 289  : {

$LN12:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 290  : 	switch (OpCode)

  00008	0f b6 44 24 20	 movzx	 eax, BYTE PTR OpCode$[rsp]
  0000d	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00010	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]
  00013	ff c8		 dec	 eax
  00015	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00018	81 3c 24 88 00
	00 00		 cmp	 DWORD PTR tv65[rsp], 136 ; 00000088H
  0001f	77 42		 ja	 SHORT $LN2@SmGetInstr
  00021	48 63 04 24	 movsxd	 rax, DWORD PTR tv65[rsp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0002c	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN10@SmGetInstr[rcx+rax]
  00034	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN11@SmGetInstr[rcx+rax*4]
  0003b	48 03 c1	 add	 rax, rcx
  0003e	ff e0		 jmp	 rax
$LN4@SmGetInstr:

; 291  : 	{
; 292  : 	case VMEXIT:
; 293  : 	case NOP:
; 294  : 
; 295  : 	case LDAB:
; 296  : 	case LDAW:
; 297  : 	case LDAD:
; 298  : 	case LDAQ:
; 299  : 
; 300  : 	case STAB:
; 301  : 	case STAW:
; 302  : 	case STAD:
; 303  : 	case STAQ:
; 304  : 
; 305  : 	case SXBW:
; 306  : 	case SXBD:
; 307  : 	case SXBQ:
; 308  : 	case SXWD:
; 309  : 	case SXWQ:
; 310  : 	case SXDQ:
; 311  : 
; 312  : 	case ZXBW:
; 313  : 	case ZXBD:
; 314  : 	case ZXBQ:
; 315  : 	case ZXWD:
; 316  : 	case ZXWQ:
; 317  : 	case ZXDQ:
; 318  : 
; 319  : 	case ADDB:
; 320  : 	case ADDW:
; 321  : 	case ADDD:
; 322  : 	case ADDQ:
; 323  : 
; 324  : 	case SUBB:
; 325  : 	case SUBW:
; 326  : 	case SUBD:
; 327  : 	case SUBQ:
; 328  : 
; 329  : 	case MULB:
; 330  : 	case MULW:
; 331  : 	case MULD:
; 332  : 	case MULQ:
; 333  : 
; 334  : 	case DIVB:
; 335  : 	case DIVW:
; 336  : 	case DIVD:
; 337  : 	case DIVQ:
; 338  : 
; 339  : 	case ANDB:
; 340  : 	case ANDW:
; 341  : 	case ANDD:
; 342  : 	case ANDQ:
; 343  : 
; 344  : 	case ORB:
; 345  : 	case ORW:
; 346  : 	case ORD:
; 347  : 	case ORQ:
; 348  : 
; 349  : 	case XORB:
; 350  : 	case XORW:
; 351  : 	case XORD:
; 352  : 	case XORQ:
; 353  : 
; 354  : 	case SHLB:
; 355  : 	case SHLW:
; 356  : 	case SHLD:
; 357  : 	case SHLQ:
; 358  : 
; 359  : 	case SHRB:
; 360  : 	case SHRW:
; 361  : 	case SHRD:
; 362  : 	case SHRQ:
; 363  : 	case CMPB:
; 364  : 	case CMPW:
; 365  : 	case CMPD:
; 366  : 	case CMPQ:
; 367  : 	case RET:
; 368  : 	case X86CALL:
; 369  : 	case SWAPB:
; 370  : 	case SWAPW:
; 371  : 	case SWAPD:
; 372  : 	case SWAPQ:
; 373  : 	case DECB:
; 374  : 	case DECW:
; 375  : 	case DECD:
; 376  : 	case DECQ:
; 377  : 	case INCB:
; 378  : 	case INCW:
; 379  : 	case INCD:
; 380  : 	case INCQ:
; 381  : 	case NPOPB:
; 382  : 	case NPOPW:
; 383  : 	case NPOPD:
; 384  : 	case NPOPQ:
; 385  : 	case SWAPBQ:
; 386  : 	case SWAPWQ:
; 387  : 	case SWAPDQ:
; 388  : 	case JMP:
; 389  : 	{
; 390  : 		return 1;

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	eb 1e		 jmp	 SHORT $LN1@SmGetInstr
$LN5@SmGetInstr:

; 391  : 	}
; 392  : 	case LDIB:
; 393  : 	case PUSHB:
; 394  : 	case PUSHW:
; 395  : 	case PUSHD:
; 396  : 	case PUSHQ:
; 397  : 	case POPB:
; 398  : 	case POPW:
; 399  : 	case POPD:
; 400  : 	case POPQ:
; 401  : 	case STSP:
; 402  : 	case LDSP:
; 403  : 	case STIP:
; 404  : 	case LDIP:
; 405  : 	case LDIBSXW:
; 406  : 	case LDIBSXD:
; 407  : 	case LDIBSXQ:
; 408  : 	case LDIBZXW:
; 409  : 	case LDIBZXD:
; 410  : 	case LDIBZXQ:
; 411  : 	{
; 412  : 		return 2;

  00047	b8 02 00 00 00	 mov	 eax, 2
  0004c	eb 17		 jmp	 SHORT $LN1@SmGetInstr
$LN6@SmGetInstr:

; 413  : 	}
; 414  : 	case LDIW:
; 415  : 	case EDITSP:
; 416  : 	case LDIWSXD:
; 417  : 	case LDIWSXQ:
; 418  : 	case LDIWZXD:
; 419  : 	case LDIWZXQ:
; 420  : 	case LDBPB:
; 421  : 	case LDBPW:
; 422  : 	case LDBPD:
; 423  : 	case LDBPQ:
; 424  : 	case STBPB:
; 425  : 	case STBPW:
; 426  : 	case STBPD:
; 427  : 	case STBPQ:
; 428  : 	{
; 429  : 		return 3;

  0004e	b8 03 00 00 00	 mov	 eax, 3
  00053	eb 10		 jmp	 SHORT $LN1@SmGetInstr
$LN7@SmGetInstr:

; 430  : 	}
; 431  : 	case LDID: 
; 432  : 	case LDIDSXQ:
; 433  : 	case LDIDZXQ:
; 434  : 	{
; 435  : 		return 5;

  00055	b8 05 00 00 00	 mov	 eax, 5
  0005a	eb 09		 jmp	 SHORT $LN1@SmGetInstr
$LN8@SmGetInstr:

; 436  : 	}
; 437  : 	case LDIQ: 
; 438  : 	case JMPI:
; 439  : 	case JL:
; 440  : 	case JLE:
; 441  : 	case JG:
; 442  : 	case JGE:
; 443  : 	case JZ:
; 444  : 	case JNZ:
; 445  : 	case CALL:
; 446  : 	case LDSB:
; 447  : 	case LDSW:
; 448  : 	case LDSD:
; 449  : 	case LDSQ:
; 450  : 	case STSB:
; 451  : 	case STSW:
; 452  : 	case STSD:
; 453  : 	case STSQ:
; 454  : 	{
; 455  : 		return 9;

  0005c	b8 09 00 00 00	 mov	 eax, 9
  00061	eb 02		 jmp	 SHORT $LN1@SmGetInstr
$LN2@SmGetInstr:

; 456  : 	}
; 457  : 
; 458  : 	}
; 459  : 	return 0;

  00063	33 c0		 xor	 eax, eax
$LN1@SmGetInstr:

; 460  : }

  00065	48 83 c4 18	 add	 rsp, 24
  00069	c3		 ret	 0
  0006a	66 90		 npad	 2
$LN11@SmGetInstr:
  0006c	00 00 00 00	 DD	 $LN4@SmGetInstr
  00070	00 00 00 00	 DD	 $LN5@SmGetInstr
  00074	00 00 00 00	 DD	 $LN6@SmGetInstr
  00078	00 00 00 00	 DD	 $LN7@SmGetInstr
  0007c	00 00 00 00	 DD	 $LN8@SmGetInstr
$LN10@SmGetInstr:
  00080	00		 DB	 0
  00081	00		 DB	 0
  00082	01		 DB	 1
  00083	02		 DB	 2
  00084	03		 DB	 3
  00085	04		 DB	 4
  00086	01		 DB	 1
  00087	01		 DB	 1
  00088	01		 DB	 1
  00089	02		 DB	 2
  0008a	02		 DB	 2
  0008b	03		 DB	 3
  0008c	01		 DB	 1
  0008d	01		 DB	 1
  0008e	01		 DB	 1
  0008f	02		 DB	 2
  00090	02		 DB	 2
  00091	03		 DB	 3
  00092	00		 DB	 0
  00093	00		 DB	 0
  00094	00		 DB	 0
  00095	00		 DB	 0
  00096	00		 DB	 0
  00097	00		 DB	 0
  00098	00		 DB	 0
  00099	00		 DB	 0
  0009a	00		 DB	 0
  0009b	00		 DB	 0
  0009c	00		 DB	 0
  0009d	00		 DB	 0
  0009e	00		 DB	 0
  0009f	00		 DB	 0
  000a0	00		 DB	 0
  000a1	00		 DB	 0
  000a2	00		 DB	 0
  000a3	00		 DB	 0
  000a4	00		 DB	 0
  000a5	00		 DB	 0
  000a6	01		 DB	 1
  000a7	01		 DB	 1
  000a8	01		 DB	 1
  000a9	01		 DB	 1
  000aa	01		 DB	 1
  000ab	01		 DB	 1
  000ac	01		 DB	 1
  000ad	01		 DB	 1
  000ae	00		 DB	 0
  000af	00		 DB	 0
  000b0	00		 DB	 0
  000b1	00		 DB	 0
  000b2	00		 DB	 0
  000b3	00		 DB	 0
  000b4	00		 DB	 0
  000b5	00		 DB	 0
  000b6	00		 DB	 0
  000b7	00		 DB	 0
  000b8	00		 DB	 0
  000b9	00		 DB	 0
  000ba	00		 DB	 0
  000bb	00		 DB	 0
  000bc	00		 DB	 0
  000bd	00		 DB	 0
  000be	00		 DB	 0
  000bf	00		 DB	 0
  000c0	00		 DB	 0
  000c1	00		 DB	 0
  000c2	00		 DB	 0
  000c3	00		 DB	 0
  000c4	00		 DB	 0
  000c5	00		 DB	 0
  000c6	00		 DB	 0
  000c7	00		 DB	 0
  000c8	00		 DB	 0
  000c9	00		 DB	 0
  000ca	00		 DB	 0
  000cb	00		 DB	 0
  000cc	00		 DB	 0
  000cd	00		 DB	 0
  000ce	00		 DB	 0
  000cf	00		 DB	 0
  000d0	00		 DB	 0
  000d1	00		 DB	 0
  000d2	00		 DB	 0
  000d3	00		 DB	 0
  000d4	00		 DB	 0
  000d5	00		 DB	 0
  000d6	00		 DB	 0
  000d7	00		 DB	 0
  000d8	00		 DB	 0
  000d9	00		 DB	 0
  000da	00		 DB	 0
  000db	04		 DB	 4
  000dc	04		 DB	 4
  000dd	04		 DB	 4
  000de	04		 DB	 4
  000df	04		 DB	 4
  000e0	04		 DB	 4
  000e1	04		 DB	 4
  000e2	04		 DB	 4
  000e3	00		 DB	 0
  000e4	00		 DB	 0
  000e5	02		 DB	 2
  000e6	01		 DB	 1
  000e7	01		 DB	 1
  000e8	01		 DB	 1
  000e9	01		 DB	 1
  000ea	00		 DB	 0
  000eb	00		 DB	 0
  000ec	00		 DB	 0
  000ed	00		 DB	 0
  000ee	00		 DB	 0
  000ef	00		 DB	 0
  000f0	00		 DB	 0
  000f1	00		 DB	 0
  000f2	00		 DB	 0
  000f3	00		 DB	 0
  000f4	00		 DB	 0
  000f5	00		 DB	 0
  000f6	00		 DB	 0
  000f7	00		 DB	 0
  000f8	00		 DB	 0
  000f9	04		 DB	 4
  000fa	04		 DB	 4
  000fb	04		 DB	 4
  000fc	04		 DB	 4
  000fd	04		 DB	 4
  000fe	04		 DB	 4
  000ff	04		 DB	 4
  00100	04		 DB	 4
  00101	02		 DB	 2
  00102	02		 DB	 2
  00103	02		 DB	 2
  00104	02		 DB	 2
  00105	02		 DB	 2
  00106	02		 DB	 2
  00107	02		 DB	 2
  00108	02		 DB	 2
?SmGetInstructionSize@@YAHE@Z ENDP			; SmGetInstructionSize
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FInstructions@@YAXXZ
text$yd	SEGMENT
??__FInstructions@@YAXXZ PROC				; `dynamic atexit destructor for 'Instructions'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Instructions@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Instructions
  0000b	e8 00 00 00 00	 call	 ??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::~vector<_SYMBOL *,std::allocator<_SYMBOL *> >
  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
??__FInstructions@@YAXXZ ENDP				; `dynamic atexit destructor for 'Instructions''
text$yd	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ??__EInstructions@@YAXXZ
text$di	SEGMENT
??__EInstructions@@YAXXZ PROC				; `dynamic initializer for 'Instructions'', COMDAT

; 65   : std::vector<PSYMBOL> Instructions;

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	ba 18 00 00 00	 mov	 edx, 24
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Instructions@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Instructions
  00010	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Instructions@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Instructions
  0001c	e8 00 00 00 00	 call	 ??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::vector<_SYMBOL *,std::allocator<_SYMBOL *> >
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FInstructions@@YAXXZ ; `dynamic atexit destructor for 'Instructions''
  00028	e8 00 00 00 00	 call	 atexit
  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
??__EInstructions@@YAXXZ ENDP				; `dynamic initializer for 'Instructions''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FLabels@@YAXXZ
text$yd	SEGMENT
??__FLabels@@YAXXZ PROC					; `dynamic atexit destructor for 'Labels'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Labels@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Labels
  0000b	e8 00 00 00 00	 call	 ??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::~vector<_SYMBOL *,std::allocator<_SYMBOL *> >
  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
??__FLabels@@YAXXZ ENDP					; `dynamic atexit destructor for 'Labels''
text$yd	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ??__ELabels@@YAXXZ
text$di	SEGMENT
??__ELabels@@YAXXZ PROC					; `dynamic initializer for 'Labels'', COMDAT

; 64   : std::vector<PSYMBOL> Labels;

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	ba 18 00 00 00	 mov	 edx, 24
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Labels@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Labels
  00010	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Labels@@3V?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@A ; Labels
  0001c	e8 00 00 00 00	 call	 ??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::vector<_SYMBOL *,std::allocator<_SYMBOL *> >
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FLabels@@YAXXZ ; `dynamic atexit destructor for 'Labels''
  00028	e8 00 00 00 00	 call	 atexit
  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
??__ELabels@@YAXXZ ENDP					; `dynamic initializer for 'Labels''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Get_first, COMDAT

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1348 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1349 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Get_first, COMDAT

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1344 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1345 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<_SYMBOL *> >::_Vector_val<std::_Simple_types<_SYMBOL *> >, COMDAT

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0002b	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00030	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<_SYMBOL *> >::_Vector_val<std::_Simple_types<_SYMBOL *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal, COMDAT

; 1735 :     const _Alty& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1736 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Get_first

; 1737 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal, COMDAT

; 1731 :     _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1732 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Get_first

; 1733 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAXPEAPEAU_SYMBOL@@0@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
?_Orphan_range@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAXPEAPEAU_SYMBOL@@0@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Orphan_range, COMDAT

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000f	c3		 ret	 0
?_Orphan_range@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAXPEAPEAU_SYMBOL@@0@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@CAXXZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1704 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
?_Xlength@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@CAXXZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Mylast$ = 48
_Myend$ = 56
tv88 = 64
tv86 = 72
tv90 = 80
this$ = 112
?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Tidy, COMDAT

; 1685 :     void _Tidy() noexcept { // free all storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00022	48 83 c0 08	 add	 rax, 8
  00026	48 89 44 24 30	 mov	 QWORD PTR _Mylast$[rsp], rax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  0002b	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00030	48 83 c0 10	 add	 rax, 16
  00034	48 89 44 24 38	 mov	 QWORD PTR _Myend$[rsp], rax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00039	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0003e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00048	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004c	0f 84 8a 00 00
	00		 je	 $LN2@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00057	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0005f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00071	e8 00 00 00 00	 call	 ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
  00076	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00085	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 2b c1	 sub	 rax, rcx
  0008e	48 c1 f8 03	 sar	 rax, 3
  00092	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0009c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009f	48 89 44 24 48	 mov	 QWORD PTR tv86[rsp], rax
  000a4	4c 8b 44 24 40	 mov	 r8, QWORD PTR tv88[rsp]
  000a9	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv86[rsp]
  000ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv90[rsp]
  000b3	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL *>::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000bd	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1698 :             _Mylast  = pointer();

  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  000c9	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1699 :             _Myend   = pointer();

  000d0	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  000d5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@Tidy:

; 1700 :         }
; 1701 :     }

  000dc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e0	c3		 ret	 0
?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXQEAPEAU_SYMBOL@@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Mylast$ = 48
_Myend$ = 56
tv88 = 64
tv86 = 72
tv90 = 80
this$ = 112
_Newvec$ = 120
_Newsize$ = 128
_Newcapacity$ = 136
?_Change_array@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXQEAPEAU_SYMBOL@@_K1@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Change_array, COMDAT

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00027	48 89 44 24 20	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  0002c	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00031	48 83 c0 08	 add	 rax, 8
  00035	48 89 44 24 30	 mov	 QWORD PTR _Mylast$[rsp], rax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  0003a	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003f	48 83 c0 10	 add	 rax, 16
  00043	48 89 44 24 38	 mov	 QWORD PTR _Myend$[rsp], rax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0004d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00057	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0005b	74 66		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00062	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0006a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0006d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00072	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00077	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	e8 00 00 00 00	 call	 ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
  00081	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00090	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00093	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00096	48 2b c1	 sub	 rax, rcx
  00099	48 c1 f8 03	 sar	 rax, 3
  0009d	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
  000a2	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000aa	48 89 44 24 48	 mov	 QWORD PTR tv86[rsp], rax
  000af	4c 8b 44 24 40	 mov	 r8, QWORD PTR tv88[rsp]
  000b4	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv86[rsp]
  000b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv90[rsp]
  000be	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL *>::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  000c3	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  000cd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000d0	48 8b 44 24 78	 mov	 rax, QWORD PTR _Newvec$[rsp]
  000d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Newsize$[rsp]
  000dd	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  000e1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Mylast$[rsp]
  000e6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000e9	48 8b 44 24 78	 mov	 rax, QWORD PTR _Newvec$[rsp]
  000ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _Newcapacity$[rsp]
  000f6	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  000fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Myend$[rsp]
  000ff	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1683 :     }

  00102	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00106	c3		 ret	 0
?_Change_array@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXQEAPEAU_SYMBOL@@_K1@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Geometric$ = 40
tv67 = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Calculate_growth, COMDAT

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ?capacity@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::capacity
  00018	48 89 44 24 20	 mov	 QWORD PTR _Oldcapacity$[rsp], rax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00022	e8 00 00 00 00	 call	 ?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::max_size
  00027	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
  0002c	33 d2		 xor	 edx, edx
  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Oldcapacity$[rsp]
  00033	b9 02 00 00 00	 mov	 ecx, 2
  00038	48 f7 f1	 div	 rcx
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv67[rsp]
  00040	48 2b c8	 sub	 rcx, rax
  00043	48 8b c1	 mov	 rax, rcx
  00046	48 39 44 24 20	 cmp	 QWORD PTR _Oldcapacity$[rsp], rax
  0004b	76 07		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00052	eb 37		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00054	33 d2		 xor	 edx, edx
  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR _Oldcapacity$[rsp]
  0005b	b9 02 00 00 00	 mov	 ecx, 2
  00060	48 f7 f1	 div	 rcx
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Oldcapacity$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	48 89 44 24 28	 mov	 QWORD PTR _Geometric$[rsp], rax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00078	48 39 44 24 28	 cmp	 QWORD PTR _Geometric$[rsp], rax
  0007d	73 07		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00084	eb 05		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 1630 :     }

  0008b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008f	c3		 ret	 0
?_Calculate_growth@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Destroy, COMDAT

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
  0001d	4c 8b c0	 mov	 r8, rax
  00020	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  00025	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  0002a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAXPEAPEAU_SYMBOL@@QEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z ; std::_Destroy_range<std::allocator<_SYMBOL *> >

; 1613 :     }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_First$ = 88
_Last$ = 96
_Dest$ = 104
?_Umove_if_noexcept@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove_if_noexcept, COMDAT

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00019	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  0001e	48 8b f8	 mov	 rdi, rax
  00021	33 c0		 xor	 eax, eax
  00023	b9 01 00 00 00	 mov	 ecx, 1
  00028	f3 aa		 rep stosb
  0002a	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T1[rsp]
  0002f	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00033	4c 8b 4c 24 68	 mov	 r9, QWORD PTR _Dest$[rsp]
  00038	4c 8b 44 24 60	 mov	 r8, QWORD PTR _Last$[rsp]
  0003d	48 8b 54 24 58	 mov	 rdx, QWORD PTR _First$[rsp]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00047	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0004c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
?_Umove_if_noexcept@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
__formal$ = 80
?_Umove_if_noexcept1@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove_if_noexcept1, COMDAT

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
  00022	4c 8b c8	 mov	 r9, rax
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Dest$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  00034	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z ; std::_Uninitialized_move<_SYMBOL * *,std::allocator<_SYMBOL *> >

; 1598 :     }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
?_Umove_if_noexcept1@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove, COMDAT

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
  00022	4c 8b c8	 mov	 r9, rax
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Dest$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  00034	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAPEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@YAPEAPEAU_SYMBOL@@QEAPEAU1@0PEAPEAU1@AEAV?$allocator@PEAU_SYMBOL@@@0@@Z ; std::_Uninitialized_move<_SYMBOL * *,std::allocator<_SYMBOL *> >

; 1593 :     }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
?_Umove@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAPEAPEAU_SYMBOL@@PEAPEAU3@00@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::capacity, COMDAT

; 1492 :     _NODISCARD size_type capacity() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR _My_data$[rsp], rax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	48 8b 04 24	 mov	 rax, QWORD PTR _My_data$[rsp]
  00016	48 8b 0c 24	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0001a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00021	48 2b c1	 sub	 rax, rcx
  00024	48 c1 f8 03	 sar	 rax, 3

; 1495 :     }

  00028	48 83 c4 18	 add	 rsp, 24
  0002c	c3		 ret	 0
?capacity@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::max_size, COMDAT

; 1487 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1488 :         return (_STD min)(

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Getal@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@PEAU_SYMBOL@@@2@XZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Getal
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@PEAU_SYMBOL@@@2@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::max_size
  0001b	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00025	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0002a	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0002f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  00034	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
?max_size@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Unchecked_end@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_end, COMDAT

; 1469 :     pointer _Unchecked_end() noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1470 :         return _Mypair._Myval2._Mylast;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1471 :     }

  0000e	c3		 ret	 0
?_Unchecked_end@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_begin, COMDAT

; 1461 :     pointer _Unchecked_begin() noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1462 :         return _Mypair._Myval2._Myfirst;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1463 :     }

  0000d	c3		 ret	 0
?_Unchecked_begin@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAPEAPEAU_SYMBOL@@XZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
_Myfirst$ = 48
this$ = 80
?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::clear, COMDAT

; 1383 :     void clear() noexcept { // erase all

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR _My_data$[rsp], rax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  00022	48 83 c0 08	 add	 rax, 8
  00026	48 89 44 24 28	 mov	 QWORD PTR _Mylast$[rsp], rax

; 1387 : 
; 1388 :         _My_data._Orphan_all();

  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00030	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1389 :         _Destroy(_Myfirst, _Mylast);

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0003a	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00042	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXPEAPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Destroy

; 1390 :         _Mylast = _Myfirst;

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00054	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00059	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1391 :     }

  0005f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00063	c3		 ret	 0
?clear@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAXXZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::push_back, COMDAT

; 720  :     void push_back(_Ty&& _Val) { // insert by moving into element at end, provide strong guarantee

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 721  :         emplace_back(_STD move(_Val));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Val$[rsp]
  00013	e8 00 00 00 00	 call	 ??$move@AEAPEAU_SYMBOL@@@std@@YA$$QEAPEAU_SYMBOL@@AEAPEAU1@@Z ; std::move<_SYMBOL * &>
  00018	48 8b d0	 mov	 rdx, rax
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00020	e8 00 00 00 00	 call	 ??$emplace_back@PEAU_SYMBOL@@@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAAEAPEAU_SYMBOL@@$$QEAPEAU2@@Z ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::emplace_back<_SYMBOL *>

; 722  :     }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
?push_back@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAAX$$QEAPEAU_SYMBOL@@@Z ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::~vector<_SYMBOL *,std::allocator<_SYMBOL *> >, COMDAT

; 672  :     ~vector() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 673  :         _Tidy();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@AEAAXXZ ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::~vector<_SYMBOL *,std::allocator<_SYMBOL *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ PROC ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::vector<_SYMBOL *,std::allocator<_SYMBOL *> >, COMDAT

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00013	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  0001d	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAU_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@PEAU_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1>::_Compressed_pair<std::allocator<_SYMBOL *>,std::_Vector_val<std::_Simple_types<_SYMBOL *> >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  0002c	48 8d 54 24 21	 lea	 rdx, QWORD PTR $T2[rsp]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv78[rsp]
  00036	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00040	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00044	c3		 ret	 0
??0?$vector@PEAU_SYMBOL@@V?$allocator@PEAU_SYMBOL@@@std@@@std@@QEAA@XZ ENDP ; std::vector<_SYMBOL *,std::allocator<_SYMBOL *> >::vector<_SYMBOL *,std::allocator<_SYMBOL *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@PEAU_SYMBOL@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@PEAU_SYMBOL@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00005	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 704  :     }

  0000f	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@PEAU_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@PEAU_SYMBOL@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<_SYMBOL *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAPEAPEAU_SYMBOL@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAPEAPEAU_SYMBOL@@_K@Z PROC ; std::allocator<_SYMBOL *>::allocate, COMDAT

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Count$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YA_K_K@Z ; std::_Get_size_of_n<8>
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 808  :     }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
?allocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAPEAPEAU_SYMBOL@@_K@Z ENDP ; std::allocator<_SYMBOL *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z PROC ; std::allocator<_SYMBOL *>::deallocate, COMDAT

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR _Count$[rsp]
  00018	48 c1 e0 03	 shl	 rax, 3
  0001c	48 8b d0	 mov	 rdx, rax
  0001f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00024	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 804  :     }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
?deallocate@?$allocator@PEAU_SYMBOL@@@std@@QEAAXQEAPEAU_SYMBOL@@_K@Z ENDP ; std::allocator<_SYMBOL *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@PEAU_SYMBOL@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAU_SYMBOL@@@std@@QEAA@XZ PROC		; std::allocator<_SYMBOL *>::allocator<_SYMBOL *>, COMDAT

; 795  :     constexpr allocator() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$allocator@PEAU_SYMBOL@@@std@@QEAA@XZ ENDP		; std::allocator<_SYMBOL *>::allocator<_SYMBOL *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FSymbols@@YAXXZ
text$yd	SEGMENT
??__FSymbols@@YAXXZ PROC				; `dynamic atexit destructor for 'Symbols'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  0000b	e8 00 00 00 00	 call	 ??1?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::~vector<_SYMBOL,std::allocator<_SYMBOL> >
  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
??__FSymbols@@YAXXZ ENDP				; `dynamic atexit destructor for 'Symbols''
text$yd	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ??__ESymbols@@YAXXZ
text$di	SEGMENT
??__ESymbols@@YAXXZ PROC				; `dynamic initializer for 'Symbols'', COMDAT

; 63   : std::vector<SYMBOL> Symbols;

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	ba 18 00 00 00	 mov	 edx, 24
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  00010	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Symbols@@3V?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@A ; Symbols
  0001c	e8 00 00 00 00	 call	 ??0?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::vector<_SYMBOL,std::allocator<_SYMBOL> >
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FSymbols@@YAXXZ ; `dynamic atexit destructor for 'Symbols''
  00028	e8 00 00 00 00	 call	 atexit
  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
??__ESymbols@@YAXXZ ENDP				; `dynamic initializer for 'Symbols''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_SYMBOL@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_SYMBOL@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Get_first, COMDAT

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1348 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1349 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_SYMBOL@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_SYMBOL@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_SYMBOL@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Get_first, COMDAT

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1344 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1345 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<_SYMBOL> >::_Vector_val<std::_Simple_types<_SYMBOL> >, COMDAT

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0002b	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00030	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<_SYMBOL> >::_Vector_val<std::_Simple_types<_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@U_SYMBOL@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@U_SYMBOL@@@2@XZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal, COMDAT

; 1735 :     const _Alty& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1736 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_SYMBOL@@@2@XZ ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Get_first

; 1737 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@U_SYMBOL@@@2@XZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal, COMDAT

; 1731 :     _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1732 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Get_first

; 1733 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAXPEAU_SYMBOL@@0@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
?_Orphan_range@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAXPEAU_SYMBOL@@0@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Orphan_range, COMDAT

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000f	c3		 ret	 0
?_Orphan_range@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAXPEAU_SYMBOL@@0@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@CAXXZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1704 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
?_Xlength@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@CAXXZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Mylast$ = 48
_Myend$ = 56
tv88 = 64
tv86 = 72
tv90 = 80
this$ = 112
?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Tidy, COMDAT

; 1685 :     void _Tidy() noexcept { // free all storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00022	48 83 c0 08	 add	 rax, 8
  00026	48 89 44 24 30	 mov	 QWORD PTR _Mylast$[rsp], rax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  0002b	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00030	48 83 c0 10	 add	 rax, 16
  00034	48 89 44 24 38	 mov	 QWORD PTR _Myend$[rsp], rax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00039	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0003e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00048	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004c	0f 84 90 00 00
	00		 je	 $LN2@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00057	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0005f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00071	e8 00 00 00 00	 call	 ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
  00076	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00085	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 2b c1	 sub	 rax, rcx
  0008e	48 99		 cdq
  00090	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00095	48 f7 f9	 idiv	 rcx
  00098	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 89 44 24 48	 mov	 QWORD PTR tv86[rsp], rax
  000aa	4c 8b 44 24 40	 mov	 r8, QWORD PTR tv88[rsp]
  000af	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv86[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv90[rsp]
  000b9	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL>::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000c3	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1698 :             _Mylast  = pointer();

  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  000cf	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1699 :             _Myend   = pointer();

  000d6	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  000db	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@Tidy:

; 1700 :         }
; 1701 :     }

  000e2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e6	c3		 ret	 0
?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXQEAU_SYMBOL@@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Mylast$ = 48
_Myend$ = 56
tv88 = 64
tv86 = 72
tv90 = 80
this$ = 112
_Newvec$ = 120
_Newsize$ = 128
_Newcapacity$ = 136
?_Change_array@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXQEAU_SYMBOL@@_K1@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Change_array, COMDAT

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00027	48 89 44 24 20	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  0002c	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00031	48 83 c0 08	 add	 rax, 8
  00035	48 89 44 24 30	 mov	 QWORD PTR _Mylast$[rsp], rax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  0003a	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003f	48 83 c0 10	 add	 rax, 16
  00043	48 89 44 24 38	 mov	 QWORD PTR _Myend$[rsp], rax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0004d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00057	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0005b	74 6c		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00062	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0006a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0006d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00072	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00077	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	e8 00 00 00 00	 call	 ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
  00081	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00090	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00093	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00096	48 2b c1	 sub	 rax, rcx
  00099	48 99		 cdq
  0009b	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000a0	48 f7 f9	 idiv	 rcx
  000a3	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b0	48 89 44 24 48	 mov	 QWORD PTR tv86[rsp], rax
  000b5	4c 8b 44 24 40	 mov	 r8, QWORD PTR tv88[rsp]
  000ba	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv86[rsp]
  000bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv90[rsp]
  000c4	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z ; std::allocator<_SYMBOL>::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  000d3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000d6	48 6b 84 24 80
	00 00 00 48	 imul	 rax, QWORD PTR _Newsize$[rsp], 72 ; 00000048H
  000df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  000e4	48 03 c8	 add	 rcx, rax
  000e7	48 8b c1	 mov	 rax, rcx
  000ea	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Mylast$[rsp]
  000ef	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000f2	48 6b 84 24 88
	00 00 00 48	 imul	 rax, QWORD PTR _Newcapacity$[rsp], 72 ; 00000048H
  000fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Myend$[rsp]
  0010b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1683 :     }

  0010e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00112	c3		 ret	 0
?_Change_array@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXQEAU_SYMBOL@@_K1@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Geometric$ = 40
tv67 = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Calculate_growth, COMDAT

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ?capacity@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::capacity
  00018	48 89 44 24 20	 mov	 QWORD PTR _Oldcapacity$[rsp], rax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00022	e8 00 00 00 00	 call	 ?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::max_size
  00027	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
  0002c	33 d2		 xor	 edx, edx
  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Oldcapacity$[rsp]
  00033	b9 02 00 00 00	 mov	 ecx, 2
  00038	48 f7 f1	 div	 rcx
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv67[rsp]
  00040	48 2b c8	 sub	 rcx, rax
  00043	48 8b c1	 mov	 rax, rcx
  00046	48 39 44 24 20	 cmp	 QWORD PTR _Oldcapacity$[rsp], rax
  0004b	76 07		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00052	eb 37		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00054	33 d2		 xor	 edx, edx
  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR _Oldcapacity$[rsp]
  0005b	b9 02 00 00 00	 mov	 ecx, 2
  00060	48 f7 f1	 div	 rcx
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Oldcapacity$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	48 89 44 24 28	 mov	 QWORD PTR _Geometric$[rsp], rax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00078	48 39 44 24 28	 cmp	 QWORD PTR _Geometric$[rsp], rax
  0007d	73 07		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00084	eb 05		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 1630 :     }

  0008b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008f	c3		 ret	 0
?_Calculate_growth@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Destroy, COMDAT

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
  0001d	4c 8b c0	 mov	 r8, rax
  00020	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  00025	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  0002a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@U_SYMBOL@@@std@@@std@@YAXPEAU_SYMBOL@@QEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z ; std::_Destroy_range<std::allocator<_SYMBOL> >

; 1613 :     }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_First$ = 88
_Last$ = 96
_Dest$ = 104
?_Umove_if_noexcept@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove_if_noexcept, COMDAT

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00019	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  0001e	48 8b f8	 mov	 rdi, rax
  00021	33 c0		 xor	 eax, eax
  00023	b9 01 00 00 00	 mov	 ecx, 1
  00028	f3 aa		 rep stosb
  0002a	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T1[rsp]
  0002f	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00033	4c 8b 4c 24 68	 mov	 r9, QWORD PTR _Dest$[rsp]
  00038	4c 8b 44 24 60	 mov	 r8, QWORD PTR _Last$[rsp]
  0003d	48 8b 54 24 58	 mov	 rdx, QWORD PTR _First$[rsp]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00047	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0004c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
?_Umove_if_noexcept@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
__formal$ = 80
?_Umove_if_noexcept1@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove_if_noexcept1, COMDAT

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
  00022	4c 8b c8	 mov	 r9, rax
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Dest$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  00034	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z ; std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >

; 1598 :     }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
?_Umove_if_noexcept1@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove, COMDAT

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAAEAV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
  00022	4c 8b c8	 mov	 r9, rax
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Dest$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  00034	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAU_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@YAPEAU_SYMBOL@@QEAU1@0PEAU1@AEAV?$allocator@U_SYMBOL@@@0@@Z ; std::_Uninitialized_move<_SYMBOL *,std::allocator<_SYMBOL> >

; 1593 :     }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
?_Umove@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAPEAU_SYMBOL@@PEAU3@00@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
_Pos$ = 40
??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[], COMDAT

; 1497 :     _NODISCARD _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR _My_data$[rsp], rax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00017	48 6b 44 24 28
	48		 imul	 rax, QWORD PTR _Pos$[rsp], 72 ; 00000048H
  0001d	48 8b 0c 24	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00021	48 03 01	 add	 rax, QWORD PTR [rcx]

; 1505 :     }

  00024	48 83 c4 18	 add	 rsp, 24
  00028	c3		 ret	 0
??A?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAAEAU_SYMBOL@@_K@Z ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::capacity, COMDAT

; 1492 :     _NODISCARD size_type capacity() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR _My_data$[rsp], rax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	48 8b 04 24	 mov	 rax, QWORD PTR _My_data$[rsp]
  00016	48 8b 0c 24	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0001a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00021	48 2b c1	 sub	 rax, rcx
  00024	48 99		 cdq
  00026	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0002b	48 f7 f9	 idiv	 rcx

; 1495 :     }

  0002e	48 83 c4 18	 add	 rsp, 24
  00032	c3		 ret	 0
?capacity@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::max_size, COMDAT

; 1487 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1488 :         return (_STD min)(

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Getal@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEBAAEBV?$allocator@U_SYMBOL@@@2@XZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Getal
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@U_SYMBOL@@@2@@Z ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::max_size
  0001b	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00025	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0002a	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0002f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  00034	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
?max_size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::size, COMDAT

; 1482 :     _NODISCARD size_type size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR _My_data$[rsp], rax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	48 8b 04 24	 mov	 rax, QWORD PTR _My_data$[rsp]
  00016	48 8b 0c 24	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0001a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00021	48 2b c1	 sub	 rax, rcx
  00024	48 99		 cdq
  00026	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0002b	48 f7 f9	 idiv	 rcx

; 1485 :     }

  0002e	48 83 c4 18	 add	 rsp, 24
  00032	c3		 ret	 0
?size@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
_Myfirst$ = 48
this$ = 80
?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::clear, COMDAT

; 1383 :     void clear() noexcept { // erase all

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR _My_data$[rsp], rax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  00022	48 83 c0 08	 add	 rax, 8
  00026	48 89 44 24 28	 mov	 QWORD PTR _Mylast$[rsp], rax

; 1387 : 
; 1388 :         _My_data._Orphan_all();

  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00030	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1389 :         _Destroy(_Myfirst, _Mylast);

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  0003a	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00042	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXPEAU_SYMBOL@@0@Z ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Destroy

; 1390 :         _Mylast = _Myfirst;

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00054	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00059	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1391 :     }

  0005f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00063	c3		 ret	 0
?clear@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAAXXZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::~vector<_SYMBOL,std::allocator<_SYMBOL> >, COMDAT

; 672  :     ~vector() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 673  :         _Tidy();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@AEAAXXZ ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::~vector<_SYMBOL,std::allocator<_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ PROC ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::vector<_SYMBOL,std::allocator<_SYMBOL> >, COMDAT

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00013	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  0001d	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@U_SYMBOL@@@std@@V?$_Vector_val@U?$_Simple_types@U_SYMBOL@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1>::_Compressed_pair<std::allocator<_SYMBOL>,std::_Vector_val<std::_Simple_types<_SYMBOL> >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  0002c	48 8d 54 24 21	 lea	 rdx, QWORD PTR $T2[rsp]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv78[rsp]
  00036	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00040	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00044	c3		 ret	 0
??0?$vector@U_SYMBOL@@V?$allocator@U_SYMBOL@@@std@@@std@@QEAA@XZ ENDP ; std::vector<_SYMBOL,std::allocator<_SYMBOL> >::vector<_SYMBOL,std::allocator<_SYMBOL> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@U_SYMBOL@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@U_SYMBOL@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00005	48 b8 8e e3 38
	8e e3 38 8e 03	 mov	 rax, 256204778801521550	; 038e38e38e38e38eH

; 704  :     }

  0000f	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U_SYMBOL@@@std@@@std@@SA_KAEBV?$allocator@U_SYMBOL@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<_SYMBOL> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@U_SYMBOL@@@std@@QEAAPEAU_SYMBOL@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U_SYMBOL@@@std@@QEAAPEAU_SYMBOL@@_K@Z PROC ; std::allocator<_SYMBOL>::allocate, COMDAT

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Count$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0EI@@std@@YA_K_K@Z ; std::_Get_size_of_n<72>
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 808  :     }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
?allocate@?$allocator@U_SYMBOL@@@std@@QEAAPEAU_SYMBOL@@_K@Z ENDP ; std::allocator<_SYMBOL>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z PROC ; std::allocator<_SYMBOL>::deallocate, COMDAT

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 6b 44 24 40
	48		 imul	 rax, QWORD PTR _Count$[rsp], 72 ; 00000048H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00021	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 804  :     }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?deallocate@?$allocator@U_SYMBOL@@@std@@QEAAXQEAU_SYMBOL@@_K@Z ENDP ; std::allocator<_SYMBOL>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@U_SYMBOL@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U_SYMBOL@@@std@@QEAA@XZ PROC		; std::allocator<_SYMBOL>::allocator<_SYMBOL>, COMDAT

; 795  :     constexpr allocator() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$allocator@U_SYMBOL@@@std@@QEAA@XZ ENDP		; std::allocator<_SYMBOL>::allocator<_SYMBOL>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z
_TEXT	SEGMENT
Block$ = 24
Item$ = 32
ItemSize$ = 40
?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z PROC		; SmPushBackBlock, COMDAT

; 58   : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi

; 59   : 	memcpy(Block->Offset, Item, ItemSize);

  00011	8b 44 24 28	 mov	 eax, DWORD PTR ItemSize$[rsp]
  00015	48 8b 4c 24 18	 mov	 rcx, QWORD PTR Block$[rsp]
  0001a	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  0001e	48 8b 74 24 20	 mov	 rsi, QWORD PTR Item$[rsp]
  00023	8b c8		 mov	 ecx, eax
  00025	f3 a4		 rep movsb

; 60   : 	Block->Offset = (PUCHAR)Block->Offset + ItemSize;

  00027	8b 44 24 28	 mov	 eax, DWORD PTR ItemSize$[rsp]
  0002b	48 8b 4c 24 18	 mov	 rcx, QWORD PTR Block$[rsp]
  00030	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00034	48 8b 4c 24 18	 mov	 rcx, QWORD PTR Block$[rsp]
  00039	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 61   : }

  0003d	5f		 pop	 rdi
  0003e	5e		 pop	 rsi
  0003f	c3		 ret	 0
?SmPushBackBlock@@YAXPEAU_SMCB@@PEAXK@Z ENDP		; SmPushBackBlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SmAllocCodeBlock@@YAXPEAU_SMCB@@K@Z
_TEXT	SEGMENT
Block$ = 48
Size$ = 56
?SmAllocCodeBlock@@YAXPEAU_SMCB@@K@Z PROC		; SmAllocCodeBlock, COMDAT

; 51   : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 52   : 	Block->Base = malloc(Size);

  0000d	8b 44 24 38	 mov	 eax, DWORD PTR Size$[rsp]
  00011	8b c8		 mov	 ecx, eax
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Block$[rsp]
  0001e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 53   : 	Block->Offset = Block->Base;

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR Block$[rsp]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Block$[rsp]
  0002b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 54   : 	Block->Capacity = Size;

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR Block$[rsp]
  00037	8b 4c 24 38	 mov	 ecx, DWORD PTR Size$[rsp]
  0003b	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 55   : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
?SmAllocCodeBlock@@YAXPEAU_SMCB@@K@Z ENDP		; SmAllocCodeBlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\algorithm
;	COMDAT ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z
_TEXT	SEGMENT
tv83 = 32
_UFirst$ = 40
_UDest$ = 48
_ULast$ = 56
__$ArrayPad$ = 64
__$ReturnUdt$ = 96
_First$ = 104
_Last$ = 112
_Dest$ = 120
_Func$ = 128
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z PROC ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>, COMDAT

; 2209 : _CONSTEXPR20 _OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2210 :     // transform [_First, _Last) with _Func
; 2211 :     _Adl_verify_range(_First, _Last);

  00027	48 8d 54 24 70	 lea	 rdx, QWORD PTR _Last$[rsp]
  0002c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR _First$[rsp]
  00031	e8 00 00 00 00	 call	 ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >

; 2212 :     auto _UFirst      = _Get_unwrapped(_First);

  00036	48 8d 4c 24 68	 lea	 rcx, QWORD PTR _First$[rsp]
  0003b	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>
  00040	48 89 44 24 28	 mov	 QWORD PTR _UFirst$[rsp], rax

; 2213 :     const auto _ULast = _Get_unwrapped(_Last);

  00045	48 8d 4c 24 70	 lea	 rcx, QWORD PTR _Last$[rsp]
  0004a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YAPEADAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > const &>
  0004f	48 89 44 24 38	 mov	 QWORD PTR _ULast$[rsp], rax

; 2214 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  00054	48 8d 54 24 38	 lea	 rdx, QWORD PTR _ULast$[rsp]
  00059	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _UFirst$[rsp]
  0005e	e8 00 00 00 00	 call	 ??$_Idl_distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@PEAD@std@@YA_JAEBQEAD0@Z ; std::_Idl_distance<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char *>
  00063	48 8b d0	 mov	 rdx, rax
  00066	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _Dest$[rsp]
  0006b	e8 00 00 00 00	 call	 ??$_Get_unwrapped_n@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@_J@std@@YAPEADAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &,__int64>
  00070	48 89 44 24 30	 mov	 QWORD PTR _UDest$[rsp], rax

; 2215 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {

  00075	eb 1a		 jmp	 SHORT $LN4@transform
$LN2@transform:
  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR _UFirst$[rsp]
  0007c	48 ff c0	 inc	 rax
  0007f	48 89 44 24 28	 mov	 QWORD PTR _UFirst$[rsp], rax
  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR _UDest$[rsp]
  00089	48 ff c0	 inc	 rax
  0008c	48 89 44 24 30	 mov	 QWORD PTR _UDest$[rsp], rax
$LN4@transform:
  00091	48 8b 44 24 38	 mov	 rax, QWORD PTR _ULast$[rsp]
  00096	48 39 44 24 28	 cmp	 QWORD PTR _UFirst$[rsp], rax
  0009b	74 24		 je	 SHORT $LN3@transform

; 2216 :         *_UDest = _Func(*_UFirst);

  0009d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Func$[rsp]
  000a5	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR _UFirst$[rsp]
  000af	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b2	8b c8		 mov	 ecx, eax
  000b4	ff 54 24 20	 call	 QWORD PTR tv83[rsp]
  000b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _UDest$[rsp]
  000bd	88 01		 mov	 BYTE PTR [rcx], al

; 2217 :     }

  000bf	eb b6		 jmp	 SHORT $LN2@transform
$LN3@transform:

; 2218 : 
; 2219 :     _Seek_wrapped(_Dest, _UDest);

  000c1	48 8d 54 24 30	 lea	 rdx, QWORD PTR _UDest$[rsp]
  000c6	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _Dest$[rsp]
  000cb	e8 00 00 00 00	 call	 ??$_Seek_wrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@AEAPEAD@std@@YAXAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@AEAPEAD@Z ; std::_Seek_wrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,char * &>

; 2220 :     return _Dest;

  000d0	48 8b 44 24 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  000d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Dest$[rsp]
  000da	48 89 08	 mov	 QWORD PTR [rax], rcx
  000dd	48 8b 44 24 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 2221 : }

  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e7	48 33 cc	 xor	 rcx, rsp
  000ea	e8 00 00 00 00	 call	 __security_check_cookie
  000ef	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f3	c3		 ret	 0
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z ENDP ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	4c 8b 44 24 40	 mov	 r8, QWORD PTR __param1$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR __param0$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00022	e8 00 00 00 00	 call	 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped, COMDAT

; 2059 :     _NODISCARD value_type* _Unwrapped() const {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2060 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00011	e8 00 00 00 00	 call	 ??$_Unfancy@$$CBD@std@@YAPEBDPEBD@Z ; std::_Unfancy<char const >

; 2061 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
_Tmp$ = 32
__$ArrayPad$ = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator+, COMDAT

; 2036 :     _NODISCARD _String_iterator operator+(const difference_type _Off) const {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2037 :         _String_iterator _Tmp = *this;

  00022	ba 08 00 00 00	 mov	 edx, 8
  00027	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Tmp$[rsp]
  0002c	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAX_K@Z
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 89 44 24 20	 mov	 QWORD PTR _Tmp$[rsp], rax

; 2038 :         return _Tmp += _Off;

  0003e	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Off$[rsp]
  00043	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Tmp$[rsp]
  00048	e8 00 00 00 00	 call	 ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator+=
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00055	48 89 01	 mov	 QWORD PTR [rcx], rax
  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 2039 :     }

  0005d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00062	48 33 cc	 xor	 rcx, rsp
  00065	e8 00 00 00 00	 call	 __security_check_cookie
  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator+=, COMDAT

; 2031 :     _String_iterator& operator+=(const difference_type _Off) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2032 :         _Mybase::operator+=(_Off);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Off$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator+=

; 2033 :         return *this;

  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]

; 2034 :     }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z
_TEXT	SEGMENT
this$ = 48
_It$ = 56
?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Seek_to, COMDAT

; 1940 :     void _Seek_to(const value_type* _It) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1941 :         _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _It$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Refancy@PEBD$0A@@std@@YAPEBDPEBD@Z ; std::_Refancy<char const *,0>
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1942 :     }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
?_Seek_to@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAXPEBD@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator+=, COMDAT

; 1861 :     _String_const_iterator& operator+=(const difference_type _Off) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1862 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1863 :         _Verify_offset(_Off);
; 1864 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1865 :         _Ptr += _Off;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 03 44 24 10	 add	 rax, QWORD PTR _Off$[rsp]
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0001c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1866 :         return *this;

  0001f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1867 :     }

  00024	c3		 ret	 0
??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Verify_offset, COMDAT

; 1833 :     void _Verify_offset(const difference_type _Off) const noexcept {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1834 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1835 :         if (_Off == 0) {
; 1836 :             return;
; 1837 :         }
; 1838 : 
; 1839 :         _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
; 1840 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1841 :         _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was"
; 1842 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1843 :         const auto _Contptr = _Mycont->_Myptr();
; 1844 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1845 : 
; 1846 :         if (_Off < 0) {
; 1847 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1848 :             _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
; 1849 :         }
; 1850 : 
; 1851 :         if (_Off > 0) {
; 1852 :             using _Size_type = typename _Mystr::size_type;
; 1853 :             const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
; 1854 :             _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
; 1855 :         }
; 1856 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1857 :         (void) _Off;
; 1858 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1859 :     }

  0000a	c3		 ret	 0
?_Verify_offset@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAX_J@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pstring$ = 64
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1771 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Parg$[rsp]
  0001d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1772 :         this->_Adopt(_Pstring);

  00020	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Pstring$[rsp]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt

; 1773 :     }

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_SYMBOL@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_SYMBOL@@QEAAPEAXI@Z PROC				; _SYMBOL::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1_SYMBOL@@QEAA@XZ
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G_SYMBOL@@QEAAPEAXI@Z ENDP				; _SYMBOL::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_SYMBOL@@QEAA@$$QEAU0@@Z
_TEXT	SEGMENT
tv78 = 32
tv87 = 40
this$ = 64
__that$ = 72
??0_SYMBOL@@QEAA@$$QEAU0@@Z PROC			; _SYMBOL::_SYMBOL, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00018	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0001a	89 08		 mov	 DWORD PTR [rax], ecx
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00026	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  0002a	88 48 04	 mov	 BYTE PTR [rax+4], cl
  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00037	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0003a	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00042	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00047	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  0004a	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00052	48 83 c0 10	 add	 rax, 16
  00056	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  0005b	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  00060	48 83 c0 10	 add	 rax, 16
  00064	48 8b d0	 mov	 rdx, rax
  00067	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv78[rsp]
  0006c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00076	48 83 c0 30	 add	 rax, 48			; 00000030H
  0007a	48 89 44 24 28	 mov	 QWORD PTR tv87[rsp], rax
  0007f	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  00084	48 83 c0 30	 add	 rax, 48			; 00000030H
  00088	48 8b d0	 mov	 rdx, rax
  0008b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv87[rsp]
  00090	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009e	c3		 ret	 0
??0_SYMBOL@@QEAA@$$QEAU0@@Z ENDP			; _SYMBOL::_SYMBOL
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_SYMBOL@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_SYMBOL@@QEAA@XZ PROC				; _SYMBOL::~_SYMBOL, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 30	 add	 rax, 48			; 00000030H
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 83 c0 10	 add	 rax, 16
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
??1_SYMBOL@@QEAA@XZ ENDP				; _SYMBOL::~_SYMBOL
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv71 = 48
tv86 = 56
$T1 = 64
tv93 = 72
$T2 = 80
tv132 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
tv160 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 200
this$ = 240
Il$ = 248
L$ = 256
??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; _SYMBOL::_SYMBOL, COMDAT

; 37   : 	{

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 36   : 		: Offset(0), IsLabel(Il), Line(L), Ele() 

  00015	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0001d	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR Il$[rsp]
  00024	89 08		 mov	 DWORD PTR [rax], ecx
  00026	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
  00035	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0003d	48 83 c0 10	 add	 rax, 16
  00041	48 89 44 24 30	 mov	 QWORD PTR tv71[rsp], rax
  00046	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR L$[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv71[rsp]
  00053	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00058	90		 npad	 1
  00059	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00061	48 83 c0 30	 add	 rax, 48			; 00000030H
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006d	90		 npad	 1

; 38   : 		std::transform(Line.begin(), Line.end(), Line.begin(), ::toupper);

  0006e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00076	48 83 c0 10	 add	 rax, 16
  0007a	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
  0007f	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  00087	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv86[rsp]
  0008c	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00091	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00094	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]
  0009e	48 89 44 24 68	 mov	 QWORD PTR $T4[rsp], rax
  000a3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ab	48 83 c0 10	 add	 rax, 16
  000af	48 89 44 24 48	 mov	 QWORD PTR tv93[rsp], rax
  000b4	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T8[rsp]
  000bc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv93[rsp]
  000c1	e8 00 00 00 00	 call	 ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
  000c6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c9	48 89 44 24 50	 mov	 QWORD PTR $T2[rsp], rax
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR $T2[rsp]
  000d3	48 89 44 24 70	 mov	 QWORD PTR $T5[rsp], rax
  000d8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000e0	48 83 c0 10	 add	 rax, 16
  000e4	48 89 44 24 58	 mov	 QWORD PTR tv132[rsp], rax
  000e9	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR $T9[rsp]
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv132[rsp]
  000f6	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  000fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fe	48 89 44 24 60	 mov	 QWORD PTR $T3[rsp], rax
  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR $T3[rsp]
  00108	48 89 44 24 78	 mov	 QWORD PTR $T6[rsp], rax
  0010d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_toupper
  00114	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00119	4c 8b 4c 24 68	 mov	 r9, QWORD PTR $T4[rsp]
  0011e	4c 8b 44 24 70	 mov	 r8, QWORD PTR $T5[rsp]
  00123	48 8b 54 24 78	 mov	 rdx, QWORD PTR $T6[rsp]
  00128	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  00130	e8 00 00 00 00	 call	 ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@P6AHH@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>

; 39   : 		Ele = SplitString(Line, " ");

  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5@
  0013c	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  00144	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00149	90		 npad	 1
  0014a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00152	48 83 c0 10	 add	 rax, 16
  00156	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR $T11[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  00169	e8 00 00 00 00	 call	 ?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; SplitString
  0016e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  00176	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0017e	48 83 c0 30	 add	 rax, 48			; 00000030H
  00182	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv160[rsp]
  0018a	48 8b c8	 mov	 rcx, rax
  0018d	e8 00 00 00 00	 call	 ??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator=
  00192	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  0019a	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0019f	90		 npad	 1
  001a0	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  001a8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001ad	90		 npad	 1

; 40   : 	}

  001ae	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001b6	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  001bd	c3		 ret	 0
??0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; _SYMBOL::_SYMBOL
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv71 = 48
tv86 = 56
$T1 = 64
tv93 = 72
$T2 = 80
tv132 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
tv160 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 200
this$ = 240
Il$ = 248
L$ = 256
?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `_SYMBOL::_SYMBOL'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00010	48 83 c1 10	 add	 rcx, 16
  00014	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `_SYMBOL::_SYMBOL'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv71 = 48
tv86 = 56
$T1 = 64
tv93 = 72
$T2 = 80
tv132 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
tv160 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 200
this$ = 240
Il$ = 248
L$ = 256
?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `_SYMBOL::_SYMBOL'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00010	48 83 c1 30	 add	 rcx, 48			; 00000030H
  00014	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `_SYMBOL::_SYMBOL'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv71 = 48
tv86 = 56
$T1 = 64
tv93 = 72
$T2 = 80
tv132 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
tv160 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 200
this$ = 240
Il$ = 248
L$ = 256
?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `_SYMBOL::_SYMBOL'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `_SYMBOL::_SYMBOL'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv71 = 48
tv86 = 56
$T1 = 64
tv93 = 72
$T2 = 80
tv132 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
tv160 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 200
this$ = 240
Il$ = 248
L$ = 256
?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `_SYMBOL::_SYMBOL'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00010	48 83 c1 10	 add	 rcx, 16
  00014	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `_SYMBOL::_SYMBOL'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv71 = 48
tv86 = 56
$T1 = 64
tv93 = 72
$T2 = 80
tv132 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
tv160 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 200
this$ = 240
Il$ = 248
L$ = 256
?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `_SYMBOL::_SYMBOL'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00010	48 83 c1 30	 add	 rcx, 48			; 00000030H
  00014	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$1@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `_SYMBOL::_SYMBOL'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv71 = 48
tv86 = 56
$T1 = 64
tv93 = 72
$T2 = 80
tv132 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
tv160 = 128
$T7 = 136
$T8 = 144
$T9 = 152
$T10 = 160
$T11 = 168
$T12 = 200
this$ = 240
Il$ = 248
L$ = 256
?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `_SYMBOL::_SYMBOL'::`1'::dtor$2
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$2@?0???0_SYMBOL@@QEAA@HAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `_SYMBOL::_SYMBOL'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1348 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1349 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1344 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1345 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Take_contents, COMDAT

; 384  :     void _Take_contents(_Vector_val& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 385  :         this->_Swap_proxy_and_iterators(_Right);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators

; 386  :         _Myfirst = _Right._Myfirst;

  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Right$[rsp]
  00027	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 387  :         _Mylast  = _Right._Mylast;

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Right$[rsp]
  00037	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 388  :         _Myend   = _Right._Myend;

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00044	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Right$[rsp]
  00049	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0004d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 389  : 
; 390  :         _Right._Myfirst = pointer();

  00051	48 8b 44 24 38	 mov	 rax, QWORD PTR _Right$[rsp]
  00056	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 391  :         _Right._Mylast  = pointer();

  0005d	48 8b 44 24 38	 mov	 rax, QWORD PTR _Right$[rsp]
  00062	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 392  :         _Right._Myend   = pointer();

  0006a	48 8b 44 24 38	 mov	 rax, QWORD PTR _Right$[rsp]
  0006f	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 393  :     }

  00077	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007b	c3		 ret	 0
?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0002b	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00030	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal, COMDAT

; 1735 :     const _Alty& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1736 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first

; 1737 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal, COMDAT

; 1731 :     _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1732 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first

; 1733 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range, COMDAT

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000f	c3		 ret	 0
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1704 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Mylast$ = 48
_Myend$ = 56
tv88 = 64
tv86 = 72
tv90 = 80
this$ = 112
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT

; 1685 :     void _Tidy() noexcept { // free all storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00022	48 83 c0 08	 add	 rax, 8
  00026	48 89 44 24 30	 mov	 QWORD PTR _Mylast$[rsp], rax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  0002b	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00030	48 83 c0 10	 add	 rax, 16
  00034	48 89 44 24 38	 mov	 QWORD PTR _Myend$[rsp], rax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00039	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0003e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00048	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004c	0f 84 8a 00 00
	00		 je	 $LN2@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00057	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0005f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00071	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00076	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00085	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 2b c1	 sub	 rax, rcx
  0008e	48 c1 f8 05	 sar	 rax, 5
  00092	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0009c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009f	48 89 44 24 48	 mov	 QWORD PTR tv86[rsp], rax
  000a4	4c 8b 44 24 40	 mov	 r8, QWORD PTR tv88[rsp]
  000a9	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv86[rsp]
  000ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv90[rsp]
  000b3	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000bd	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1698 :             _Mylast  = pointer();

  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  000c9	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1699 :             _Myend   = pointer();

  000d0	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  000d5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@Tidy:

; 1700 :         }
; 1701 :     }

  000dc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e0	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Mylast$ = 48
_Myend$ = 56
tv88 = 64
tv86 = 72
tv90 = 80
this$ = 112
_Newvec$ = 120
_Newsize$ = 128
_Newcapacity$ = 136
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array, COMDAT

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00027	48 89 44 24 20	 mov	 QWORD PTR _Myfirst$[rsp], rax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  0002c	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00031	48 83 c0 08	 add	 rax, 8
  00035	48 89 44 24 30	 mov	 QWORD PTR _Mylast$[rsp], rax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  0003a	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003f	48 83 c0 10	 add	 rax, 16
  00043	48 89 44 24 38	 mov	 QWORD PTR _Myend$[rsp], rax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0004d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  00057	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0005b	74 66		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR _Mylast$[rsp]
  00062	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  0006a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0006d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00072	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00077	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00081	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR _Myend$[rsp]
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Myfirst$[rsp]
  00090	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00093	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00096	48 2b c1	 sub	 rax, rcx
  00099	48 c1 f8 05	 sar	 rax, 5
  0009d	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
  000a2	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000aa	48 89 44 24 48	 mov	 QWORD PTR tv86[rsp], rax
  000af	4c 8b 44 24 40	 mov	 r8, QWORD PTR tv88[rsp]
  000b4	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv86[rsp]
  000b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv90[rsp]
  000be	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  000c3	48 8b 44 24 20	 mov	 rax, QWORD PTR _Myfirst$[rsp]
  000c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  000cd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  000d0	48 6b 84 24 80
	00 00 00 20	 imul	 rax, QWORD PTR _Newsize$[rsp], 32 ; 00000020H
  000d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Mylast$[rsp]
  000e9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  000ec	48 6b 84 24 88
	00 00 00 20	 imul	 rax, QWORD PTR _Newcapacity$[rsp], 32 ; 00000020H
  000f5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Newvec$[rsp]
  000fa	48 03 c8	 add	 rcx, rax
  000fd	48 8b c1	 mov	 rax, rcx
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Myend$[rsp]
  00105	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1683 :     }

  00108	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0010c	c3		 ret	 0
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Geometric$ = 40
tv67 = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth, COMDAT

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
  00018	48 89 44 24 20	 mov	 QWORD PTR _Oldcapacity$[rsp], rax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00022	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  00027	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
  0002c	33 d2		 xor	 edx, edx
  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Oldcapacity$[rsp]
  00033	b9 02 00 00 00	 mov	 ecx, 2
  00038	48 f7 f1	 div	 rcx
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv67[rsp]
  00040	48 2b c8	 sub	 rcx, rax
  00043	48 8b c1	 mov	 rax, rcx
  00046	48 39 44 24 20	 cmp	 QWORD PTR _Oldcapacity$[rsp], rax
  0004b	76 07		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00052	eb 37		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00054	33 d2		 xor	 edx, edx
  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR _Oldcapacity$[rsp]
  0005b	b9 02 00 00 00	 mov	 ecx, 2
  00060	48 f7 f1	 div	 rcx
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Oldcapacity$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	48 89 44 24 28	 mov	 QWORD PTR _Geometric$[rsp], rax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00078	48 39 44 24 28	 cmp	 QWORD PTR _Geometric$[rsp], rax
  0007d	73 07		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00084	eb 05		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 1630 :     }

  0008b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008f	c3		 ret	 0
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  0001d	4c 8b c0	 mov	 r8, rax
  00020	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  00025	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  0002a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1613 :     }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_First$ = 88
_Last$ = 96
_Dest$ = 104
?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept, COMDAT

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00019	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  0001e	48 8b f8	 mov	 rdi, rax
  00021	33 c0		 xor	 eax, eax
  00023	b9 01 00 00 00	 mov	 ecx, 1
  00028	f3 aa		 rep stosb
  0002a	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T1[rsp]
  0002f	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00033	4c 8b 4c 24 68	 mov	 r9, QWORD PTR _Dest$[rsp]
  00038	4c 8b 44 24 60	 mov	 r8, QWORD PTR _Last$[rsp]
  0003d	48 8b 54 24 58	 mov	 rdx, QWORD PTR _First$[rsp]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00047	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0004c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
__formal$ = 80
?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1, COMDAT

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00022	4c 8b c8	 mov	 r9, rax
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Dest$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  00034	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1598 :     }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove, COMDAT

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00022	4c 8b c8	 mov	 r9, rax
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Dest$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Last$[rsp]
  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _First$[rsp]
  00034	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1593 :     }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PEAV32@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
_Pos$ = 40
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT

; 1497 :     _NODISCARD _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR _My_data$[rsp], rax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00017	48 6b 44 24 28
	20		 imul	 rax, QWORD PTR _Pos$[rsp], 32 ; 00000020H
  0001d	48 8b 0c 24	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00021	48 03 01	 add	 rax, QWORD PTR [rcx]

; 1505 :     }

  00024	48 83 c4 18	 add	 rsp, 24
  00028	c3		 ret	 0
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT

; 1492 :     _NODISCARD size_type capacity() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR _My_data$[rsp], rax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	48 8b 04 24	 mov	 rax, QWORD PTR _My_data$[rsp]
  00016	48 8b 0c 24	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0001a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00021	48 2b c1	 sub	 rax, rcx
  00024	48 c1 f8 05	 sar	 rax, 5

; 1495 :     }

  00028	48 83 c4 18	 add	 rsp, 24
  0002c	c3		 ret	 0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT

; 1487 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1488 :         return (_STD min)(

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBAAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  0001b	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00025	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0002a	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0002f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  00034	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT

; 1482 :     _NODISCARD size_type size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR _My_data$[rsp], rax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	48 8b 04 24	 mov	 rax, QWORD PTR _My_data$[rsp]
  00016	48 8b 0c 24	 mov	 rcx, QWORD PTR _My_data$[rsp]
  0001a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00021	48 2b c1	 sub	 rax, rcx
  00024	48 c1 f8 05	 sar	 rax, 5

; 1485 :     }

  00028	48 83 c4 18	 add	 rsp, 24
  0002c	c3		 ret	 0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT

; 716  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 717  :         emplace_back(_Val);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Val$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??$emplace_back@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>

; 718  :     }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 672  :     ~vector() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 673  :         _Tidy();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator=, COMDAT

; 664  :     vector& operator=(vector&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 665  :         if (this != _STD addressof(_Right)) {

  0000f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Right$[rsp]
  00014	e8 00 00 00 00	 call	 ??$addressof@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AEAV10@@Z ; std::addressof<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
  00019	48 39 44 24 40	 cmp	 QWORD PTR this$[rsp], rax
  0001e	74 26		 je	 SHORT $LN2@operator

; 666  :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00020	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00025	48 8b f8	 mov	 rdi, rax
  00028	33 c0		 xor	 eax, eax
  0002a	b9 01 00 00 00	 mov	 ecx, 1
  0002f	f3 aa		 rep stosb
  00031	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR $T1[rsp]
  00037	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Right$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00041	e8 00 00 00 00	 call	 ?_Move_assign@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_assign
$LN2@operator:

; 667  :         }
; 668  : 
; 669  :         return *this;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]

; 670  :     }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Move_assign@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
tv74 = 32
tv72 = 40
tv82 = 48
this$ = 80
_Right$ = 88
__formal$ = 96
?_Move_assign@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_assign, COMDAT

; 595  :     void _Move_assign(vector& _Right, _Equal_allocators) noexcept {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 596  :         _Tidy();

  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 597  :         _Pocma(_Getal(), _Right._Getal());

  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Right$[rsp]
  00022	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00027	48 89 44 24 20	 mov	 QWORD PTR tv74[rsp], rax
  0002c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00031	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00036	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  0003b	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv74[rsp]
  00040	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv72[rsp]
  00045	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@0@Z ; std::_Pocma<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 598  :         _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);

  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004f	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  00054	48 8b 44 24 58	 mov	 rax, QWORD PTR _Right$[rsp]
  00059	48 8b d0	 mov	 rdx, rax
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv82[rsp]
  00061	e8 00 00 00 00	 call	 ?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Take_contents

; 599  :     }

  00066	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006a	c3		 ret	 0
?_Move_assign@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
tv75 = 40
tv77 = 48
tv86 = 56
this$ = 80
_Right$ = 88
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 581  :     vector(vector&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 89 44 24 30	 mov	 QWORD PTR tv77[rsp], rax
  00019	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Right$[rsp]
  0001e	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 ??$move@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
  0002b	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  00030	0f b6 44 24 22	 movzx	 eax, BYTE PTR $T3[rsp]
  00035	88 44 24 20	 mov	 BYTE PTR $T1[rsp], al
  00039	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv75[rsp]
  0003e	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv77[rsp]
  00048	e8 00 00 00 00	 call	 ??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 582  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00052	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
  00057	48 8d 54 24 23	 lea	 rdx, QWORD PTR $T4[rsp]
  0005c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv86[rsp]
  00061	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 583  :         _Move_construct(_Right, true_type{});

  00066	48 8d 44 24 21	 lea	 rax, QWORD PTR $T2[rsp]
  0006b	48 8b f8	 mov	 rdi, rax
  0006e	33 c0		 xor	 eax, eax
  00070	b9 01 00 00 00	 mov	 ecx, 1
  00075	f3 aa		 rep stosb
  00077	44 0f b6 44 24
	21		 movzx	 r8d, BYTE PTR $T2[rsp]
  0007d	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Right$[rsp]
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00087	e8 00 00 00 00	 call	 ?_Move_construct@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_construct

; 584  :     }

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00091	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Move_construct@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
tv71 = 32
this$ = 64
_Right$ = 72
__formal$ = 80
?_Move_construct@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_construct, COMDAT

; 556  :     void _Move_construct(vector& _Right, true_type) noexcept { // move from _Right, stealing its contents

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 557  :         _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR tv71[rsp], rax
  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR _Right$[rsp]
  00022	48 8b d0	 mov	 rdx, rax
  00025	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv71[rsp]
  0002a	e8 00 00 00 00	 call	 ?_Take_contents@?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Take_contents

; 558  :     }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
?_Move_construct@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_construct
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00013	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  0001d	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  0002c	48 8d 54 24 21	 lea	 rdx, QWORD PTR $T2[rsp]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv78[rsp]
  00036	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00040	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00044	c3		 ret	 0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00005	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH

; 704  :     }

  0000f	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Count$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z ; std::_Get_size_of_n<32>
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 808  :     }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR _Count$[rsp], 32 ; 00000020H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00021	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 804  :     }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 795  :     constexpr allocator() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachineAssembler.h
;	COMDAT ?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
CurPos$ = 32
$T1 = 40
PrevPos$ = 48
Values$ = 56
token$2 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
Str$ = 152
Sep$ = 160
?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; SplitString, COMDAT

; 13   : {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00025	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 14   : 	std::vector<std::string> Values;

  0002d	ba 18 00 00 00	 mov	 edx, 24
  00032	48 8d 4c 24 38	 lea	 rcx, QWORD PTR Values$[rsp]
  00037	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
  0003c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR Values$[rsp]
  00041	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00046	90		 npad	 1

; 15   : 	size_t PrevPos = 0, CurPos = 0;

  00047	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR PrevPos$[rsp], 0
  00050	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR CurPos$[rsp], 0
$LN4@SplitStrin:

; 16   : 	do
; 17   : 	{
; 18   : 		CurPos = Str.find(Sep, PrevPos);

  00059	4c 8b 44 24 30	 mov	 r8, QWORD PTR PrevPos$[rsp]
  0005e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR Sep$[rsp]
  00066	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Str$[rsp]
  0006e	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00073	48 89 44 24 20	 mov	 QWORD PTR CurPos$[rsp], rax

; 19   : 		if (CurPos == std::string::npos) CurPos = Str.length();

  00078	48 83 7c 24 20
	ff		 cmp	 QWORD PTR CurPos$[rsp], -1
  0007e	75 12		 jne	 SHORT $LN5@SplitStrin
  00080	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Str$[rsp]
  00088	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  0008d	48 89 44 24 20	 mov	 QWORD PTR CurPos$[rsp], rax
$LN5@SplitStrin:

; 20   : 		std::string token = Str.substr(PrevPos, CurPos - PrevPos);

  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR PrevPos$[rsp]
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR CurPos$[rsp]
  0009c	48 2b c8	 sub	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx
  000a2	4c 8b c8	 mov	 r9, rax
  000a5	4c 8b 44 24 30	 mov	 r8, QWORD PTR PrevPos$[rsp]
  000aa	48 8d 54 24 50	 lea	 rdx, QWORD PTR token$2[rsp]
  000af	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Str$[rsp]
  000b7	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  000bc	90		 npad	 1

; 21   : 		if (!token.empty()) Values.push_back(token);

  000bd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR token$2[rsp]
  000c2	e8 00 00 00 00	 call	 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
  000c7	0f b6 c0	 movzx	 eax, al
  000ca	85 c0		 test	 eax, eax
  000cc	75 0f		 jne	 SHORT $LN6@SplitStrin
  000ce	48 8d 54 24 50	 lea	 rdx, QWORD PTR token$2[rsp]
  000d3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR Values$[rsp]
  000d8	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
$LN6@SplitStrin:

; 22   : 		PrevPos = CurPos + Sep.length();

  000dd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Sep$[rsp]
  000e5	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  000ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR CurPos$[rsp]
  000ef	48 03 c8	 add	 rcx, rax
  000f2	48 8b c1	 mov	 rax, rcx
  000f5	48 89 44 24 30	 mov	 QWORD PTR PrevPos$[rsp], rax

; 23   : 	} while (CurPos < Str.length() && PrevPos < Str.length());

  000fa	48 8d 4c 24 50	 lea	 rcx, QWORD PTR token$2[rsp]
  000ff	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00104	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Str$[rsp]
  0010c	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00111	48 39 44 24 20	 cmp	 QWORD PTR CurPos$[rsp], rax
  00116	73 18		 jae	 SHORT $LN7@SplitStrin
  00118	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR Str$[rsp]
  00120	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00125	48 39 44 24 30	 cmp	 QWORD PTR PrevPos$[rsp], rax
  0012a	0f 82 29 ff ff
	ff		 jb	 $LN4@SplitStrin
$LN7@SplitStrin:

; 24   : 	return Values;

  00130	48 8d 54 24 38	 lea	 rdx, QWORD PTR Values$[rsp]
  00135	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0013d	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00142	8b 44 24 28	 mov	 eax, DWORD PTR $T1[rsp]
  00146	83 c8 01	 or	 eax, 1
  00149	89 44 24 28	 mov	 DWORD PTR $T1[rsp], eax
  0014d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR Values$[rsp]
  00152	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00157	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 25   : }

  0015f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00164	48 33 cc	 xor	 rcx, rsp
  00167	e8 00 00 00 00	 call	 __security_check_cookie
  0016c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00173	c3		 ret	 0
?SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; SplitString
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
CurPos$ = 32
$T1 = 40
PrevPos$ = 48
Values$ = 56
token$2 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
Str$ = 152
Sep$ = 160
?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA PROC ; `SplitString'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR Values$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA ENDP ; `SplitString'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
CurPos$ = 32
$T1 = 40
PrevPos$ = 48
Values$ = 56
token$2 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
Str$ = 152
Sep$ = 160
?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA PROC ; `SplitString'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 50	 lea	 rcx, QWORD PTR token$2[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA ENDP ; `SplitString'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
CurPos$ = 32
$T1 = 40
PrevPos$ = 48
Values$ = 56
token$2 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
Str$ = 152
Sep$ = 160
?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA PROC ; `SplitString'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR Values$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA ENDP ; `SplitString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
CurPos$ = 32
$T1 = 40
PrevPos$ = 48
Values$ = 56
token$2 = 80
__$ArrayPad$ = 112
__$ReturnUdt$ = 144
Str$ = 152
Sep$ = 160
?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA PROC ; `SplitString'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 50	 lea	 rcx, QWORD PTR token$2[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$1@?0??SplitString@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z@4HA ENDP ; `SplitString'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z
_TEXT	SEGMENT
tv85 = 32
tv93 = 40
$T1 = 48
this$ = 128
__formal$ = 136
_Lobj$ = 144
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT

; 176  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 177  :         _Cvt = _Lobj._Getcvt();

  00015	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  0001a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00030	48 8d 79 2c	 lea	 rdi, QWORD PTR [rcx+44]
  00034	48 8b f0	 mov	 rsi, rax
  00037	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0003c	f3 a4		 rep movsb

; 178  : 
; 179  :         if (is_same_v<_Elem2, wchar_t>) {

  0003e	33 c0		 xor	 eax, eax
  00040	83 f8 01	 cmp	 eax, 1
  00043	74 61		 je	 SHORT $LN2@Getvals

; 180  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPEA_WPEB_W@Z ; std::_Maklocwcs
  0005b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00063	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 181  :             _Months =

  00067	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ
  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPEA_WPEB_W@Z ; std::_Maklocwcs
  0007d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00085	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 182  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 183  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00090	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPEA_WPEB_W@Z ; std::_Maklocwcs
  00095	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0009d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 184  :         } else {

  000a1	e9 a3 00 00 00	 jmp	 $LN3@Getvals
$LN2@Getvals:

; 185  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  000a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ae	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  000b2	48 89 44 24 20	 mov	 QWORD PTR tv85[rsp], rax
  000b7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv85[rsp]
  000ca	4c 8b c1	 mov	 r8, rcx
  000cd	33 d2		 xor	 edx, edx
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000df	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 186  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  000e3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000eb	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  000ef	48 89 44 24 28	 mov	 QWORD PTR tv93[rsp], rax
  000f4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ
  00102	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv93[rsp]
  00107	4c 8b c1	 mov	 r8, rcx
  0010a	33 d2		 xor	 edx, edx
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00114	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0011c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 187  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00120	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00128	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0012c	4c 8b c0	 mov	 r8, rax
  0012f	33 d2		 xor	 edx, edx
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  00138	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  0013d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00145	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN3@Getvals:

; 188  :         }
; 189  :     }

  00149	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0014d	5f		 pop	 rdi
  0014e	5e		 pop	 rsi
  0014f	c3		 ret	 0
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z
_TEXT	SEGMENT
tv85 = 32
tv93 = 40
$T1 = 48
this$ = 128
__formal$ = 136
_Lobj$ = 144
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT

; 176  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 177  :         _Cvt = _Lobj._Getcvt();

  00015	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  0001a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00030	48 8d 79 2c	 lea	 rdi, QWORD PTR [rcx+44]
  00034	48 8b f0	 mov	 rsi, rax
  00037	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0003c	f3 a4		 rep movsb

; 178  : 
; 179  :         if (is_same_v<_Elem2, wchar_t>) {

  0003e	33 c0		 xor	 eax, eax
  00040	83 f8 01	 cmp	 eax, 1
  00043	74 61		 je	 SHORT $LN2@Getvals

; 180  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPEA_WPEB_W@Z ; std::_Maklocwcs
  0005b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00063	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 181  :             _Months =

  00067	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ
  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPEA_WPEB_W@Z ; std::_Maklocwcs
  0007d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00085	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 182  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 183  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00090	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPEA_WPEB_W@Z ; std::_Maklocwcs
  00095	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0009d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 184  :         } else {

  000a1	e9 a3 00 00 00	 jmp	 $LN3@Getvals
$LN2@Getvals:

; 185  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  000a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ae	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  000b2	48 89 44 24 20	 mov	 QWORD PTR tv85[rsp], rax
  000b7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv85[rsp]
  000ca	4c 8b c1	 mov	 r8, rcx
  000cd	33 d2		 xor	 edx, edx
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000df	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 186  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  000e3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000eb	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  000ef	48 89 44 24 28	 mov	 QWORD PTR tv93[rsp], rax
  000f4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Lobj$[rsp]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ
  00102	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv93[rsp]
  00107	4c 8b c1	 mov	 r8, rcx
  0010a	33 d2		 xor	 edx, edx
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
  00114	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0011c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 187  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00120	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00128	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0012c	4c 8b c0	 mov	 r8, rax
  0012f	33 d2		 xor	 edx, edx
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  00138	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
  0013d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00145	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN3@Getvals:

; 188  :         }
; 189  :     }

  00149	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0014d	5f		 pop	 rdi
  0014e	5e		 pop	 rsi
  0014f	c3		 ret	 0
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAX_WAEBV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
_TEXT	SEGMENT
tv69 = 32
_Byte$ = 64
_File$ = 72
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 129  : inline bool _Ungetc(const char& _Byte, FILE* _File) { // put back a char element to a C stream

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 130  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR _Byte$[rsp]
  00013	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00016	48 8b 54 24 48	 mov	 rdx, QWORD PTR _File$[rsp]
  0001b	8b c8		 mov	 ecx, eax
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  00023	83 f8 ff	 cmp	 eax, -1
  00026	74 0a		 je	 SHORT $LN3@Ungetc
  00028	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  00030	eb 08		 jmp	 SHORT $LN4@Ungetc
$LN3@Ungetc:
  00032	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN4@Ungetc:
  0003a	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv69[rsp]

; 131  : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
_TEXT	SEGMENT
tv69 = 32
_Byte$ = 64
_File$ = 72
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 106  : inline bool _Fputc(char _Byte, FILE* _File) { // put a char element to a C stream

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  0000d	0f be 44 24 40	 movsx	 eax, BYTE PTR _Byte$[rsp]
  00012	48 8b 54 24 48	 mov	 rdx, QWORD PTR _File$[rsp]
  00017	8b c8		 mov	 ecx, eax
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	74 0a		 je	 SHORT $LN3@Fputc
  00024	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  0002c	eb 08		 jmp	 SHORT $LN4@Fputc
$LN3@Fputc:
  0002e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN4@Fputc:
  00036	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv69[rsp]

; 108  : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Meta$ = 32
_Byte$ = 64
_File$ = 72
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 65   : inline bool _Fgetc(char& _Byte, FILE* _File) { // get a char element from a C stream

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 66   :     int _Meta;
; 67   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _File$[rsp]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  00019	89 44 24 20	 mov	 DWORD PTR _Meta$[rsp], eax
  0001d	83 7c 24 20 ff	 cmp	 DWORD PTR _Meta$[rsp], -1
  00022	75 06		 jne	 SHORT $LN2@Fgetc

; 68   :         return false;

  00024	32 c0		 xor	 al, al
  00026	eb 10		 jmp	 SHORT $LN1@Fgetc

; 69   :     } else { // got one, convert to char

  00028	eb 0e		 jmp	 SHORT $LN3@Fgetc
$LN2@Fgetc:

; 70   :         _Byte = static_cast<char>(_Meta);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR _Byte$[rsp]
  0002f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR _Meta$[rsp]
  00034	88 08		 mov	 BYTE PTR [rax], cl

; 71   :         return true;

  00036	b0 01		 mov	 al, 1
$LN3@Fgetc:
$LN1@Fgetc:

; 72   :     }
; 73   : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z
_TEXT	SEGMENT
_RNext$ = 32
$T1 = 40
$T2 = 44
_UVal$ = 48
_Buff_end$ = 56
_Buff$ = 64
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
_Val$ = 120
??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z PROC ; std::_Integral_to_string<char,__int64>, COMDAT

; 485  : basic_string<_Elem> _Integral_to_string(const _Ty _Val) { // convert _Val to string

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T2[rsp], 0

; 486  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 487  :     using _UTy = make_unsigned_t<_Ty>;
; 488  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 489  :     _Elem* const _Buff_end = _STD end(_Buff);

  00025	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Buff$[rsp]
  0002a	e8 00 00 00 00	 call	 ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ; std::end<char,21>
  0002f	48 89 44 24 38	 mov	 QWORD PTR _Buff_end$[rsp], rax

; 490  :     _Elem* _RNext          = _Buff_end;

  00034	48 8b 44 24 38	 mov	 rax, QWORD PTR _Buff_end$[rsp]
  00039	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax

; 491  :     const auto _UVal       = static_cast<_UTy>(_Val);

  0003e	48 8b 44 24 78	 mov	 rax, QWORD PTR _Val$[rsp]
  00043	48 89 44 24 30	 mov	 QWORD PTR _UVal$[rsp], rax

; 492  :     if (_Val < 0) {

  00048	48 83 7c 24 78
	00		 cmp	 QWORD PTR _Val$[rsp], 0
  0004e	7d 30		 jge	 SHORT $LN2@Integral_t

; 493  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);

  00050	33 c0		 xor	 eax, eax
  00052	48 2b 44 24 30	 sub	 rax, QWORD PTR _UVal$[rsp]
  00057	48 8b d0	 mov	 rdx, rax
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _RNext$[rsp]
  0005f	e8 00 00 00 00	 call	 ??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z ; std::_UIntegral_to_buff<char,unsigned __int64>
  00064	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax

; 494  :         *--_RNext = '-';

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR _RNext$[rsp]
  0006e	48 ff c8	 dec	 rax
  00071	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax
  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR _RNext$[rsp]
  0007b	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH

; 495  :     } else {

  0007e	eb 14		 jmp	 SHORT $LN3@Integral_t
$LN2@Integral_t:

; 496  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

  00080	48 8b 54 24 30	 mov	 rdx, QWORD PTR _UVal$[rsp]
  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _RNext$[rsp]
  0008a	e8 00 00 00 00	 call	 ??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z ; std::_UIntegral_to_buff<char,unsigned __int64>
  0008f	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax
$LN3@Integral_t:

; 497  :     }
; 498  : 
; 499  :     return basic_string<_Elem>(_RNext, _Buff_end);

  00094	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  00099	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  0009e	4c 8b c8	 mov	 r9, rax
  000a1	4c 8b 44 24 38	 mov	 r8, QWORD PTR _Buff_end$[rsp]
  000a6	48 8b 54 24 20	 mov	 rdx, QWORD PTR _RNext$[rsp]
  000ab	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000b0	e8 00 00 00 00	 call	 ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
  000b5	8b 44 24 2c	 mov	 eax, DWORD PTR $T2[rsp]
  000b9	83 c8 01	 or	 eax, 1
  000bc	89 44 24 2c	 mov	 DWORD PTR $T2[rsp], eax
  000c0	48 8b 44 24 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 500  : }

  000c5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ca	48 33 cc	 xor	 rcx, rsp
  000cd	e8 00 00 00 00	 call	 __security_check_cookie
  000d2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000d6	c3		 ret	 0
??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z ENDP ; std::_Integral_to_string<char,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Val$ = 72
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z PROC ; std::to_string, COMDAT

; 530  : _NODISCARD inline string to_string(long long _Val) { // convert long long to string

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 531  :     return _Integral_to_string<char>(_Val);

  00016	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Val$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00020	e8 00 00 00 00	 call	 ??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z ; std::_Integral_to_string<char,__int64>
  00025	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00029	83 c8 01	 or	 eax, 1
  0002c	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 532  : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
_TEXT	SEGMENT
_RNext$ = 32
$T1 = 40
_UVal$ = 44
$T2 = 48
_Buff_end$ = 56
_Buff$ = 64
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
_Val$ = 120
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z PROC ; std::_Integral_to_string<char,int>, COMDAT

; 485  : basic_string<_Elem> _Integral_to_string(const _Ty _Val) { // convert _Val to string

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T2[rsp], 0

; 486  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 487  :     using _UTy = make_unsigned_t<_Ty>;
; 488  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 489  :     _Elem* const _Buff_end = _STD end(_Buff);

  00024	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Buff$[rsp]
  00029	e8 00 00 00 00	 call	 ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ; std::end<char,21>
  0002e	48 89 44 24 38	 mov	 QWORD PTR _Buff_end$[rsp], rax

; 490  :     _Elem* _RNext          = _Buff_end;

  00033	48 8b 44 24 38	 mov	 rax, QWORD PTR _Buff_end$[rsp]
  00038	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax

; 491  :     const auto _UVal       = static_cast<_UTy>(_Val);

  0003d	8b 44 24 78	 mov	 eax, DWORD PTR _Val$[rsp]
  00041	89 44 24 2c	 mov	 DWORD PTR _UVal$[rsp], eax

; 492  :     if (_Val < 0) {

  00045	83 7c 24 78 00	 cmp	 DWORD PTR _Val$[rsp], 0
  0004a	7d 2e		 jge	 SHORT $LN2@Integral_t

; 493  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);

  0004c	33 c0		 xor	 eax, eax
  0004e	2b 44 24 2c	 sub	 eax, DWORD PTR _UVal$[rsp]
  00052	8b d0		 mov	 edx, eax
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _RNext$[rsp]
  00059	e8 00 00 00 00	 call	 ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
  0005e	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax

; 494  :         *--_RNext = '-';

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR _RNext$[rsp]
  00068	48 ff c8	 dec	 rax
  0006b	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax
  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR _RNext$[rsp]
  00075	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH

; 495  :     } else {

  00078	eb 13		 jmp	 SHORT $LN3@Integral_t
$LN2@Integral_t:

; 496  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

  0007a	8b 54 24 2c	 mov	 edx, DWORD PTR _UVal$[rsp]
  0007e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _RNext$[rsp]
  00083	e8 00 00 00 00	 call	 ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
  00088	48 89 44 24 20	 mov	 QWORD PTR _RNext$[rsp], rax
$LN3@Integral_t:

; 497  :     }
; 498  : 
; 499  :     return basic_string<_Elem>(_RNext, _Buff_end);

  0008d	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  00092	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00097	4c 8b c8	 mov	 r9, rax
  0009a	4c 8b 44 24 38	 mov	 r8, QWORD PTR _Buff_end$[rsp]
  0009f	48 8b 54 24 20	 mov	 rdx, QWORD PTR _RNext$[rsp]
  000a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000a9	e8 00 00 00 00	 call	 ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
  000ae	8b 44 24 30	 mov	 eax, DWORD PTR $T2[rsp]
  000b2	83 c8 01	 or	 eax, 1
  000b5	89 44 24 30	 mov	 DWORD PTR $T2[rsp], eax
  000b9	48 8b 44 24 70	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 500  : }

  000be	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c3	48 33 cc	 xor	 rcx, rsp
  000c6	e8 00 00 00 00	 call	 __security_check_cookie
  000cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000cf	c3		 ret	 0
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ENDP ; std::_Integral_to_string<char,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Val$ = 72
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::to_string, COMDAT

; 514  : _NODISCARD inline string to_string(int _Val) { // convert int to string

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 515  :     return _Integral_to_string<char>(_Val);

  00015	8b 54 24 48	 mov	 edx, DWORD PTR _Val$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0001e	e8 00 00 00 00	 call	 ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
  00023	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00027	83 c8 01	 or	 eax, 1
  0002a	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 516  : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	c3		 ret	 0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ?stoll@std@@YA_JAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z
_TEXT	SEGMENT
_Ptr$ = 32
_Errno_ref$ = 40
_Ans$ = 48
_Eptr$ = 56
__$ArrayPad$ = 64
_Str$ = 96
_Idx$ = 104
_Base$ = 112
?stoll@std@@YA_JAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z PROC ; std::stoll, COMDAT

; 158  : inline long long stoll(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 159  :     // convert string to long long
; 160  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00028	48 89 44 24 28	 mov	 QWORD PTR _Errno_ref$[rsp], rax

; 161  :     const char* _Ptr = _Str.c_str();

  0002d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Str$[rsp]
  00032	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00037	48 89 44 24 20	 mov	 QWORD PTR _Ptr$[rsp], rax

; 162  :     char* _Eptr;
; 163  :     _Errno_ref           = 0;

  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR _Errno_ref$[rsp]
  00041	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 164  :     const long long _Ans = _CSTD strtoll(_Ptr, &_Eptr, _Base);

  00047	44 8b 44 24 70	 mov	 r8d, DWORD PTR _Base$[rsp]
  0004c	48 8d 54 24 38	 lea	 rdx, QWORD PTR _Eptr$[rsp]
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoll
  0005c	48 89 44 24 30	 mov	 QWORD PTR _Ans$[rsp], rax

; 165  : 
; 166  :     if (_Ptr == _Eptr) {

  00061	48 8b 44 24 38	 mov	 rax, QWORD PTR _Eptr$[rsp]
  00066	48 39 44 24 20	 cmp	 QWORD PTR _Ptr$[rsp], rax
  0006b	75 0c		 jne	 SHORT $LN2@stoll

; 167  :         _Xinvalid_argument("invalid stoll argument");

  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@KOGMOJCH@invalid?5stoll?5argument@
  00074	e8 00 00 00 00	 call	 ?_Xinvalid_argument@std@@YAXPEBD@Z ; std::_Xinvalid_argument
$LN2@stoll:

; 168  :     }
; 169  : 
; 170  :     if (_Errno_ref == ERANGE) {

  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR _Errno_ref$[rsp]
  0007e	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  00081	75 0c		 jne	 SHORT $LN3@stoll

; 171  :         _Xout_of_range("stoll argument out of range");

  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@BPCBEBLO@stoll?5argument?5out?5of?5range@
  0008a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
$LN3@stoll:

; 172  :     }
; 173  : 
; 174  :     if (_Idx) {

  0008f	48 83 7c 24 68
	00		 cmp	 QWORD PTR _Idx$[rsp], 0
  00095	74 18		 je	 SHORT $LN4@stoll

; 175  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);

  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR _Ptr$[rsp]
  0009c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Eptr$[rsp]
  000a1	48 2b c8	 sub	 rcx, rax
  000a4	48 8b c1	 mov	 rax, rcx
  000a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Idx$[rsp]
  000ac	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN4@stoll:

; 176  :     }
; 177  : 
; 178  :     return _Ans;

  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ans$[rsp]
$LN5@stoll:

; 179  : }

  000b4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b9	48 33 cc	 xor	 rcx, rsp
  000bc	e8 00 00 00 00	 call	 __security_check_cookie
  000c1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c5	c3		 ret	 0
?stoll@std@@YA_JAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ENDP ; std::stoll
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\string
;	COMDAT ?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z
_TEXT	SEGMENT
_Ans$ = 32
_Ptr$ = 40
_Errno_ref$ = 48
_Eptr$ = 56
__$ArrayPad$ = 64
_Str$ = 96
_Idx$ = 104
_Base$ = 112
?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z PROC ; std::stoi, COMDAT

; 89   : inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 90   :     // convert string to int
; 91   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00028	48 89 44 24 30	 mov	 QWORD PTR _Errno_ref$[rsp], rax

; 92   :     const char* _Ptr = _Str.c_str();

  0002d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Str$[rsp]
  00032	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00037	48 89 44 24 28	 mov	 QWORD PTR _Ptr$[rsp], rax

; 93   :     char* _Eptr;
; 94   :     _Errno_ref      = 0;

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR _Errno_ref$[rsp]
  00041	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 95   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

  00047	44 8b 44 24 70	 mov	 r8d, DWORD PTR _Base$[rsp]
  0004c	48 8d 54 24 38	 lea	 rdx, QWORD PTR _Eptr$[rsp]
  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  0005c	89 44 24 20	 mov	 DWORD PTR _Ans$[rsp], eax

; 96   : 
; 97   :     if (_Ptr == _Eptr) {

  00060	48 8b 44 24 38	 mov	 rax, QWORD PTR _Eptr$[rsp]
  00065	48 39 44 24 28	 cmp	 QWORD PTR _Ptr$[rsp], rax
  0006a	75 0c		 jne	 SHORT $LN2@stoi

; 98   :         _Xinvalid_argument("invalid stoi argument");

  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
  00073	e8 00 00 00 00	 call	 ?_Xinvalid_argument@std@@YAXPEBD@Z ; std::_Xinvalid_argument
$LN2@stoi:

; 99   :     }
; 100  : 
; 101  :     if (_Errno_ref == ERANGE || _Ans < INT_MIN || INT_MAX < _Ans) {

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR _Errno_ref$[rsp]
  0007d	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  00080	74 14		 je	 SHORT $LN4@stoi
  00082	81 7c 24 20 00
	00 00 80	 cmp	 DWORD PTR _Ans$[rsp], -2147483648 ; ffffffff80000000H
  0008a	7c 0a		 jl	 SHORT $LN4@stoi
  0008c	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR _Ans$[rsp], 2147483647 ; 7fffffffH
  00094	7e 0c		 jle	 SHORT $LN3@stoi
$LN4@stoi:

; 102  :         _Xout_of_range("stoi argument out of range");

  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
  0009d	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
$LN3@stoi:

; 103  :     }
; 104  : 
; 105  :     if (_Idx) {

  000a2	48 83 7c 24 68
	00		 cmp	 QWORD PTR _Idx$[rsp], 0
  000a8	74 18		 je	 SHORT $LN5@stoi

; 106  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);

  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR _Ptr$[rsp]
  000af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Eptr$[rsp]
  000b4	48 2b c8	 sub	 rcx, rax
  000b7	48 8b c1	 mov	 rax, rcx
  000ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Idx$[rsp]
  000bf	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@stoi:

; 107  :     }
; 108  : 
; 109  :     return static_cast<int>(_Ans);

  000c2	8b 44 24 20	 mov	 eax, DWORD PTR _Ans$[rsp]
$LN6@stoi:

; 110  : }

  000c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000cb	48 33 cc	 xor	 rcx, rsp
  000ce	e8 00 00 00 00	 call	 __security_check_cookie
  000d3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d7	c3		 ret	 0
?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ENDP ; std::stoi
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\$Fanta\VirtualMachine\StackMachine\StackMachine.h
;	COMDAT ?InitHandlerTable@@YAXPEAU_VM_HANDLER_TABLE@@@Z
_TEXT	SEGMENT
Table$ = 8
?InitHandlerTable@@YAXPEAU_VM_HANDLER_TABLE@@@Z PROC	; InitHandlerTable, COMDAT

; 425  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 426  : 	Table->HandlerTable[VMEXIT] = ViVmExit;

  00005	b8 08 00 00 00	 mov	 eax, 8
  0000a	48 6b c0 01	 imul	 rax, rax, 1
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViVmExit
  0001a	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 427  : 	Table->HandlerTable[NOP] = ViNop;

  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 02	 imul	 rax, rax, 2
  00027	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViNop
  00033	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 428  : 
; 429  : 	Table->HandlerTable[LDIB] = ViLdib;

  00037	b8 08 00 00 00	 mov	 eax, 8
  0003c	48 6b c0 03	 imul	 rax, rax, 3
  00040	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdib
  0004c	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 430  : 	Table->HandlerTable[LDIW] = ViLdiw;

  00050	b8 08 00 00 00	 mov	 eax, 8
  00055	48 6b c0 04	 imul	 rax, rax, 4
  00059	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdiw
  00065	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 431  : 	Table->HandlerTable[LDID] = ViLdid;

  00069	b8 08 00 00 00	 mov	 eax, 8
  0006e	48 6b c0 05	 imul	 rax, rax, 5
  00072	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdid
  0007e	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 432  : 	Table->HandlerTable[LDIQ] = ViLdiq;

  00082	b8 08 00 00 00	 mov	 eax, 8
  00087	48 6b c0 06	 imul	 rax, rax, 6
  0008b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdiq
  00097	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 433  : 
; 434  : 	Table->HandlerTable[LDIBSXW] = ViLdibsxw;

  0009b	b8 08 00 00 00	 mov	 eax, 8
  000a0	48 6b c0 07	 imul	 rax, rax, 7
  000a4	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdibsxw
  000b0	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 435  : 	Table->HandlerTable[LDIBSXD] = ViLdibsxd;

  000b4	b8 08 00 00 00	 mov	 eax, 8
  000b9	48 6b c0 08	 imul	 rax, rax, 8
  000bd	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdibsxd
  000c9	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 436  : 	Table->HandlerTable[LDIBSXQ] = ViLdibsxq;

  000cd	b8 08 00 00 00	 mov	 eax, 8
  000d2	48 6b c0 09	 imul	 rax, rax, 9
  000d6	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdibsxq
  000e2	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 437  : 	Table->HandlerTable[LDIWSXD] = ViLdiwsxd;

  000e6	b8 08 00 00 00	 mov	 eax, 8
  000eb	48 6b c0 0a	 imul	 rax, rax, 10
  000ef	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdiwsxd
  000fb	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 438  : 	Table->HandlerTable[LDIWSXQ] = ViLdiwsxq;

  000ff	b8 08 00 00 00	 mov	 eax, 8
  00104	48 6b c0 0b	 imul	 rax, rax, 11
  00108	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdiwsxq
  00114	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 439  : 	Table->HandlerTable[LDIDSXQ] = ViLdidsxq;

  00118	b8 08 00 00 00	 mov	 eax, 8
  0011d	48 6b c0 0c	 imul	 rax, rax, 12
  00121	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdidsxq
  0012d	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 440  : 
; 441  : 	Table->HandlerTable[LDIBZXW] = ViLdibzxw;

  00131	b8 08 00 00 00	 mov	 eax, 8
  00136	48 6b c0 0d	 imul	 rax, rax, 13
  0013a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdibzxw
  00146	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 442  : 	Table->HandlerTable[LDIBZXD] = ViLdibzxd;

  0014a	b8 08 00 00 00	 mov	 eax, 8
  0014f	48 6b c0 0e	 imul	 rax, rax, 14
  00153	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdibzxd
  0015f	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 443  : 	Table->HandlerTable[LDIBZXQ] = ViLdibzxq;

  00163	b8 08 00 00 00	 mov	 eax, 8
  00168	48 6b c0 0f	 imul	 rax, rax, 15
  0016c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdibzxq
  00178	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 444  : 	Table->HandlerTable[LDIWZXD] = ViLdiwzxd;

  0017c	b8 08 00 00 00	 mov	 eax, 8
  00181	48 6b c0 10	 imul	 rax, rax, 16
  00185	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdiwzxd
  00191	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 445  : 	Table->HandlerTable[LDIWZXQ] = ViLdiwzxq;

  00195	b8 08 00 00 00	 mov	 eax, 8
  0019a	48 6b c0 11	 imul	 rax, rax, 17
  0019e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdiwzxq
  001aa	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 446  : 	Table->HandlerTable[LDIDZXQ] = ViLdidzxq;

  001ae	b8 08 00 00 00	 mov	 eax, 8
  001b3	48 6b c0 12	 imul	 rax, rax, 18
  001b7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdidzxq
  001c3	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 447  : 
; 448  : 	Table->HandlerTable[LDAB] = ViLdab;

  001c7	b8 08 00 00 00	 mov	 eax, 8
  001cc	48 6b c0 13	 imul	 rax, rax, 19
  001d0	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdab
  001dc	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 449  : 	Table->HandlerTable[LDAW] = ViLdaw;

  001e0	b8 08 00 00 00	 mov	 eax, 8
  001e5	48 6b c0 14	 imul	 rax, rax, 20
  001e9	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdaw
  001f5	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 450  : 	Table->HandlerTable[LDAD] = ViLdad;

  001f9	b8 08 00 00 00	 mov	 eax, 8
  001fe	48 6b c0 15	 imul	 rax, rax, 21
  00202	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdad
  0020e	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 451  : 	Table->HandlerTable[LDAQ] = ViLdaq;

  00212	b8 08 00 00 00	 mov	 eax, 8
  00217	48 6b c0 16	 imul	 rax, rax, 22
  0021b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdaq
  00227	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 452  : 
; 453  : 	Table->HandlerTable[STAB] = ViStab;

  0022b	b8 08 00 00 00	 mov	 eax, 8
  00230	48 6b c0 17	 imul	 rax, rax, 23
  00234	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00239	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStab
  00240	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 454  : 	Table->HandlerTable[STAW] = ViStaw;

  00244	b8 08 00 00 00	 mov	 eax, 8
  00249	48 6b c0 18	 imul	 rax, rax, 24
  0024d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStaw
  00259	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 455  : 	Table->HandlerTable[STAD] = ViStad;

  0025d	b8 08 00 00 00	 mov	 eax, 8
  00262	48 6b c0 19	 imul	 rax, rax, 25
  00266	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0026b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStad
  00272	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 456  : 	Table->HandlerTable[STAQ] = ViStaq;

  00276	b8 08 00 00 00	 mov	 eax, 8
  0027b	48 6b c0 1a	 imul	 rax, rax, 26
  0027f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStaq
  0028b	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 457  : 
; 458  : 	Table->HandlerTable[SXBW] = ViSxbw;

  0028f	b8 08 00 00 00	 mov	 eax, 8
  00294	48 6b c0 1b	 imul	 rax, rax, 27
  00298	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0029d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSxbw
  002a4	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 459  : 	Table->HandlerTable[SXBD] = ViSxbd;

  002a8	b8 08 00 00 00	 mov	 eax, 8
  002ad	48 6b c0 1c	 imul	 rax, rax, 28
  002b1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  002b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSxbd
  002bd	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 460  : 	Table->HandlerTable[SXBQ] = ViSxbq;

  002c1	b8 08 00 00 00	 mov	 eax, 8
  002c6	48 6b c0 1d	 imul	 rax, rax, 29
  002ca	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  002cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSxbq
  002d6	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 461  : 	Table->HandlerTable[SXWD] = ViSxwd;

  002da	b8 08 00 00 00	 mov	 eax, 8
  002df	48 6b c0 1e	 imul	 rax, rax, 30
  002e3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  002e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSxwd
  002ef	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 462  : 	Table->HandlerTable[SXWQ] = ViSxwq;

  002f3	b8 08 00 00 00	 mov	 eax, 8
  002f8	48 6b c0 1f	 imul	 rax, rax, 31
  002fc	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSxwq
  00308	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 463  : 	Table->HandlerTable[SXDQ] = ViSxdq;

  0030c	b8 08 00 00 00	 mov	 eax, 8
  00311	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00315	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0031a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSxdq
  00321	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 464  : 
; 465  : 	Table->HandlerTable[ZXBW] = ViZxbw;

  00325	b8 08 00 00 00	 mov	 eax, 8
  0032a	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  0032e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00333	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViZxbw
  0033a	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 466  : 	Table->HandlerTable[ZXBD] = ViZxbd;

  0033e	b8 08 00 00 00	 mov	 eax, 8
  00343	48 6b c0 22	 imul	 rax, rax, 34		; 00000022H
  00347	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0034c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViZxbd
  00353	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 467  : 	Table->HandlerTable[ZXBQ] = ViZxbq;

  00357	b8 08 00 00 00	 mov	 eax, 8
  0035c	48 6b c0 23	 imul	 rax, rax, 35		; 00000023H
  00360	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00365	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViZxbq
  0036c	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 468  : 	Table->HandlerTable[ZXWD] = ViZxwd;

  00370	b8 08 00 00 00	 mov	 eax, 8
  00375	48 6b c0 24	 imul	 rax, rax, 36		; 00000024H
  00379	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0037e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViZxwd
  00385	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 469  : 	Table->HandlerTable[ZXWQ] = ViZxwq;

  00389	b8 08 00 00 00	 mov	 eax, 8
  0038e	48 6b c0 25	 imul	 rax, rax, 37		; 00000025H
  00392	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00397	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViZxwq
  0039e	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 470  : 	Table->HandlerTable[ZXDQ] = ViZxdq;

  003a2	b8 08 00 00 00	 mov	 eax, 8
  003a7	48 6b c0 26	 imul	 rax, rax, 38		; 00000026H
  003ab	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  003b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViZxdq
  003b7	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 471  : 
; 472  : 	Table->HandlerTable[PUSHB] = ViPushb;

  003bb	b8 08 00 00 00	 mov	 eax, 8
  003c0	48 6b c0 27	 imul	 rax, rax, 39		; 00000027H
  003c4	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  003c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViPushb
  003d0	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 473  : 	Table->HandlerTable[PUSHW] = ViPushw;

  003d4	b8 08 00 00 00	 mov	 eax, 8
  003d9	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  003dd	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  003e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViPushw
  003e9	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 474  : 	Table->HandlerTable[PUSHD] = ViPushd;

  003ed	b8 08 00 00 00	 mov	 eax, 8
  003f2	48 6b c0 29	 imul	 rax, rax, 41		; 00000029H
  003f6	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  003fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViPushd
  00402	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 475  : 	Table->HandlerTable[PUSHQ] = ViPushq;

  00406	b8 08 00 00 00	 mov	 eax, 8
  0040b	48 6b c0 2a	 imul	 rax, rax, 42		; 0000002aH
  0040f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00414	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViPushq
  0041b	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 476  : 
; 477  : 	Table->HandlerTable[POPB] = ViPopb;

  0041f	b8 08 00 00 00	 mov	 eax, 8
  00424	48 6b c0 2b	 imul	 rax, rax, 43		; 0000002bH
  00428	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0042d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViPopb
  00434	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 478  : 	Table->HandlerTable[POPW] = ViPopw;

  00438	b8 08 00 00 00	 mov	 eax, 8
  0043d	48 6b c0 2c	 imul	 rax, rax, 44		; 0000002cH
  00441	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00446	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViPopw
  0044d	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 479  : 	Table->HandlerTable[POPD] = ViPopd;

  00451	b8 08 00 00 00	 mov	 eax, 8
  00456	48 6b c0 2d	 imul	 rax, rax, 45		; 0000002dH
  0045a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0045f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViPopd
  00466	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 480  : 	Table->HandlerTable[POPQ] = ViPopq;

  0046a	b8 08 00 00 00	 mov	 eax, 8
  0046f	48 6b c0 2e	 imul	 rax, rax, 46		; 0000002eH
  00473	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00478	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViPopq
  0047f	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 481  : 
; 482  : 	Table->HandlerTable[NPOPB] = ViNpopb;

  00483	b8 08 00 00 00	 mov	 eax, 8
  00488	48 6b c0 2f	 imul	 rax, rax, 47		; 0000002fH
  0048c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00491	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViNpopb
  00498	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 483  : 	Table->HandlerTable[NPOPW] = ViNpopw;

  0049c	b8 08 00 00 00	 mov	 eax, 8
  004a1	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  004a5	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  004aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViNpopw
  004b1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 484  : 	Table->HandlerTable[NPOPD] = ViNpopd;

  004b5	b8 08 00 00 00	 mov	 eax, 8
  004ba	48 6b c0 31	 imul	 rax, rax, 49		; 00000031H
  004be	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  004c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViNpopd
  004ca	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 485  : 	Table->HandlerTable[NPOPQ] = ViNpopq;

  004ce	b8 08 00 00 00	 mov	 eax, 8
  004d3	48 6b c0 32	 imul	 rax, rax, 50		; 00000032H
  004d7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  004dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViNpopq
  004e3	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 486  : 
; 487  : 	Table->HandlerTable[ADDB] = ViAddb;

  004e7	b8 08 00 00 00	 mov	 eax, 8
  004ec	48 6b c0 33	 imul	 rax, rax, 51		; 00000033H
  004f0	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  004f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViAddb
  004fc	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 488  : 	Table->HandlerTable[ADDW] = ViAddw;

  00500	b8 08 00 00 00	 mov	 eax, 8
  00505	48 6b c0 34	 imul	 rax, rax, 52		; 00000034H
  00509	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0050e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViAddw
  00515	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 489  : 	Table->HandlerTable[ADDD] = ViAddd;

  00519	b8 08 00 00 00	 mov	 eax, 8
  0051e	48 6b c0 35	 imul	 rax, rax, 53		; 00000035H
  00522	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00527	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViAddd
  0052e	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 490  : 	Table->HandlerTable[ADDQ] = ViAddq;

  00532	b8 08 00 00 00	 mov	 eax, 8
  00537	48 6b c0 36	 imul	 rax, rax, 54		; 00000036H
  0053b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00540	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViAddq
  00547	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 491  : 
; 492  : 	Table->HandlerTable[SUBB] = ViSubb;

  0054b	b8 08 00 00 00	 mov	 eax, 8
  00550	48 6b c0 37	 imul	 rax, rax, 55		; 00000037H
  00554	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00559	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSubb
  00560	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 493  : 	Table->HandlerTable[SUBW] = ViSubw;

  00564	b8 08 00 00 00	 mov	 eax, 8
  00569	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0056d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00572	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSubw
  00579	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 494  : 	Table->HandlerTable[SUBD] = ViSubd;

  0057d	b8 08 00 00 00	 mov	 eax, 8
  00582	48 6b c0 39	 imul	 rax, rax, 57		; 00000039H
  00586	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0058b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSubd
  00592	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 495  : 	Table->HandlerTable[SUBQ] = ViSubq;

  00596	b8 08 00 00 00	 mov	 eax, 8
  0059b	48 6b c0 3a	 imul	 rax, rax, 58		; 0000003aH
  0059f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  005a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSubq
  005ab	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 496  : 
; 497  : 	Table->HandlerTable[MULB] = ViMulb;

  005af	b8 08 00 00 00	 mov	 eax, 8
  005b4	48 6b c0 3b	 imul	 rax, rax, 59		; 0000003bH
  005b8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  005bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViMulb
  005c4	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 498  : 	Table->HandlerTable[MULW] = ViMulw;

  005c8	b8 08 00 00 00	 mov	 eax, 8
  005cd	48 6b c0 3c	 imul	 rax, rax, 60		; 0000003cH
  005d1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  005d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViMulw
  005dd	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 499  : 	Table->HandlerTable[MULD] = ViMuld;

  005e1	b8 08 00 00 00	 mov	 eax, 8
  005e6	48 6b c0 3d	 imul	 rax, rax, 61		; 0000003dH
  005ea	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  005ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViMuld
  005f6	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 500  : 	Table->HandlerTable[MULQ] = ViMulq;

  005fa	b8 08 00 00 00	 mov	 eax, 8
  005ff	48 6b c0 3e	 imul	 rax, rax, 62		; 0000003eH
  00603	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00608	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViMulq
  0060f	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 501  : 
; 502  : 	Table->HandlerTable[DIVB] = ViDivb;

  00613	b8 08 00 00 00	 mov	 eax, 8
  00618	48 6b c0 3f	 imul	 rax, rax, 63		; 0000003fH
  0061c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00621	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViDivb
  00628	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 503  : 	Table->HandlerTable[DIVW] = ViDivw;

  0062c	b8 08 00 00 00	 mov	 eax, 8
  00631	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00635	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0063a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViDivw
  00641	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 504  : 	Table->HandlerTable[DIVD] = ViDivd;

  00645	b8 08 00 00 00	 mov	 eax, 8
  0064a	48 6b c0 41	 imul	 rax, rax, 65		; 00000041H
  0064e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00653	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViDivd
  0065a	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 505  : 	Table->HandlerTable[DIVQ] = ViDivq;

  0065e	b8 08 00 00 00	 mov	 eax, 8
  00663	48 6b c0 42	 imul	 rax, rax, 66		; 00000042H
  00667	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0066c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViDivq
  00673	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 506  : 
; 507  : 	Table->HandlerTable[ANDB] = ViAndb;

  00677	b8 08 00 00 00	 mov	 eax, 8
  0067c	48 6b c0 43	 imul	 rax, rax, 67		; 00000043H
  00680	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00685	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViAndb
  0068c	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 508  : 	Table->HandlerTable[ANDW] = ViAndw;

  00690	b8 08 00 00 00	 mov	 eax, 8
  00695	48 6b c0 44	 imul	 rax, rax, 68		; 00000044H
  00699	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0069e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViAndw
  006a5	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 509  : 	Table->HandlerTable[ANDD] = ViAndd;

  006a9	b8 08 00 00 00	 mov	 eax, 8
  006ae	48 6b c0 45	 imul	 rax, rax, 69		; 00000045H
  006b2	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  006b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViAndd
  006be	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 510  : 	Table->HandlerTable[ANDQ] = ViAndq;

  006c2	b8 08 00 00 00	 mov	 eax, 8
  006c7	48 6b c0 46	 imul	 rax, rax, 70		; 00000046H
  006cb	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  006d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViAndq
  006d7	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 511  : 
; 512  : 	Table->HandlerTable[ORB] = ViOrb;

  006db	b8 08 00 00 00	 mov	 eax, 8
  006e0	48 6b c0 47	 imul	 rax, rax, 71		; 00000047H
  006e4	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  006e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViOrb
  006f0	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 513  : 	Table->HandlerTable[ORW] = ViOrw;

  006f4	b8 08 00 00 00	 mov	 eax, 8
  006f9	48 6b c0 48	 imul	 rax, rax, 72		; 00000048H
  006fd	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00702	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViOrw
  00709	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 514  : 	Table->HandlerTable[ORD] = ViOrd;

  0070d	b8 08 00 00 00	 mov	 eax, 8
  00712	48 6b c0 49	 imul	 rax, rax, 73		; 00000049H
  00716	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0071b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViOrd
  00722	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 515  : 	Table->HandlerTable[ORQ] = ViOrq;

  00726	b8 08 00 00 00	 mov	 eax, 8
  0072b	48 6b c0 4a	 imul	 rax, rax, 74		; 0000004aH
  0072f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00734	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViOrq
  0073b	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 516  : 
; 517  : 	Table->HandlerTable[XORB] = ViXorb;

  0073f	b8 08 00 00 00	 mov	 eax, 8
  00744	48 6b c0 4b	 imul	 rax, rax, 75		; 0000004bH
  00748	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0074d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViXorb
  00754	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 518  : 	Table->HandlerTable[XORW] = ViXorw;

  00758	b8 08 00 00 00	 mov	 eax, 8
  0075d	48 6b c0 4c	 imul	 rax, rax, 76		; 0000004cH
  00761	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00766	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViXorw
  0076d	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 519  : 	Table->HandlerTable[XORD] = ViXord;

  00771	b8 08 00 00 00	 mov	 eax, 8
  00776	48 6b c0 4d	 imul	 rax, rax, 77		; 0000004dH
  0077a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0077f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViXord
  00786	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 520  : 	Table->HandlerTable[XORQ] = ViXorq;

  0078a	b8 08 00 00 00	 mov	 eax, 8
  0078f	48 6b c0 4e	 imul	 rax, rax, 78		; 0000004eH
  00793	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00798	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViXorq
  0079f	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 521  : 
; 522  : 	Table->HandlerTable[SHLB] = ViShlb;

  007a3	b8 08 00 00 00	 mov	 eax, 8
  007a8	48 6b c0 4f	 imul	 rax, rax, 79		; 0000004fH
  007ac	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  007b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViShlb
  007b8	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 523  : 	Table->HandlerTable[SHLW] = ViShlw;

  007bc	b8 08 00 00 00	 mov	 eax, 8
  007c1	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  007c5	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  007ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViShlw
  007d1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 524  : 	Table->HandlerTable[SHLD] = ViShld;

  007d5	b8 08 00 00 00	 mov	 eax, 8
  007da	48 6b c0 51	 imul	 rax, rax, 81		; 00000051H
  007de	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  007e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViShld
  007ea	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 525  : 	Table->HandlerTable[SHLQ] = ViShlq;

  007ee	b8 08 00 00 00	 mov	 eax, 8
  007f3	48 6b c0 52	 imul	 rax, rax, 82		; 00000052H
  007f7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  007fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViShlq
  00803	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 526  : 
; 527  : 	Table->HandlerTable[SHRB] = ViShrb;

  00807	b8 08 00 00 00	 mov	 eax, 8
  0080c	48 6b c0 53	 imul	 rax, rax, 83		; 00000053H
  00810	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00815	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViShrb
  0081c	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 528  : 	Table->HandlerTable[SHRW] = ViShrw;

  00820	b8 08 00 00 00	 mov	 eax, 8
  00825	48 6b c0 54	 imul	 rax, rax, 84		; 00000054H
  00829	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0082e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViShrw
  00835	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 529  : 	Table->HandlerTable[SHRD] = ViShrd;

  00839	b8 08 00 00 00	 mov	 eax, 8
  0083e	48 6b c0 55	 imul	 rax, rax, 85		; 00000055H
  00842	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00847	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViShrd
  0084e	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 530  : 	Table->HandlerTable[SHRQ] = ViShrq;

  00852	b8 08 00 00 00	 mov	 eax, 8
  00857	48 6b c0 56	 imul	 rax, rax, 86		; 00000056H
  0085b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00860	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViShrq
  00867	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 531  : 
; 532  : 	Table->HandlerTable[CMPB] = ViCmpb;

  0086b	b8 08 00 00 00	 mov	 eax, 8
  00870	48 6b c0 57	 imul	 rax, rax, 87		; 00000057H
  00874	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00879	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViCmpb
  00880	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 533  : 	Table->HandlerTable[CMPW] = ViCmpw;

  00884	b8 08 00 00 00	 mov	 eax, 8
  00889	48 6b c0 58	 imul	 rax, rax, 88		; 00000058H
  0088d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00892	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViCmpw
  00899	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 534  : 	Table->HandlerTable[CMPD] = ViCmpd;

  0089d	b8 08 00 00 00	 mov	 eax, 8
  008a2	48 6b c0 59	 imul	 rax, rax, 89		; 00000059H
  008a6	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  008ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViCmpd
  008b2	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 535  : 	Table->HandlerTable[CMPQ] = ViCmpq;

  008b6	b8 08 00 00 00	 mov	 eax, 8
  008bb	48 6b c0 5a	 imul	 rax, rax, 90		; 0000005aH
  008bf	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  008c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViCmpq
  008cb	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 536  : 
; 537  : 	Table->HandlerTable[JMP] = ViJmp;

  008cf	b8 08 00 00 00	 mov	 eax, 8
  008d4	48 6b c0 5b	 imul	 rax, rax, 91		; 0000005bH
  008d8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  008dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViJmp
  008e4	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 538  : 	Table->HandlerTable[JMPI] = ViJmpi;

  008e8	b8 08 00 00 00	 mov	 eax, 8
  008ed	48 6b c0 5c	 imul	 rax, rax, 92		; 0000005cH
  008f1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  008f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViJmpi
  008fd	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 539  : 	Table->HandlerTable[JL] = ViJl;

  00901	b8 08 00 00 00	 mov	 eax, 8
  00906	48 6b c0 5d	 imul	 rax, rax, 93		; 0000005dH
  0090a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0090f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViJl
  00916	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 540  : 	Table->HandlerTable[JLE] = ViJle;

  0091a	b8 08 00 00 00	 mov	 eax, 8
  0091f	48 6b c0 5e	 imul	 rax, rax, 94		; 0000005eH
  00923	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00928	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViJle
  0092f	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 541  : 	Table->HandlerTable[JG] = ViJg;

  00933	b8 08 00 00 00	 mov	 eax, 8
  00938	48 6b c0 5f	 imul	 rax, rax, 95		; 0000005fH
  0093c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00941	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViJg
  00948	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 542  : 	Table->HandlerTable[JGE] = ViJge;

  0094c	b8 08 00 00 00	 mov	 eax, 8
  00951	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00955	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0095a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViJge
  00961	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 543  : 	Table->HandlerTable[JZ] = ViJz;

  00965	b8 08 00 00 00	 mov	 eax, 8
  0096a	48 6b c0 61	 imul	 rax, rax, 97		; 00000061H
  0096e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00973	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViJz
  0097a	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 544  : 	Table->HandlerTable[JNZ] = ViJnz;

  0097e	b8 08 00 00 00	 mov	 eax, 8
  00983	48 6b c0 62	 imul	 rax, rax, 98		; 00000062H
  00987	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  0098c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViJnz
  00993	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 545  : 
; 546  : 	Table->HandlerTable[CALL] = ViCall;

  00997	b8 08 00 00 00	 mov	 eax, 8
  0099c	48 6b c0 63	 imul	 rax, rax, 99		; 00000063H
  009a0	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  009a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViCall
  009ac	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 547  : 	Table->HandlerTable[RET] = ViRet;

  009b0	b8 08 00 00 00	 mov	 eax, 8
  009b5	48 6b c0 64	 imul	 rax, rax, 100		; 00000064H
  009b9	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  009be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViRet
  009c5	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 548  : 	Table->HandlerTable[X86CALL] = ViX86Call;

  009c9	b8 08 00 00 00	 mov	 eax, 8
  009ce	48 6b c0 65	 imul	 rax, rax, 101		; 00000065H
  009d2	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  009d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViX86Call
  009de	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 549  : 
; 550  : 	Table->HandlerTable[EDITSP] = ViEditsp;

  009e2	b8 08 00 00 00	 mov	 eax, 8
  009e7	48 6b c0 66	 imul	 rax, rax, 102		; 00000066H
  009eb	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  009f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViEditsp
  009f7	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 551  : 
; 552  : 	Table->HandlerTable[STSP] = ViStsp;

  009fb	b8 08 00 00 00	 mov	 eax, 8
  00a00	48 6b c0 67	 imul	 rax, rax, 103		; 00000067H
  00a04	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00a09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStsp
  00a10	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 553  : 	Table->HandlerTable[LDSP] = ViLdsp;

  00a14	b8 08 00 00 00	 mov	 eax, 8
  00a19	48 6b c0 68	 imul	 rax, rax, 104		; 00000068H
  00a1d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00a22	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdsp
  00a29	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 554  : 	Table->HandlerTable[STIP] = ViStip;

  00a2d	b8 08 00 00 00	 mov	 eax, 8
  00a32	48 6b c0 69	 imul	 rax, rax, 105		; 00000069H
  00a36	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00a3b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStip
  00a42	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 555  : 	Table->HandlerTable[LDIP] = ViLdip;

  00a46	b8 08 00 00 00	 mov	 eax, 8
  00a4b	48 6b c0 6a	 imul	 rax, rax, 106		; 0000006aH
  00a4f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00a54	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdip
  00a5b	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 556  : 
; 557  : 	Table->HandlerTable[SWAPB] = ViSwapb;

  00a5f	b8 08 00 00 00	 mov	 eax, 8
  00a64	48 6b c0 6b	 imul	 rax, rax, 107		; 0000006bH
  00a68	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00a6d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSwapb
  00a74	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 558  : 	Table->HandlerTable[SWAPW] = ViSwapw;

  00a78	b8 08 00 00 00	 mov	 eax, 8
  00a7d	48 6b c0 6c	 imul	 rax, rax, 108		; 0000006cH
  00a81	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00a86	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSwapw
  00a8d	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 559  : 	Table->HandlerTable[SWAPD] = ViSwapd;

  00a91	b8 08 00 00 00	 mov	 eax, 8
  00a96	48 6b c0 6d	 imul	 rax, rax, 109		; 0000006dH
  00a9a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00a9f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSwapd
  00aa6	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 560  : 	Table->HandlerTable[SWAPQ] = ViSwapq;

  00aaa	b8 08 00 00 00	 mov	 eax, 8
  00aaf	48 6b c0 6e	 imul	 rax, rax, 110		; 0000006eH
  00ab3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00ab8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSwapq
  00abf	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 561  : 
; 562  : 	Table->HandlerTable[DECB] = ViDecb;

  00ac3	b8 08 00 00 00	 mov	 eax, 8
  00ac8	48 6b c0 6f	 imul	 rax, rax, 111		; 0000006fH
  00acc	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00ad1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViDecb
  00ad8	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 563  : 	Table->HandlerTable[DECW] = ViDecw;

  00adc	b8 08 00 00 00	 mov	 eax, 8
  00ae1	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00ae5	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00aea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViDecw
  00af1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 564  : 	Table->HandlerTable[DECD] = ViDecd;

  00af5	b8 08 00 00 00	 mov	 eax, 8
  00afa	48 6b c0 71	 imul	 rax, rax, 113		; 00000071H
  00afe	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00b03	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViDecd
  00b0a	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 565  : 	Table->HandlerTable[DECQ] = ViDecq;

  00b0e	b8 08 00 00 00	 mov	 eax, 8
  00b13	48 6b c0 72	 imul	 rax, rax, 114		; 00000072H
  00b17	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00b1c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViDecq
  00b23	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 566  : 
; 567  : 	Table->HandlerTable[INCB] = ViIncb;

  00b27	b8 08 00 00 00	 mov	 eax, 8
  00b2c	48 6b c0 73	 imul	 rax, rax, 115		; 00000073H
  00b30	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00b35	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViIncb
  00b3c	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 568  : 	Table->HandlerTable[INCW] = ViIncw;

  00b40	b8 08 00 00 00	 mov	 eax, 8
  00b45	48 6b c0 74	 imul	 rax, rax, 116		; 00000074H
  00b49	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00b4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViIncw
  00b55	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 569  : 	Table->HandlerTable[INCD] = ViIncd;

  00b59	b8 08 00 00 00	 mov	 eax, 8
  00b5e	48 6b c0 75	 imul	 rax, rax, 117		; 00000075H
  00b62	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00b67	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViIncd
  00b6e	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 570  : 	Table->HandlerTable[INCQ] = ViIncq;

  00b72	b8 08 00 00 00	 mov	 eax, 8
  00b77	48 6b c0 76	 imul	 rax, rax, 118		; 00000076H
  00b7b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00b80	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViIncq
  00b87	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 571  : 
; 572  : 	Table->HandlerTable[SWAPBQ] = ViSwapbq;

  00b8b	b8 08 00 00 00	 mov	 eax, 8
  00b90	48 6b c0 77	 imul	 rax, rax, 119		; 00000077H
  00b94	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00b99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSwapbq
  00ba0	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 573  : 	Table->HandlerTable[SWAPWQ] = ViSwapwq;

  00ba4	b8 08 00 00 00	 mov	 eax, 8
  00ba9	48 6b c0 78	 imul	 rax, rax, 120		; 00000078H
  00bad	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00bb2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSwapwq
  00bb9	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 574  : 	Table->HandlerTable[SWAPDQ] = ViSwapdq;

  00bbd	b8 08 00 00 00	 mov	 eax, 8
  00bc2	48 6b c0 79	 imul	 rax, rax, 121		; 00000079H
  00bc6	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00bcb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViSwapdq
  00bd2	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 575  : 
; 576  : 	Table->HandlerTable[LDSB] = ViLdsb;

  00bd6	b8 08 00 00 00	 mov	 eax, 8
  00bdb	48 6b c0 7a	 imul	 rax, rax, 122		; 0000007aH
  00bdf	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00be4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdsb
  00beb	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 577  : 	Table->HandlerTable[LDSW] = ViLdsw;

  00bef	b8 08 00 00 00	 mov	 eax, 8
  00bf4	48 6b c0 7b	 imul	 rax, rax, 123		; 0000007bH
  00bf8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00bfd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdsw
  00c04	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 578  : 	Table->HandlerTable[LDSD] = ViLdsd;

  00c08	b8 08 00 00 00	 mov	 eax, 8
  00c0d	48 6b c0 7c	 imul	 rax, rax, 124		; 0000007cH
  00c11	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00c16	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdsd
  00c1d	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 579  : 	Table->HandlerTable[LDSQ] = ViLdsq;

  00c21	b8 08 00 00 00	 mov	 eax, 8
  00c26	48 6b c0 7d	 imul	 rax, rax, 125		; 0000007dH
  00c2a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00c2f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdsq
  00c36	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 580  : 
; 581  : 	Table->HandlerTable[STSB] = ViStsb;

  00c3a	b8 08 00 00 00	 mov	 eax, 8
  00c3f	48 6b c0 7e	 imul	 rax, rax, 126		; 0000007eH
  00c43	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00c48	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStsb
  00c4f	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 582  : 	Table->HandlerTable[STSW] = ViStsw;

  00c53	b8 08 00 00 00	 mov	 eax, 8
  00c58	48 6b c0 7f	 imul	 rax, rax, 127		; 0000007fH
  00c5c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00c61	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStsw
  00c68	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 583  : 	Table->HandlerTable[STSD] = ViStsd;

  00c6c	b8 08 00 00 00	 mov	 eax, 8
  00c71	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  00c78	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00c7d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStsd
  00c84	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 584  : 	Table->HandlerTable[STSQ] = ViStsq;

  00c88	b8 08 00 00 00	 mov	 eax, 8
  00c8d	48 69 c0 81 00
	00 00		 imul	 rax, rax, 129		; 00000081H
  00c94	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00c99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStsq
  00ca0	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 585  : 
; 586  : 	Table->HandlerTable[LDBPB] = ViLdbpb;

  00ca4	b8 08 00 00 00	 mov	 eax, 8
  00ca9	48 69 c0 82 00
	00 00		 imul	 rax, rax, 130		; 00000082H
  00cb0	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00cb5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdbpb
  00cbc	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 587  : 	Table->HandlerTable[LDBPW] = ViLdbpw;

  00cc0	b8 08 00 00 00	 mov	 eax, 8
  00cc5	48 69 c0 83 00
	00 00		 imul	 rax, rax, 131		; 00000083H
  00ccc	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00cd1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdbpw
  00cd8	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 588  : 	Table->HandlerTable[LDBPD] = ViLdbpd;

  00cdc	b8 08 00 00 00	 mov	 eax, 8
  00ce1	48 69 c0 84 00
	00 00		 imul	 rax, rax, 132		; 00000084H
  00ce8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00ced	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdbpd
  00cf4	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 589  : 	Table->HandlerTable[LDBPQ] = ViLdbpq;

  00cf8	b8 08 00 00 00	 mov	 eax, 8
  00cfd	48 69 c0 85 00
	00 00		 imul	 rax, rax, 133		; 00000085H
  00d04	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00d09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViLdbpq
  00d10	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 590  : 
; 591  : 	Table->HandlerTable[STBPB] = ViStbpb;

  00d14	b8 08 00 00 00	 mov	 eax, 8
  00d19	48 69 c0 86 00
	00 00		 imul	 rax, rax, 134		; 00000086H
  00d20	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00d25	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStbpb
  00d2c	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 592  : 	Table->HandlerTable[STBPW] = ViStbpw;

  00d30	b8 08 00 00 00	 mov	 eax, 8
  00d35	48 69 c0 87 00
	00 00		 imul	 rax, rax, 135		; 00000087H
  00d3c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00d41	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStbpw
  00d48	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 593  : 	Table->HandlerTable[STBPD] = ViStbpd;

  00d4c	b8 08 00 00 00	 mov	 eax, 8
  00d51	48 69 c0 88 00
	00 00		 imul	 rax, rax, 136		; 00000088H
  00d58	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00d5d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStbpd
  00d64	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 594  : 	Table->HandlerTable[STBPQ] = ViStbpq;

  00d68	b8 08 00 00 00	 mov	 eax, 8
  00d6d	48 69 c0 89 00
	00 00		 imul	 rax, rax, 137		; 00000089H
  00d74	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Table$[rsp]
  00d79	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ViStbpq
  00d80	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 595  : }

  00d84	c3		 ret	 0
?InitHandlerTable@@YAXPEAU_VM_HANDLER_TABLE@@@Z ENDP	; InitHandlerTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\ios
;	COMDAT ?hex@std@@YAAEAVios_base@1@AEAV21@@Z
_TEXT	SEGMENT
_Iosbase$ = 48
?hex@std@@YAAEAVios_base@1@AEAV21@@Z PROC		; std::hex, COMDAT

; 206  : inline ios_base& __CLRCALL_OR_CDECL hex(ios_base& _Iosbase) { // set basefield to hex

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 207  :     _Iosbase.setf(ios_base::hex, ios_base::basefield);

  00009	41 b8 00 0e 00
	00		 mov	 r8d, 3584		; 00000e00H
  0000f	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Iosbase$[rsp]
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setf@ios_base@std@@QEAAHHH@Z

; 208  :     return _Iosbase;

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR _Iosbase$[rsp]

; 209  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
?hex@std@@YAAEAVios_base@1@AEAV21@@Z ENDP		; std::hex
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z
_TEXT	SEGMENT
tv81 = 32
_Count$ = 40
_Ptrnext$1 = 48
_Ptrdest$ = 56
tv80 = 64
_Ptr$ = 96
__formal$ = 104
__formal$ = 112
??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 563  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 564  :     // convert C string to _Elem sequence using _Cvtvec
; 565  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00018	48 89 44 24 40	 mov	 QWORD PTR tv80[rsp], rax
  0001d	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR tv81[rsp], -1
$LL7@Maklocstr:
  00026	48 ff 44 24 20	 inc	 QWORD PTR tv81[rsp]
  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR tv80[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv81[rsp]
  00035	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00039	75 eb		 jne	 SHORT $LL7@Maklocstr
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR tv81[rsp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 44 24 28	 mov	 QWORD PTR _Count$[rsp], rax

; 566  : 
; 567  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00048	ba 01 00 00 00	 mov	 edx, 1
  0004d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Count$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00058	48 89 44 24 38	 mov	 QWORD PTR _Ptrdest$[rsp], rax

; 568  : 
; 569  :     if (!_Ptrdest) {

  0005d	48 83 7c 24 38
	00		 cmp	 QWORD PTR _Ptrdest$[rsp], 0
  00063	75 05		 jne	 SHORT $LN5@Maklocstr

; 570  :         _Xbad_alloc();

  00065	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 571  :     }
; 572  : 
; 573  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0006a	48 8b 44 24 38	 mov	 rax, QWORD PTR _Ptrdest$[rsp]
  0006f	48 89 44 24 30	 mov	 QWORD PTR _Ptrnext$1[rsp], rax
  00074	eb 27		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR _Count$[rsp]
  0007b	48 ff c8	 dec	 rax
  0007e	48 89 44 24 28	 mov	 QWORD PTR _Count$[rsp], rax
  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ptrnext$1[rsp]
  00088	48 ff c0	 inc	 rax
  0008b	48 89 44 24 30	 mov	 QWORD PTR _Ptrnext$1[rsp], rax
  00090	48 8b 44 24 60	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00095	48 ff c0	 inc	 rax
  00098	48 89 44 24 60	 mov	 QWORD PTR _Ptr$[rsp], rax
$LN4@Maklocstr:
  0009d	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Count$[rsp], 0
  000a3	76 11		 jbe	 SHORT $LN3@Maklocstr

; 574  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  000a5	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ptrnext$1[rsp]
  000aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  000af	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000b2	88 08		 mov	 BYTE PTR [rax], cl

; 575  :     }

  000b4	eb c0		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 576  : 
; 577  :     return _Ptrdest;

  000b6	48 8b 44 24 38	 mov	 rax, QWORD PTR _Ptrdest$[rsp]
$LN6@Maklocstr:

; 578  : }

  000bb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000bf	c3		 ret	 0
??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPEA_WPEB_W@Z
_TEXT	SEGMENT
tv80 = 32
_Ptrdest$ = 40
_Count$ = 48
tv79 = 56
_Ptr$ = 80
?_Maklocwcs@std@@YAPEA_WPEB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 90   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 91   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR _Ptr$[rsp]
  0000e	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
  00013	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR tv80[rsp], -1
$LL4@Maklocwcs:
  0001c	48 ff 44 24 20	 inc	 QWORD PTR tv80[rsp]
  00021	48 8b 44 24 38	 mov	 rax, QWORD PTR tv79[rsp]
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv80[rsp]
  0002b	66 83 3c 48 00	 cmp	 WORD PTR [rax+rcx*2], 0
  00030	75 ea		 jne	 SHORT $LL4@Maklocwcs
  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR tv80[rsp]
  00037	48 ff c0	 inc	 rax
  0003a	48 89 44 24 30	 mov	 QWORD PTR _Count$[rsp], rax

; 92   : 
; 93   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  0003f	ba 02 00 00 00	 mov	 edx, 2
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Count$[rsp]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0004f	48 89 44 24 28	 mov	 QWORD PTR _Ptrdest$[rsp], rax

; 94   : 
; 95   :     if (!_Ptrdest) {

  00054	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Ptrdest$[rsp], 0
  0005a	75 05		 jne	 SHORT $LN2@Maklocwcs

; 96   :         _Xbad_alloc();

  0005c	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:

; 97   :     }
; 98   : 
; 99   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

  00061	4c 8b 44 24 30	 mov	 r8, QWORD PTR _Count$[rsp]
  00066	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  0006b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Ptrdest$[rsp]
  00070	e8 00 00 00 00	 call	 wmemcpy

; 100  :     return _Ptrdest;

  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR _Ptrdest$[rsp]
$LN3@Maklocwcs:

; 101  : }

  0007a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007e	c3		 ret	 0
?_Maklocwcs@std@@YAPEA_WPEB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 67   :     operator streamoff() const {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 68   :         // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
; 69   :         // basic_filebuf would set _Fpos.
; 70   :         return _Myoff + _Fpos;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00012	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]

; 71   :     }

  00016	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT

; 59   :     _NODISCARD _Statetype state() const {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 60   :         return _Mystate;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00018	48 89 01	 mov	 QWORD PTR [rcx], rax
  0001b	48 8b 44 24 10	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 61   :     }

  00020	c3		 ret	 0
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
this$ = 8
_State$ = 16
_Fileposition$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _Fileposition$[rsp]
  00019	48 89 08	 mov	 QWORD PTR [rax], rcx
  0001c	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00029	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _State$[rsp]
  00033	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00037	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003c	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 16
_Off$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _Off$[rsp]
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx
  00018	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00025	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 83 c0 10	 add	 rax, 16
  0002e	48 8b f8	 mov	 rdi, rax
  00031	33 c0		 xor	 eax, eax
  00033	b9 08 00 00 00	 mov	 ecx, 8
  00038	f3 aa		 rep stosb
  0003a	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1192 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1193 :     // check that [_First, _Last) forms an iterator range
; 1194 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1195 :         _Verify_range(_First, _Last);
; 1196 :     }
; 1197 : }

  0000a	c3		 ret	 0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z
_TEXT	SEGMENT
_Bytes$ = 48
_Wchars$ = 56
_Count$ = 64
tv151 = 72
_Ptrnext$ = 80
_Ptr1$ = 88
_Ptrdest$ = 96
_Count1$ = 104
tv150 = 112
_Wc$ = 120
_Mbst1$ = 128
_Mbst2$ = 136
__$ArrayPad$ = 144
_Ptr$ = 176
__formal$ = 184
_Cvt$ = 192
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z PROC ; std::_Maklocstr<wchar_t>, COMDAT

; 581  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 582  :     // convert C string to wchar_t sequence using _Cvtvec
; 583  :     size_t _Count;
; 584  :     size_t _Count1;
; 585  :     size_t _Wchars;
; 586  :     const char* _Ptr1;
; 587  :     int _Bytes;
; 588  :     wchar_t _Wc;
; 589  :     mbstate_t _Mbst1 = {};

  00029	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR _Mbst1$[rsp]
  00031	48 8b f8	 mov	 rdi, rax
  00034	33 c0		 xor	 eax, eax
  00036	b9 08 00 00 00	 mov	 ecx, 8
  0003b	f3 aa		 rep stosb

; 590  : 
; 591  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  0003d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00045	48 89 44 24 70	 mov	 QWORD PTR tv150[rsp], rax
  0004a	48 c7 44 24 48
	ff ff ff ff	 mov	 QWORD PTR tv151[rsp], -1
$LL12@Maklocstr:
  00053	48 ff 44 24 48	 inc	 QWORD PTR tv151[rsp]
  00058	48 8b 44 24 70	 mov	 rax, QWORD PTR tv150[rsp]
  0005d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv151[rsp]
  00062	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00066	75 eb		 jne	 SHORT $LL12@Maklocstr
  00068	48 8b 44 24 48	 mov	 rax, QWORD PTR tv151[rsp]
  0006d	48 ff c0	 inc	 rax
  00070	48 89 44 24 68	 mov	 QWORD PTR _Count1$[rsp], rax

; 592  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  00075	48 8b 44 24 68	 mov	 rax, QWORD PTR _Count1$[rsp]
  0007a	48 89 44 24 40	 mov	 QWORD PTR _Count$[rsp], rax
  0007f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _Wchars$[rsp], 0
  00088	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00090	48 89 44 24 58	 mov	 QWORD PTR _Ptr1$[rsp], rax
  00095	eb 37		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00097	48 63 44 24 30	 movsxd	 rax, DWORD PTR _Bytes$[rsp]
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Count$[rsp]
  000a1	48 2b c8	 sub	 rcx, rax
  000a4	48 8b c1	 mov	 rax, rcx
  000a7	48 89 44 24 40	 mov	 QWORD PTR _Count$[rsp], rax
  000ac	48 63 44 24 30	 movsxd	 rax, DWORD PTR _Bytes$[rsp]
  000b1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Ptr1$[rsp]
  000b6	48 03 c8	 add	 rcx, rax
  000b9	48 8b c1	 mov	 rax, rcx
  000bc	48 89 44 24 58	 mov	 QWORD PTR _Ptr1$[rsp], rax
  000c1	48 8b 44 24 38	 mov	 rax, QWORD PTR _Wchars$[rsp]
  000c6	48 ff c0	 inc	 rax
  000c9	48 89 44 24 38	 mov	 QWORD PTR _Wchars$[rsp], rax
$LN4@Maklocstr:
  000ce	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Count$[rsp], 0
  000d4	76 38		 jbe	 SHORT $LN3@Maklocstr

; 593  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  000d6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR _Cvt$[rsp]
  000de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e3	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR _Mbst1$[rsp]
  000eb	4c 8b 44 24 40	 mov	 r8, QWORD PTR _Count$[rsp]
  000f0	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Ptr1$[rsp]
  000f5	48 8d 4c 24 78	 lea	 rcx, QWORD PTR _Wc$[rsp]
  000fa	e8 00 00 00 00	 call	 _Mbrtowc
  000ff	89 44 24 30	 mov	 DWORD PTR _Bytes$[rsp], eax
  00103	83 7c 24 30 00	 cmp	 DWORD PTR _Bytes$[rsp], 0
  00108	7f 02		 jg	 SHORT $LN8@Maklocstr

; 594  :             break;

  0010a	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 595  :         }
; 596  :     }

  0010c	eb 89		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 597  : 
; 598  :     ++_Wchars; // count terminating nul

  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR _Wchars$[rsp]
  00113	48 ff c0	 inc	 rax
  00116	48 89 44 24 38	 mov	 QWORD PTR _Wchars$[rsp], rax

; 599  : 
; 600  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  0011b	ba 02 00 00 00	 mov	 edx, 2
  00120	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Wchars$[rsp]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0012b	48 89 44 24 60	 mov	 QWORD PTR _Ptrdest$[rsp], rax

; 601  : 
; 602  :     if (!_Ptrdest) {

  00130	48 83 7c 24 60
	00		 cmp	 QWORD PTR _Ptrdest$[rsp], 0
  00136	75 05		 jne	 SHORT $LN9@Maklocstr

; 603  :         _Xbad_alloc();

  00138	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 604  :     }
; 605  : 
; 606  :     wchar_t* _Ptrnext = _Ptrdest;

  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR _Ptrdest$[rsp]
  00142	48 89 44 24 50	 mov	 QWORD PTR _Ptrnext$[rsp], rax

; 607  :     mbstate_t _Mbst2  = {};

  00147	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR _Mbst2$[rsp]
  0014f	48 8b f8	 mov	 rdi, rax
  00152	33 c0		 xor	 eax, eax
  00154	b9 08 00 00 00	 mov	 ecx, 8
  00159	f3 aa		 rep stosb

; 608  : 
; 609  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  0015b	eb 4b		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:
  0015d	48 63 44 24 30	 movsxd	 rax, DWORD PTR _Bytes$[rsp]
  00162	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Count$[rsp]
  00167	48 2b c8	 sub	 rcx, rax
  0016a	48 8b c1	 mov	 rax, rcx
  0016d	48 89 44 24 40	 mov	 QWORD PTR _Count$[rsp], rax
  00172	48 63 44 24 30	 movsxd	 rax, DWORD PTR _Bytes$[rsp]
  00177	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  0017f	48 03 c8	 add	 rcx, rax
  00182	48 8b c1	 mov	 rax, rcx
  00185	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR _Ptr$[rsp], rax
  0018d	48 8b 44 24 38	 mov	 rax, QWORD PTR _Wchars$[rsp]
  00192	48 ff c8	 dec	 rax
  00195	48 89 44 24 38	 mov	 QWORD PTR _Wchars$[rsp], rax
  0019a	48 8b 44 24 50	 mov	 rax, QWORD PTR _Ptrnext$[rsp]
  0019f	48 83 c0 02	 add	 rax, 2
  001a3	48 89 44 24 50	 mov	 QWORD PTR _Ptrnext$[rsp], rax
$LN7@Maklocstr:
  001a8	48 83 7c 24 38
	00		 cmp	 QWORD PTR _Wchars$[rsp], 0
  001ae	76 3e		 jbe	 SHORT $LN6@Maklocstr

; 610  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  001b0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR _Cvt$[rsp]
  001b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bd	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR _Mbst2$[rsp]
  001c5	4c 8b 44 24 68	 mov	 r8, QWORD PTR _Count1$[rsp]
  001ca	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  001d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Ptrnext$[rsp]
  001d7	e8 00 00 00 00	 call	 _Mbrtowc
  001dc	89 44 24 30	 mov	 DWORD PTR _Bytes$[rsp], eax
  001e0	83 7c 24 30 00	 cmp	 DWORD PTR _Bytes$[rsp], 0
  001e5	7f 02		 jg	 SHORT $LN10@Maklocstr

; 611  :             break;

  001e7	eb 05		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 612  :         }
; 613  :     }

  001e9	e9 6f ff ff ff	 jmp	 $LN5@Maklocstr
$LN6@Maklocstr:

; 614  : 
; 615  :     *_Ptrnext = L'\0';

  001ee	33 c0		 xor	 eax, eax
  001f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Ptrnext$[rsp]
  001f5	66 89 01	 mov	 WORD PTR [rcx], ax

; 616  : 
; 617  :     return _Ptrdest;

  001f8	48 8b 44 24 60	 mov	 rax, QWORD PTR _Ptrdest$[rsp]
$LN11@Maklocstr:

; 618  : }

  001fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00205	48 33 cc	 xor	 rcx, rsp
  00208	e8 00 00 00 00	 call	 __security_check_cookie
  0020d	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00214	5f		 pop	 rdi
  00215	c3		 ret	 0
??$_Maklocstr@_W@std@@YAPEA_WPEBDPEA_WAEBU_Cvtvec@@@Z ENDP ; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
_TEXT	SEGMENT
tv71 = 32
_Facptr$ = 40
_Ptr0$ = 48
this$ = 80
_Id$ = 88
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z PROC	; std::locale::_Getfacet, COMDAT

; 373  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00017	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001b	48 39 44 24 58	 cmp	 QWORD PTR _Id$[rsp], rax
  00020	73 1d		 jae	 SHORT $LN6@Getfacet
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Id$[rsp]
  00034	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv71[rsp], rax
  0003d	eb 09		 jmp	 SHORT $LN7@Getfacet
$LN6@Getfacet:
  0003f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv71[rsp], 0
$LN7@Getfacet:
  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR tv71[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR _Facptr$[rsp], rax

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  00052	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Facptr$[rsp], 0
  00058	75 11		 jne	 SHORT $LN3@Getfacet
  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0005f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00063	0f b6 40 24	 movzx	 eax, BYTE PTR [rax+36]
  00067	85 c0		 test	 eax, eax
  00069	75 07		 jne	 SHORT $LN2@Getfacet
$LN3@Getfacet:

; 376  :             return _Facptr; // found facet or not transparent

  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR _Facptr$[rsp]
  00070	eb 30		 jmp	 SHORT $LN1@Getfacet
$LN2@Getfacet:

; 377  :         }
; 378  : 
; 379  :         // look in current locale
; 380  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  00072	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00077	48 89 44 24 30	 mov	 QWORD PTR _Ptr0$[rsp], rax

; 381  :         if (_Id < _Ptr0->_Facetcount) {

  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ptr0$[rsp]
  00081	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00085	48 39 44 24 58	 cmp	 QWORD PTR _Id$[rsp], rax
  0008a	73 14		 jae	 SHORT $LN4@Getfacet

; 382  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ptr0$[rsp]
  00091	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00095	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Id$[rsp]
  0009a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0009e	eb 02		 jmp	 SHORT $LN1@Getfacet
$LN4@Getfacet:

; 383  :         }
; 384  : 
; 385  :         return nullptr; // no entry in current locale

  000a0	33 c0		 xor	 eax, eax
$LN1@Getfacet:

; 386  :     }

  000a2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a6	c3		 ret	 0
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ENDP	; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv85 = 40
tv86 = 48
this$ = 80
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 350  :     ~locale() noexcept {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 351  :         if (_Ptr) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00013	74 53		 je	 SHORT $LN2@locale

; 352  :             delete _Ptr->_Decref();

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	ff 50 10	 call	 QWORD PTR [rax+16]
  0002d	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00032	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00038	74 25		 je	 SHORT $LN4@locale
  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]
  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
  0004a	ba 01 00 00 00	 mov	 edx, 1
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00054	ff 54 24 28	 call	 QWORD PTR tv85[rsp]
  00058	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
  0005d	eb 09		 jmp	 SHORT $LN2@locale
$LN4@locale:
  0005f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
$LN2@locale:

; 353  :         }
; 354  :     }

  00068	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006c	c3		 ret	 0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 64   : [[noreturn]] inline void _Throw_bad_cast() {

$LN3:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 65   :     _THROW(bad_cast{});

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QEAA@XZ ; std::bad_cast::bad_cast
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
$LN2@Throw_bad_:

; 66   : }

  0001f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00023	c3		 ret	 0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1bad_cast@std@@UEAA@XZ
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 00 00 00	 mov	 edx, 24
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR __that$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@AEBV01@@Z ; std::exception::exception
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_cast@std@@6B@
  00029	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT

; 135  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 134  :         : exception("bad cast", 1)

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast@
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001b	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@QEBDH@Z ; std::exception::exception

; 135  :     {

  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_cast@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 136  :     }

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1348 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1349 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1344 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1345 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4328 :     const _Alty& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4329 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4330 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4324 :     _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4325 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4326 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_Ptr$2 = 40
_Al$3 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4299 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4300 :         _Mypair._Myval2._Orphan_all();

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00023	0f b6 c0	 movzx	 eax, al
  00026	85 c0		 test	 eax, eax
  00028	74 47		 je	 SHORT $LN2@Tidy_deall

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 89 44 24 28	 mov	 QWORD PTR _Ptr$2[rsp], rax

; 4303 :             auto& _Al          = _Getal();

  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0003c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00041	48 89 44 24 30	 mov	 QWORD PTR _Al$3[rsp], rax

; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00058	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005c	48 ff c0	 inc	 rax
  0005f	4c 8b c0	 mov	 r8, rax
  00062	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Ptr$2[rsp]
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Al$3[rsp]
  0006c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4306 :         }
; 4307 : 
; 4308 :         _Mypair._Myval2._Mysize = 0;

  00071	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00076	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00083	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0008b	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	48 6b c0 00	 imul	 rax, rax, 0
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0009e	48 03 c8	 add	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
  000b1	90		 npad	 1

; 4312 :     }

  000b2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b6	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 4292 :     void _Tidy_init() noexcept { // initialize basic_string data members

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4293 :         _Mypair._Myval2._Mysize = 0;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00023	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	48 6b c0 00	 imul	 rax, rax, 0
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4297 :     }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
$T1 = 32
tv75 = 40
tv77 = 48
this$ = 80
_Newsize$ = 88
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 4288 :     void _Eos(const size_type _Newsize) { // set new length and null terminator

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4289 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  0000e	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00020	48 89 44 24 30	 mov	 QWORD PTR tv77[rsp], rax
  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Newsize$[rsp]
  0002f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00033	48 8b 44 24 58	 mov	 rax, QWORD PTR _Newsize$[rsp]
  00038	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  0003d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv75[rsp]
  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv77[rsp]
  00047	48 03 c8	 add	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4290 :     }

  0005a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005e	c3		 ret	 0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4213 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4214 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00018	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00026	48 89 44 24 28	 mov	 QWORD PTR tv74[rsp], rax
  0002b	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv76[rsp]
  00030	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv74[rsp]
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Requested$[rsp]
  0003a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 4215 :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
$T1 = 32
_Masked$ = 40
__$ArrayPad$ = 48
_Requested$ = 80
_Old$ = 88
_Max$ = 96
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4200 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR _Requested$[rsp]
  00027	48 83 c8 0f	 or	 rax, 15
  0002b	48 89 44 24 28	 mov	 QWORD PTR _Masked$[rsp], rax

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR _Max$[rsp]
  00035	48 39 44 24 28	 cmp	 QWORD PTR _Masked$[rsp], rax
  0003a	76 07		 jbe	 SHORT $LN2@Calculate_

; 4203 :             return _Max;

  0003c	48 8b 44 24 60	 mov	 rax, QWORD PTR _Max$[rsp]
  00041	eb 59		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00043	33 d2		 xor	 edx, edx
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR _Old$[rsp]
  0004a	b9 02 00 00 00	 mov	 ecx, 2
  0004f	48 f7 f1	 div	 rcx
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Max$[rsp]
  00057	48 2b c8	 sub	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 39 44 24 58	 cmp	 QWORD PTR _Old$[rsp], rax
  00062	76 07		 jbe	 SHORT $LN3@Calculate_

; 4207 :             return _Max;

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR _Max$[rsp]
  00069	eb 31		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0006b	33 d2		 xor	 edx, edx
  0006d	48 8b 44 24 58	 mov	 rax, QWORD PTR _Old$[rsp]
  00072	b9 02 00 00 00	 mov	 ecx, 2
  00077	48 f7 f1	 div	 rcx
  0007a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Old$[rsp]
  0007f	48 03 c8	 add	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0008a	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0008f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Masked$[rsp]
  00094	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  00099	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN1@Calculate_:

; 4211 :     }

  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a1	48 33 cc	 xor	 rcx, rsp
  000a4	e8 00 00 00 00	 call	 __security_check_cookie
  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT

; 4194 :     _NODISCARD allocator_type get_allocator() const noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4195 :         return static_cast<allocator_type>(_Getal());

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 4196 :     }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
_TEXT	SEGMENT
tv83 = 32
tv81 = 40
tv79 = 48
this$ = 80
_Ptr$ = 88
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT

; 4095 :     bool _Equal(_In_z_ const _Elem* const _Ptr) const noexcept { // compare [0, size()) with _Ptr for equality

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4096 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  0000e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00013	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00018	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00026	48 89 44 24 28	 mov	 QWORD PTR tv81[rsp], rax
  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 8b c8	 mov	 rcx, rax
  00033	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00038	48 89 44 24 30	 mov	 QWORD PTR tv79[rsp], rax
  0003d	4c 8b 4c 24 20	 mov	 r9, QWORD PTR tv83[rsp]
  00042	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Ptr$[rsp]
  00047	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv81[rsp]
  0004c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv79[rsp]
  00051	e8 00 00 00 00	 call	 ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ; std::_Traits_equal<std::char_traits<char> >

; 4097 :     }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
tv86 = 48
tv84 = 56
this$ = 80
_Right$ = 88
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT

; 4090 :     bool _Equal(const basic_string& _Right) const noexcept { // compare [0, size()) with _Right for equality

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4091 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR _Right$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 44 24 20	 mov	 QWORD PTR tv90[rsp], rax
  0001c	48 8b 44 24 58	 mov	 rax, QWORD PTR _Right$[rsp]
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00029	48 89 44 24 28	 mov	 QWORD PTR tv88[rsp], rax
  0002e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00049	48 89 44 24 38	 mov	 QWORD PTR tv84[rsp], rax
  0004e	4c 8b 4c 24 20	 mov	 r9, QWORD PTR tv90[rsp]
  00053	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv88[rsp]
  00058	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv86[rsp]
  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv84[rsp]
  00062	e8 00 00 00 00	 call	 ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ; std::_Traits_equal<std::char_traits<char> >

; 4092 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 4093 :     }

  00067	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006b	c3		 ret	 0
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT

; 4085 :     _NODISCARD basic_string substr(const size_type _Off = 0, const size_type _Count = npos) const {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR $T2[rsp], 0

; 4086 :         // return [_Off, _Off + _Count) as new string
; 4087 :         return basic_string(*this, _Off, _Count, get_allocator());

  00020	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00025	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	e8 00 00 00 00	 call	 ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
  0002f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00034	4c 8b 4c 24 68	 mov	 r9, QWORD PTR _Count$[rsp]
  00039	4c 8b 44 24 60	 mov	 r8, QWORD PTR _Off$[rsp]
  0003e	48 8b 54 24 50	 mov	 rdx, QWORD PTR this$[rsp]
  00043	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00048	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004d	8b 44 24 34	 mov	 eax, DWORD PTR $T2[rsp]
  00051	83 c8 01	 or	 eax, 1
  00054	89 44 24 34	 mov	 DWORD PTR $T2[rsp], eax
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 4088 :     }

  0005d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00061	c3		 ret	 0
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
tv91 = 48
tv89 = 56
tv87 = 64
tv85 = 72
this$ = 96
_Right$ = 104
_Off$ = 112
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 3865 :     _NODISCARD size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3866 :         // look for _Right beginning at or after _Off
; 3867 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

  00013	48 8b 44 24 68	 mov	 rax, QWORD PTR _Right$[rsp]
  00018	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001c	48 89 44 24 30	 mov	 QWORD PTR tv91[rsp], rax
  00021	48 8b 44 24 68	 mov	 rax, QWORD PTR _Right$[rsp]
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0002e	48 89 44 24 38	 mov	 QWORD PTR tv89[rsp], rax
  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00038	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003c	48 89 44 24 40	 mov	 QWORD PTR tv87[rsp], rax
  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00046	48 8b c8	 mov	 rcx, rax
  00049	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0004e	48 89 44 24 48	 mov	 QWORD PTR tv85[rsp], rax
  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR tv91[rsp]
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	4c 8b 4c 24 38	 mov	 r9, QWORD PTR tv89[rsp]
  00062	4c 8b 44 24 70	 mov	 r8, QWORD PTR _Off$[rsp]
  00067	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv87[rsp]
  0006c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv85[rsp]
  00071	e8 00 00 00 00	 call	 ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >

; 3868 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 3869 :     }

  00076	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007a	c3		 ret	 0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 32
this$ = 64
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 3763 :     _NODISCARD bool empty() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3764 :         return size() == 0;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00013	48 85 c0	 test	 rax, rax
  00016	75 0a		 jne	 SHORT $LN3@empty
  00018	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00020	eb 08		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@empty:
  0002a	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv67[rsp]

; 3765 :     }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Storage_max$ = 40
$T2 = 48
$T3 = 56
_Alloc_max$ = 64
__$ArrayPad$ = 72
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 3689 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3690 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  0002a	48 89 44 24 40	 mov	 QWORD PTR _Alloc_max$[rsp], rax

; 3691 :         const size_type _Storage_max = // can always store small string

  0002f	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR $T1[rsp], 16
  00038	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0003d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Alloc_max$[rsp]
  00042	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  00047	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004a	48 89 44 24 28	 mov	 QWORD PTR _Storage_max$[rsp], rax

; 3692 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3693 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR _Storage_max$[rsp]
  00054	48 ff c8	 dec	 rax
  00057	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  0005c	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00061	48 89 44 24 38	 mov	 QWORD PTR $T3[rsp], rax
  00066	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  0006b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T3[rsp]
  00070	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 3694 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3695 :         );
; 3696 :     }

  00078	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007d	48 33 cc	 xor	 rcx, rsp
  00080	e8 00 00 00 00	 call	 __security_check_cookie
  00085	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00089	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 3685 :     _NODISCARD size_type size() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 3686 :         return _Mypair._Myval2._Mysize;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 3687 :     }

  0000e	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT

; 3681 :     _NODISCARD size_type length() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 3682 :         return _Mypair._Myval2._Mysize;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 3683 :     }

  0000e	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 3676 :     _NODISCARD _Ret_z_ _Elem* data() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3677 :         return _Mypair._Myval2._Myptr();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 3678 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 3671 :     _NODISCARD _Ret_z_ const _Elem* data() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3672 :         return _Mypair._Myval2._Myptr();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 3673 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 3667 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3668 :         return _Mypair._Myval2._Myptr();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 3669 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ
_TEXT	SEGMENT
this$ = 48
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front, COMDAT

; 3635 :     _NODISCARD reference front() noexcept /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3636 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3637 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3638 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3639 : 
; 3640 :         return _Mypair._Myval2._Myptr()[0];

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00016	b9 01 00 00 00	 mov	 ecx, 1
  0001b	48 6b c9 00	 imul	 rcx, rcx, 0
  0001f	48 03 c1	 add	 rax, rcx

; 3641 :     }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_Old_size$ = 32
this$ = 64
?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back, COMDAT

; 3627 :     void pop_back() noexcept /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3628 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00012	48 89 44 24 20	 mov	 QWORD PTR _Old_size$[rsp], rax

; 3629 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 3630 :         _STL_VERIFY(_Old_size != 0, "invalid to pop_back empty string");
; 3631 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 3632 :         _Eos(_Old_size - 1);

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR _Old_size$[rsp]
  0001c	48 ff c8	 dec	 rax
  0001f	48 8b d0	 mov	 rdx, rax
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  0002c	90		 npad	 1

; 3633 :     }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Old_size$ = 40
_Ptr$3 = 48
this$ = 80
_Ch$ = 88
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 3607 :     void push_back(const _Elem _Ch) { // insert element at end

$LN4:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3608 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 44 24 28	 mov	 QWORD PTR _Old_size$[rsp], rax

; 3609 :         if (_Old_size < _Mypair._Myval2._Myres) {

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00025	48 39 44 24 28	 cmp	 QWORD PTR _Old_size$[rsp], rax
  0002a	73 63		 jae	 SHORT $LN2@push_back

; 3610 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0002c	48 8b 44 24 28	 mov	 rax, QWORD PTR _Old_size$[rsp]
  00031	48 ff c0	 inc	 rax
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00039	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3611 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0004a	48 89 44 24 30	 mov	 QWORD PTR _Ptr$3[rsp], rax

; 3612 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR _Old_size$[rsp]
  00054	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr$3[rsp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Ch$[rsp]
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3613 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0006c	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ptr$3[rsp]
  00076	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  0007b	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00080	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3614 :             return;

  0008d	eb 2c		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 3615 :         }
; 3616 : 
; 3617 :         _Reallocate_grow_by(

  0008f	48 8d 44 24 21	 lea	 rax, QWORD PTR $T2[rsp]
  00094	48 8b f8	 mov	 rdi, rax
  00097	33 c0		 xor	 eax, eax
  00099	b9 01 00 00 00	 mov	 ecx, 1
  0009e	f3 aa		 rep stosb
  000a0	44 0f b6 4c 24
	58		 movzx	 r9d, BYTE PTR _Ch$[rsp]
  000a6	44 0f b6 44 24
	21		 movzx	 r8d, BYTE PTR $T2[rsp]
  000ac	ba 01 00 00 00	 mov	 edx, 1
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000b6	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN1@push_back:

; 3618 :             1,
; 3619 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3620 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3621 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 3622 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3623 :             },
; 3624 :             _Ch);
; 3625 :     }

  000bb	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 3586 :     _NODISCARD reference operator[](const size_type _Off) noexcept /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3587 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3588 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3589 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3590 :         return _Mypair._Myval2._Myptr()[_Off];

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001b	48 03 44 24 38	 add	 rax, QWORD PTR _Off$[rsp]

; 3591 :     }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv89 = 32
tv87 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT

; 3493 :     _NODISCARD iterator end() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3494 :         return iterator(

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0001b	48 89 44 24 20	 mov	 QWORD PTR tv89[rsp], rax
  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ; std::_Refancy<char *,0>
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0003e	48 89 44 24 28	 mov	 QWORD PTR tv87[rsp], rax
  00043	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv89[rsp]
  00048	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv87[rsp]
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00052	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 3495 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3496 :             _STD addressof(_Mypair._Myval2));
; 3497 :     }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv85 = 32
tv83 = 40
this$ = 64
__$ReturnUdt$ = 72
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT

; 3485 :     _NODISCARD iterator begin() noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3486 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0001b	48 89 44 24 20	 mov	 QWORD PTR tv85[rsp], rax
  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ; std::_Refancy<char *,0>
  00035	48 89 44 24 28	 mov	 QWORD PTR tv83[rsp], rax
  0003a	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv85[rsp]
  0003f	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv83[rsp]
  00044	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00049	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 3487 :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Off$ = 32
tv64 = 40
tv82 = 48
$T1 = 56
this$ = 80
__$ReturnUdt$ = 88
_Where$ = 96
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 3227 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3228 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3229 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3230 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3231 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());

  00013	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Where$[rsp]
  00018	e8 00 00 00 00	 call	 ??$_Unfancy@$$CBD@std@@YAPEBDPEBD@Z ; std::_Unfancy<char const >
  0001d	48 89 44 24 28	 mov	 QWORD PTR tv64[rsp], rax
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0002c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv64[rsp]
  00031	48 2b c8	 sub	 rcx, rax
  00034	48 8b c1	 mov	 rax, rcx
  00037	48 89 44 24 20	 mov	 QWORD PTR _Off$[rsp], rax

; 3232 :         erase(_Off, 1);

  0003c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00042	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Off$[rsp]
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 3233 :         return begin() + static_cast<difference_type>(_Off);

  00051	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T1[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0005b	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00060	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  00065	4c 8b 44 24 20	 mov	 r8, QWORD PTR _Off$[rsp]
  0006a	48 8b 54 24 58	 mov	 rdx, QWORD PTR __$ReturnUdt$[rsp]
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv82[rsp]
  00074	e8 00 00 00 00	 call	 ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator+
  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 3234 :     }

  0007e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00082	c3		 ret	 0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
_TEXT	SEGMENT
_New_size$ = 32
_Erase_at$ = 40
tv69 = 48
tv77 = 56
_My_ptr$ = 64
_Old_size$ = 72
this$ = 96
_Off$ = 104
_Count$ = 112
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 3215 :     basic_string& erase(const size_type _Off, size_type _Count) { // erase elements [_Off, _Off + _Count)

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3216 :         _Mypair._Myval2._Check_offset(_Off);

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR tv69[rsp], rax
  0001d	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Off$[rsp]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv69[rsp]
  00027	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 3217 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);

  0002c	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 89 44 24 38	 mov	 QWORD PTR tv77[rsp], rax
  00036	4c 8b 44 24 70	 mov	 r8, QWORD PTR _Count$[rsp]
  0003b	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Off$[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv77[rsp]
  00045	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
  0004a	48 89 44 24 70	 mov	 QWORD PTR _Count$[rsp], rax

; 3218 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0004f	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00054	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00058	48 89 44 24 48	 mov	 QWORD PTR _Old_size$[rsp], rax

; 3219 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();

  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00062	48 8b c8	 mov	 rcx, rax
  00065	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0006a	48 89 44 24 40	 mov	 QWORD PTR _My_ptr$[rsp], rax

; 3220 :         _Elem* const _Erase_at    = _My_ptr + _Off;

  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR _Off$[rsp]
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _My_ptr$[rsp]
  00079	48 03 c8	 add	 rcx, rax
  0007c	48 8b c1	 mov	 rax, rcx
  0007f	48 89 44 24 28	 mov	 QWORD PTR _Erase_at$[rsp], rax

; 3221 :         const size_type _New_size = _Old_size - _Count;

  00084	48 8b 44 24 70	 mov	 rax, QWORD PTR _Count$[rsp]
  00089	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  0008e	48 2b c8	 sub	 rcx, rax
  00091	48 8b c1	 mov	 rax, rcx
  00094	48 89 44 24 20	 mov	 QWORD PTR _New_size$[rsp], rax

; 3222 :         _Mypair._Myval2._Mysize   = _New_size;

  00099	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0009e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _New_size$[rsp]
  000a3	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3223 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000a7	48 8b 44 24 68	 mov	 rax, QWORD PTR _Off$[rsp]
  000ac	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _New_size$[rsp]
  000b1	48 2b c8	 sub	 rcx, rax
  000b4	48 8b c1	 mov	 rax, rcx
  000b7	48 ff c0	 inc	 rax
  000ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _Count$[rsp]
  000bf	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Erase_at$[rsp]
  000c4	48 03 d1	 add	 rdx, rcx
  000c7	48 8b ca	 mov	 rcx, rdx
  000ca	4c 8b c0	 mov	 r8, rax
  000cd	48 8b d1	 mov	 rdx, rcx
  000d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Erase_at$[rsp]
  000d5	e8 00 00 00 00	 call	 ?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::move

; 3224 :         return *this;

  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]

; 3225 :     }

  000df	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e3	c3		 ret	 0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Off$ = 72
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 3209 :     basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3210 :         _Mypair._Myval2._Check_offset(_Off);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR tv69[rsp], rax
  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Off$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv69[rsp]
  00022	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 3211 :         _Eos(_Off);

  00027	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Off$[rsp]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00031	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 3212 :         return *this;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]

; 3213 :     }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2983 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00013	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??$_Convert_size@_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64>
  00020	4c 8b c0	 mov	 r8, rax
  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2985 :     }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Old_ptr$3 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2964 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2965 :         // assign [_Ptr, _Ptr + _Count)
; 2966 :         if (_Count <= _Mypair._Myval2._Myres) {

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00019	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001d	48 39 44 24 50	 cmp	 QWORD PTR _Count$[rsp], rax
  00022	77 5d		 ja	 SHORT $LN2@assign

; 2967 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00031	48 89 44 24 28	 mov	 QWORD PTR _Old_ptr$3[rsp], rax

; 2968 :             _Mypair._Myval2._Mysize = _Count;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Count$[rsp]
  00040	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2969 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  00044	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Count$[rsp]
  00049	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Old_ptr$3[rsp]
  00053	e8 00 00 00 00	 call	 ?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::move

; 2970 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00058	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count$[rsp]
  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Old_ptr$3[rsp]
  00067	48 03 c8	 add	 rcx, rax
  0006a	48 8b c1	 mov	 rax, rcx
  0006d	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2971 :             return *this;

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007f	eb 2b		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 2972 :         }
; 2973 : 
; 2974 :         return _Reallocate_for(

  00081	48 8d 44 24 21	 lea	 rax, QWORD PTR $T2[rsp]
  00086	48 8b f8	 mov	 rdi, rax
  00089	33 c0		 xor	 eax, eax
  0008b	b9 01 00 00 00	 mov	 ecx, 1
  00090	f3 aa		 rep stosb
  00092	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Ptr$[rsp]
  00097	44 0f b6 44 24
	21		 movzx	 r8d, BYTE PTR $T2[rsp]
  0009d	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Count$[rsp]
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000a7	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
$LN1@assign:

; 2975 :             _Count,
; 2976 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2977 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2979 :             },
; 2980 :             _Ptr);
; 2981 :     }

  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
_TEXT	SEGMENT
tv69 = 32
tv77 = 40
this$ = 64
_Right$ = 72
_Roff$ = 80
_Count$ = 88
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2942 :     basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2943 :         // assign _Right [_Roff, _Roff + _Count)
; 2944 :         _Right._Mypair._Myval2._Check_offset(_Roff);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR _Right$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR tv69[rsp], rax
  00022	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Roff$[rsp]
  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv69[rsp]
  0002c	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 2945 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR _Right$[rsp]
  00036	48 89 44 24 28	 mov	 QWORD PTR tv77[rsp], rax
  0003b	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Count$[rsp]
  00040	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Roff$[rsp]
  00045	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv77[rsp]
  0004a	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
  0004f	48 89 44 24 58	 mov	 QWORD PTR _Count$[rsp], rax

; 2946 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00054	48 8b 44 24 48	 mov	 rax, QWORD PTR _Right$[rsp]
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00061	48 03 44 24 50	 add	 rax, QWORD PTR _Roff$[rsp]
  00066	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Count$[rsp]
  0006b	48 8b d0	 mov	 rdx, rax
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00073	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2947 :     }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2879 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2880 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00013	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??$_Convert_size@_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64>
  00020	4c 8b c0	 mov	 r8, rax
  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2881 :     }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Ptr$ = 104
_Count$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2857 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2858 :         // append [_Ptr, _Ptr + _Count)
; 2859 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00014	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00019	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001d	48 89 44 24 38	 mov	 QWORD PTR _Old_size$[rsp], rax

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  0002c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00030	48 2b c1	 sub	 rax, rcx
  00033	48 39 44 24 70	 cmp	 QWORD PTR _Count$[rsp], rax
  00038	0f 87 81 00 00
	00		 ja	 $LN2@append

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0003e	48 8b 44 24 70	 mov	 rax, QWORD PTR _Count$[rsp]
  00043	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  00048	48 03 c8	 add	 rcx, rax
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00053	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2862 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00057	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00064	48 89 44 24 40	 mov	 QWORD PTR _Old_ptr$3[rsp], rax

; 2863 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00069	48 8b 44 24 38	 mov	 rax, QWORD PTR _Old_size$[rsp]
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Old_ptr$3[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	4c 8b 44 24 70	 mov	 r8, QWORD PTR _Count$[rsp]
  0007e	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 ?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::move

; 2864 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0008b	c6 44 24 30 00	 mov	 BYTE PTR $T1[rsp], 0
  00090	48 8b 44 24 70	 mov	 rax, QWORD PTR _Count$[rsp]
  00095	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  0009a	48 03 c8	 add	 rcx, rax
  0009d	48 8b c1	 mov	 rax, rcx
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Old_ptr$3[rsp]
  000a5	48 03 c8	 add	 rcx, rax
  000a8	48 8b c1	 mov	 rax, rcx
  000ab	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2865 :             return *this;

  000b8	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000bd	eb 35		 jmp	 SHORT $LN1@append
$LN2@append:

; 2866 :         }
; 2867 : 
; 2868 :         return _Reallocate_grow_by(

  000bf	48 8d 44 24 31	 lea	 rax, QWORD PTR $T2[rsp]
  000c4	48 8b f8	 mov	 rdi, rax
  000c7	33 c0		 xor	 eax, eax
  000c9	b9 01 00 00 00	 mov	 ecx, 1
  000ce	f3 aa		 rep stosb
  000d0	48 8b 44 24 70	 mov	 rax, QWORD PTR _Count$[rsp]
  000d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000da	4c 8b 4c 24 68	 mov	 r9, QWORD PTR _Ptr$[rsp]
  000df	44 0f b6 44 24
	31		 movzx	 r8d, BYTE PTR $T2[rsp]
  000e5	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Count$[rsp]
  000ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000ef	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
$LN1@append:

; 2869 :             _Count,
; 2870 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2871 :                 const size_type _Count) {
; 2872 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2873 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2875 :             },
; 2876 :             _Ptr, _Count);
; 2877 :     }

  000f4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
_Right$ = 72
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2831 :     basic_string& append(const basic_string& _Right) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2832 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR _Right$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR _Right$[rsp]
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00029	48 89 44 24 28	 mov	 QWORD PTR tv76[rsp], rax
  0002e	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv78[rsp]
  00033	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv76[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2833 :     }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 2826 :     basic_string& operator+=(_Elem _Ch) {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2827 :         push_back(_Ch);

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR _Ch$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00017	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 2828 :         return *this;

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]

; 2829 :     }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 2822 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2823 :         return append(_Ptr);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2824 :     }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 2811 :     basic_string& operator+=(const basic_string& _Right) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2812 :         return append(_Right);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2813 :     }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2722 :     ~basic_string() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2723 :         _Tidy_deallocate();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2724 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2725 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2726 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2727 :         _Mypair._Myval2._Myproxy = nullptr;
; 2728 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2729 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2730 :     }

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Right_size$ = 40
_Right_data$ = 48
_Right_ptr$ = 56
_New_capacity$ = 64
$T1 = 72
$T2 = 80
_Al$ = 88
tv131 = 96
_New_array$ = 104
__$ArrayPad$ = 112
this$ = 144
_Right$ = 152
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT

; 2650 :     void _Construct_lv_contents(const basic_string& _Right) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2651 :         // assign by copying data stored in _Right
; 2652 :         // pre: this != &_Right
; 2653 :         // pre: *this owns no memory, iterators orphaned (note:
; 2654 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2655 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00020	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR _Right$[rsp]
  00028	48 89 44 24 30	 mov	 QWORD PTR _Right_data$[rsp], rax

; 2656 :         const size_type _Right_size   = _Right_data._Mysize;

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR _Right_data$[rsp]
  00032	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00036	48 89 44 24 28	 mov	 QWORD PTR _Right_size$[rsp], rax

; 2657 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Right_data$[rsp]
  00040	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00045	48 89 44 24 38	 mov	 QWORD PTR _Right_ptr$[rsp], rax

; 2658 :         auto& _My_data                = _Mypair._Myval2;

  0004a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00052	48 89 44 24 20	 mov	 QWORD PTR _My_data$[rsp], rax

; 2659 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00057	48 83 7c 24 28
	10		 cmp	 QWORD PTR _Right_size$[rsp], 16
  0005d	73 38		 jae	 SHORT $LN2@Construct_

; 2660 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  00064	41 b8 10 00 00
	00		 mov	 r8d, 16
  0006a	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right_ptr$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 2661 :             _My_data._Mysize = _Right_size;

  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right_size$[rsp]
  00081	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2662 :             _My_data._Myres  = _BUF_SIZE - 1;

  00085	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  0008a	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 2663 :             return;

  00092	e9 bd 00 00 00	 jmp	 $LN1@Construct_
$LN2@Construct_:

; 2664 :         }
; 2665 : 
; 2666 :         auto& _Al                     = _Getal();

  00097	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0009f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000a4	48 89 44 24 58	 mov	 QWORD PTR _Al$[rsp], rax

; 2667 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  000a9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000b1	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000b6	48 89 44 24 48	 mov	 QWORD PTR $T1[rsp], rax
  000bb	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right_size$[rsp]
  000c0	48 83 c8 0f	 or	 rax, 15
  000c4	48 89 44 24 50	 mov	 QWORD PTR $T2[rsp], rax
  000c9	48 8d 54 24 48	 lea	 rdx, QWORD PTR $T1[rsp]
  000ce	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T2[rsp]
  000d3	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  000d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000db	48 89 44 24 40	 mov	 QWORD PTR _New_capacity$[rsp], rax

; 2668 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  000e5	48 ff c0	 inc	 rax
  000e8	48 8b d0	 mov	 rdx, rax
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Al$[rsp]
  000f0	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  000f5	48 89 44 24 68	 mov	 QWORD PTR _New_array$[rsp], rax

; 2669 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  000ff	48 8d 54 24 68	 lea	 rdx, QWORD PTR _New_array$[rsp]
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2670 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  0010c	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right_size$[rsp]
  00111	48 ff c0	 inc	 rax
  00114	48 89 44 24 60	 mov	 QWORD PTR tv131[rsp], rax
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _New_array$[rsp]
  0011e	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00123	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv131[rsp]
  00128	4c 8b c1	 mov	 r8, rcx
  0012b	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right_ptr$[rsp]
  00130	48 8b c8	 mov	 rcx, rax
  00133	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy

; 2671 :         _My_data._Mysize = _Right_size;

  00138	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  0013d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right_size$[rsp]
  00142	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2672 :         _My_data._Myres  = _New_capacity;

  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR _My_data$[rsp]
  0014b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _New_capacity$[rsp]
  00150	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
$LN1@Construct_:

; 2673 :     }

  00154	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00159	48 33 cc	 xor	 rcx, rsp
  0015c	e8 00 00 00 00	 call	 __security_check_cookie
  00161	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00168	c3		 ret	 0
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
__formal$ = 64
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 2609 :     void _Take_contents(basic_string& _Right, true_type) noexcept {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2610 :         // assign by stealing _Right's buffer, memcpy optimization
; 2611 :         // pre: this != &_Right
; 2612 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2613 :         // pre: *this owns no memory, iterators orphaned (note:
; 2614 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2615 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2616 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2617 :             // take ownership of _Right's iterators along with its buffer
; 2618 :             _Swap_proxy_and_iterators(_Right);
; 2619 :         } else {
; 2620 :             _Right._Mypair._Myval2._Orphan_all();
; 2621 :         }
; 2622 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2623 : 
; 2624 :         _Memcpy_val_from(_Right);

  00013	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right$[rsp]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 2625 :         _Right._Tidy_init();

  00022	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Right$[rsp]
  00027	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2626 :     }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
_My_data_mem$ = 32
_Right_data_mem$ = 40
this$ = 80
_Right$ = 88
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT

; 2600 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2601 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2602 :         const auto _My_data_mem =

  00010	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00015	48 8b c8	 mov	 rcx, rax
  00018	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0001d	48 89 44 24 20	 mov	 QWORD PTR _My_data_mem$[rsp], rax

; 2603 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2604 :         const auto _Right_data_mem =

  00022	48 8b 44 24 58	 mov	 rax, QWORD PTR _Right$[rsp]
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
  0002f	48 89 44 24 28	 mov	 QWORD PTR _Right_data_mem$[rsp], rax

; 2605 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00034	48 8b 7c 24 20	 mov	 rdi, QWORD PTR _My_data_mem$[rsp]
  00039	48 8b 74 24 28	 mov	 rsi, QWORD PTR _Right_data_mem$[rsp]
  0003e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00043	f3 a4		 rep movsb

; 2607 :     }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	5f		 pop	 rdi
  0004a	5e		 pop	 rsi
  0004b	c3		 ret	 0
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2418 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 89 44 24 30	 mov	 QWORD PTR tv77[rsp], rax
  00019	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Right$[rsp]
  0001e	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
  0002b	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  00030	0f b6 44 24 22	 movzx	 eax, BYTE PTR $T3[rsp]
  00035	88 44 24 20	 mov	 BYTE PTR $T1[rsp], al
  00039	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv75[rsp]
  0003e	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv77[rsp]
  00048	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2419 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00052	48 89 44 24 38	 mov	 QWORD PTR tv89[rsp], rax
  00057	48 8d 54 24 23	 lea	 rdx, QWORD PTR $T4[rsp]
  0005c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv89[rsp]
  00061	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2420 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00066	48 8d 44 24 21	 lea	 rax, QWORD PTR $T2[rsp]
  0006b	48 8b f8	 mov	 rdi, rax
  0006e	33 c0		 xor	 eax, eax
  00070	b9 01 00 00 00	 mov	 ecx, 1
  00075	f3 aa		 rep stosb
  00077	44 0f b6 44 24
	21		 movzx	 r8d, BYTE PTR $T2[rsp]
  0007d	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Right$[rsp]
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00087	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2421 :     }

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00091	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
__formal$ = 72
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct, COMDAT

; 2404 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {

$LN4:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2405 :         // initialize from [_First, _Last), pointers
; 2406 :         if (_First != _Last) {

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR _Last$[rsp]
  0001d	48 39 44 24 38	 cmp	 QWORD PTR _First$[rsp], rax
  00022	74 2a		 je	 SHORT $LN2@Construct

; 2407 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

  00024	48 8b 44 24 38	 mov	 rax, QWORD PTR _First$[rsp]
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Last$[rsp]
  0002e	48 2b c8	 sub	 rcx, rax
  00031	48 8b c1	 mov	 rax, rcx
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 ??$_Convert_size@_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64>
  0003c	4c 8b c0	 mov	 r8, rax
  0003f	48 8b 54 24 38	 mov	 rdx, QWORD PTR _First$[rsp]
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00049	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Construct:

; 2408 :         }
; 2409 :     }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv69 = 40
_Alproxy$ = 48
_Proxy$ = 56
__$ArrayPad$ = 64
this$ = 96
_Ptr$ = 104
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2335 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00027	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  0002c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  00031	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00036	90		 npad	 1

; 2336 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00037	48 8d 44 24 21	 lea	 rax, QWORD PTR $T2[rsp]
  0003c	48 89 44 24 30	 mov	 QWORD PTR _Alproxy$[rsp], rax

; 2337 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00046	4c 8b c0	 mov	 r8, rax
  00049	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Alproxy$[rsp]
  0004e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00053	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2338 :         _Tidy_init();

  00058	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0005d	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2339 :         assign(_Ptr);

  00062	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00067	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0006c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2340 :         _Proxy._Release();

  00071	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00076	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
  0007b	90		 npad	 1

; 2341 :     }

  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00086	48 33 cc	 xor	 rcx, rsp
  00089	e8 00 00 00 00	 call	 __security_check_cookie
  0008e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00092	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv69 = 40
_Alproxy$ = 48
_Proxy$ = 56
__$ArrayPad$ = 64
this$ = 96
_Ptr$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv69 = 40
_Alproxy$ = 48
_Proxy$ = 56
__$ArrayPad$ = 64
this$ = 96
_Ptr$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv70 = 40
_Alproxy$ = 48
_Proxy$ = 56
__$ArrayPad$ = 64
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2308 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0002c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00031	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR _Al$[rsp]
  00039	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  0003e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv70[rsp]
  00043	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
  00048	90		 npad	 1

; 2309 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00049	48 8d 44 24 21	 lea	 rax, QWORD PTR $T2[rsp]
  0004e	48 89 44 24 30	 mov	 QWORD PTR _Alproxy$[rsp], rax

; 2310 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00053	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00058	4c 8b c0	 mov	 r8, rax
  0005b	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Alproxy$[rsp]
  00060	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00065	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2311 :         _Tidy_init();

  0006a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0006f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2312 :         assign(_Right, _Roff, _Count);

  00074	4c 8b 4c 24 78	 mov	 r9, QWORD PTR _Count$[rsp]
  00079	4c 8b 44 24 70	 mov	 r8, QWORD PTR _Roff$[rsp]
  0007e	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Right$[rsp]
  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00088	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2313 :         _Proxy._Release();

  0008d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00092	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
  00097	90		 npad	 1

; 2314 :     }

  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0009d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a2	48 33 cc	 xor	 rcx, rsp
  000a5	e8 00 00 00 00	 call	 __security_check_cookie
  000aa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ae	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv70 = 40
_Alproxy$ = 48
_Proxy$ = 56
__$ArrayPad$ = 64
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv70 = 40
_Alproxy$ = 48
_Proxy$ = 56
__$ArrayPad$ = 64
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv70 = 40
tv82 = 48
this$ = 80
_Al$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2292 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00018	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Al$[rsp]
  0001d	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00022	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv70[rsp]
  00027	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>

; 2293 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  00036	48 8d 54 24 21	 lea	 rdx, QWORD PTR $T2[rsp]
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv82[rsp]
  00040	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2294 :         _Tidy_init();

  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004a	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2295 :     }

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00054	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00058	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv69 = 40
tv81 = 48
this$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2287 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00013	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  0001d	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2288 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0002c	48 8d 54 24 21	 lea	 rdx, QWORD PTR $T2[rsp]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00036	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2289 :         _Tidy_init();

  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00040	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2290 :     }

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004e	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
tv76 = 40
tv78 = 48
_Alproxy$ = 56
_Proxy$ = 64
__$ArrayPad$ = 72
this$ = 96
_Right$ = 104
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2273 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  00027	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Right$[rsp]
  0002c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00031	48 8b d0	 mov	 rdx, rax
  00034	48 8d 4c 24 21	 lea	 rcx, QWORD PTR $T2[rsp]
  00039	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
  0003e	48 89 44 24 28	 mov	 QWORD PTR tv76[rsp], rax
  00043	0f b6 44 24 22	 movzx	 eax, BYTE PTR $T3[rsp]
  00048	88 44 24 20	 mov	 BYTE PTR $T1[rsp], al
  0004c	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv76[rsp]
  00051	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv78[rsp]
  0005b	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
  00060	90		 npad	 1

; 2274 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00061	48 8d 44 24 23	 lea	 rax, QWORD PTR $T4[rsp]
  00066	48 89 44 24 38	 mov	 QWORD PTR _Alproxy$[rsp], rax

; 2275 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  0006b	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00070	4c 8b c0	 mov	 r8, rax
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Alproxy$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  0007d	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2276 :         _Construct_lv_contents(_Right);

  00082	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Right$[rsp]
  00087	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0008c	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2277 :         _Proxy._Release();

  00091	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00096	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
  0009b	90		 npad	 1

; 2278 :     }

  0009c	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a6	48 33 cc	 xor	 rcx, rsp
  000a9	e8 00 00 00 00	 call	 __security_check_cookie
  000ae	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000b2	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
tv76 = 40
tv78 = 48
_Alproxy$ = 56
_Proxy$ = 64
__$ArrayPad$ = 72
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
tv76 = 40
tv78 = 48
_Alproxy$ = 56
_Proxy$ = 64
__$ArrayPad$ = 72
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2180 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2178 :         _Bxty() {} // user-provided, for fancy pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Off$ = 72
_Size$ = 80
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 2172 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2173 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2174 :         return (_STD min)(_Size, _Mysize - _Off);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Off$[rsp]
  0001d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00021	48 2b c1	 sub	 rax, rcx
  00024	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00029	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0002e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Size$[rsp]
  00033	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00038	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 2175 :     }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2168 :     [[noreturn]] static void _Xran() {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2169 :         _Xout_of_range("invalid string position");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  0000b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2170 :     }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 2156 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2157 :         if (_Mysize < _Off) {

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Off$[rsp]
  00018	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  0001c	73 05		 jae	 SHORT $LN2@Check_offs

; 2158 :             _Xran();

  0001e	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN2@Check_offs:
$LN3@Check_offs:

; 2159 :         }
; 2160 :     }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT

; 2152 :     bool _Large_string_engaged() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 2153 :         return _BUF_SIZE <= _Myres;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 18 10	 cmp	 QWORD PTR [rax+24], 16
  00013	72 09		 jb	 SHORT $LN3@Large_stri
  00015	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@Large_stri
$LN3@Large_stri:
  0001e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@Large_stri:
  00025	0f b6 04 24	 movzx	 eax, BYTE PTR tv66[rsp]

; 2154 :     }

  00029	48 83 c4 18	 add	 rsp, 24
  0002d	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2143 :     const value_type* _Myptr() const noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2144 :         const value_type* _Result = _Bx._Buf;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR _Result$[rsp], rax

; 2145 :         if (_Large_string_engaged()) {

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN2@Myptr

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002c	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00031	48 89 44 24 20	 mov	 QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 2147 :         }
; 2148 : 
; 2149 :         return _Result;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR _Result$[rsp]

; 2150 :     }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2134 :     value_type* _Myptr() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2135 :         value_type* _Result = _Bx._Buf;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR _Result$[rsp], rax

; 2136 :         if (_Large_string_engaged()) {

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN2@Myptr

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002c	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00031	48 89 44 24 20	 mov	 QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 2138 :         }
; 2139 : 
; 2140 :         return _Result;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR _Result$[rsp]

; 2141 :     }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 706  :     _NODISCARD static _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 707  :         return _Al;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 708  :     }

  0000f	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00005	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1

; 704  :     }

  0000c	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2200 : [[noreturn]] inline void _Xlen_string() {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2201 :     _Xlength_error("string too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2202 : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 401  :         return static_cast<int_type>(EOF);

  00000	b8 ff ff ff ff	 mov	 eax, -1

; 402  :     }

  00005	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z
_TEXT	SEGMENT
tv68 = 32
tv69 = 36
_Meta$ = 64
?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z PROC	; std::_Narrow_char_traits<char,int>::not_eof, COMDAT

; 396  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 397  :         return _Meta != eof() ? _Meta : !eof();

  00009	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Meta$[rsp]
  00013	39 01		 cmp	 DWORD PTR [rcx], eax
  00015	74 0d		 je	 SHORT $LN5@not_eof
  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR _Meta$[rsp]
  0001c	8b 00		 mov	 eax, DWORD PTR [rax]
  0001e	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
  00022	eb 23		 jmp	 SHORT $LN6@not_eof
$LN5@not_eof:
  00024	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00029	85 c0		 test	 eax, eax
  0002b	75 0a		 jne	 SHORT $LN3@not_eof
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00035	eb 08		 jmp	 SHORT $LN4@not_eof
$LN3@not_eof:
  00037	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN4@not_eof:
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]
  00043	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
$LN6@not_eof:
  00047	8b 44 24 24	 mov	 eax, DWORD PTR tv69[rsp]

; 398  :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ENDP	; std::_Narrow_char_traits<char,int>::not_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
tv65 = 0
_Left$ = 32
_Right$ = 40
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 392  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 393  :         return _Left == _Right;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  00018	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0001a	39 08		 cmp	 DWORD PTR [rax], ecx
  0001c	75 09		 jne	 SHORT $LN3@eq_int_typ
  0001e	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv65[rsp], 1
  00025	eb 07		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv65[rsp], 0
$LN4@eq_int_typ:
  0002e	0f b6 04 24	 movzx	 eax, BYTE PTR tv65[rsp]

; 394  :     }

  00032	48 83 c4 18	 add	 rsp, 24
  00036	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 388  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 389  :         return static_cast<unsigned char>(_Ch);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ch$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 390  :     }

  0000d	c3		 ret	 0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z PROC ; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 384  :     _NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 385  :         return static_cast<_Elem>(_Meta);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Meta$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 386  :     }

  0000d	c3		 ret	 0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ENDP ; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z
_TEXT	SEGMENT
tv67 = 0
_Left$ = 32
_Right$ = 40
?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z PROC	; std::_Narrow_char_traits<char,int>::eq, COMDAT

; 376  :     _NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 377  :         return _Left == _Right;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00016	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  0001b	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0001e	3b c1		 cmp	 eax, ecx
  00020	75 09		 jne	 SHORT $LN3@eq
  00022	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00029	eb 07		 jmp	 SHORT $LN4@eq
$LN3@eq:
  0002b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@eq:
  00032	0f b6 04 24	 movzx	 eax, BYTE PTR tv67[rsp]

; 378  :     }

  00036	48 83 c4 18	 add	 rsp, 24
  0003a	c3		 ret	 0
?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z ENDP	; std::_Narrow_char_traits<char,int>::eq
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 372  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 373  :         _Left = _Right;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR _Left$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _Right$[rsp]
  00014	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00017	88 08		 mov	 BYTE PTR [rax], cl

; 374  :     }

  00019	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC ; std::_Narrow_char_traits<char,int>::move, COMDAT

; 361  :         const size_t _Count) noexcept /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 362  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00013	4c 8b 44 24 40	 mov	 r8, QWORD PTR _Count$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR _First2$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _First1$[rsp]
  00022	e8 00 00 00 00	 call	 memmove

; 364  :     }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP ; std::_Narrow_char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::find, COMDAT

; 340  :         const _Elem& _Ch) noexcept /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 341  :         // look for _Ch in [_First, _First + _Count)
; 342  : #if _HAS_CXX17
; 343  : #ifdef __cpp_char8_t
; 344  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 345  : #if _HAS_U8_INTRINSICS
; 346  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 347  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 348  :             return _Char_traits<_Elem, _Int_type>::find(_First, _Count, _Ch);
; 349  : #endif // _HAS_U8_INTRINSICS
; 350  :         } else
; 351  : #endif // __cpp_char8_t
; 352  :         {
; 353  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR _Ch$[rsp]
  00018	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0001b	4c 8b 44 24 38	 mov	 r8, QWORD PTR _Count$[rsp]
  00020	8b d0		 mov	 edx, eax
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _First$[rsp]
  00027	e8 00 00 00 00	 call	 memchr

; 354  :         }
; 355  : #else // _HAS_CXX17
; 356  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 357  : #endif // _HAS_CXX17
; 358  :     }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 24
_First2$ = 32
_Count$ = 40
?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC ; std::_Narrow_char_traits<char,int>::copy, COMDAT

; 326  :         const size_t _Count) noexcept /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi

; 327  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00011	48 8b 7c 24 18	 mov	 rdi, QWORD PTR _First1$[rsp]
  00016	48 8b 74 24 20	 mov	 rsi, QWORD PTR _First2$[rsp]
  0001b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Count$[rsp]
  00020	f3 a4		 rep movsb
  00022	48 8b 44 24 18	 mov	 rax, QWORD PTR _First1$[rsp]

; 329  :     }

  00027	5f		 pop	 rdi
  00028	5e		 pop	 rsi
  00029	c3		 ret	 0
?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP ; std::_Narrow_char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 0
tv67 = 8
_First$ = 32
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 305  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 306  :         // find length of null-terminated string
; 307  : #if _HAS_CXX17
; 308  : #ifdef __cpp_char8_t
; 309  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 310  : #if _HAS_U8_INTRINSICS
; 311  :             return __builtin_u8strlen(_First);
; 312  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 313  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 314  : #endif // _HAS_U8_INTRINSICS
; 315  :         } else
; 316  : #endif // __cpp_char8_t
; 317  :         {
; 318  :             return __builtin_strlen(_First);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR _First$[rsp]
  0000e	48 89 44 24 08	 mov	 QWORD PTR tv67[rsp], rax
  00013	48 c7 04 24 ff
	ff ff ff	 mov	 QWORD PTR tv68[rsp], -1
$LL3@length:
  0001b	48 ff 04 24	 inc	 QWORD PTR tv68[rsp]
  0001f	48 8b 44 24 08	 mov	 rax, QWORD PTR tv67[rsp]
  00024	48 8b 0c 24	 mov	 rcx, QWORD PTR tv68[rsp]
  00028	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  0002c	75 ed		 jne	 SHORT $LL3@length
  0002e	48 8b 04 24	 mov	 rax, QWORD PTR tv68[rsp]

; 319  :         }
; 320  : #else // _HAS_CXX17
; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 322  : #endif // _HAS_CXX17
; 323  :     }

  00032	48 83 c4 18	 add	 rsp, 24
  00036	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z PROC ; std::_Narrow_char_traits<char,int>::compare, COMDAT

; 289  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 290  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 291  : #if _HAS_CXX17
; 292  : #if _HAS_U8_INTRINSICS
; 293  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 294  :             return __builtin_u8memcmp(_First1, _First2, _Count);
; 295  :         } else
; 296  : #endif // _HAS_U8_INTRINSICS
; 297  :         {
; 298  :             return __builtin_memcmp(_First1, _First2, _Count);

  00013	4c 8b 44 24 40	 mov	 r8, QWORD PTR _Count$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR _First2$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _First1$[rsp]
  00022	e8 00 00 00 00	 call	 memcmp

; 299  :         }
; 300  : #else // _HAS_CXX17
; 301  :         return _CSTD memcmp(_First1, _First2, _Count);
; 302  : #endif // _HAS_CXX17
; 303  :     }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ENDP ; std::_Narrow_char_traits<char,int>::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Count$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YA_K_K@Z ; std::_Get_size_of_n<1>
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 808  :     }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Count$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  0001d	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 804  :     }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 795  :     constexpr allocator() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1259 :     void _Release() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1256 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00014	c3		 ret	 0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1072 :     void _Adopt(const void*) noexcept {}

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	c3		 ret	 0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1067 :     void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	c3		 ret	 0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1066 :     void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	c3		 ret	 0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1065 :     void _Orphan_all() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Convert_size@_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K@std@@YA_K_K@Z PROC			; std::_Convert_size<unsigned __int64>, COMDAT

; 990  : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 991  :     // convert size_t to size_t, unchanged
; 992  :     return _Len;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Len$[rsp]

; 993  : }

  0000a	c3		 ret	 0
??$_Convert_size@_K@std@@YA_K_K@Z ENDP			; std::_Convert_size<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR _Bytes$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 83 c0 27	 add	 rax, 39			; 00000027H
  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Bytes$[rsp]
  0001f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 44 24 30	 mov	 QWORD PTR _Ptr_user$[rsp], rax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002f	b8 08 00 00 00	 mov	 eax, 8
  00034	48 6b c0 ff	 imul	 rax, rax, -1
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr_user$[rsp]
  0003d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00041	48 89 44 24 28	 mov	 QWORD PTR _Ptr_container$[rsp], rax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  00046	48 c7 44 24 38
	08 00 00 00	 mov	 QWORD PTR _Min_back_shift$[rsp], 8

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00054	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Ptr_container$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 2b c1	 sub	 rax, rcx
  0005f	48 89 44 24 20	 mov	 QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00064	48 83 7c 24 20
	08		 cmp	 QWORD PTR _Back_shift$[rsp], 8
  0006a	72 0a		 jb	 SHORT $LN8@Adjust_man
  0006c	48 83 7c 24 20
	27		 cmp	 QWORD PTR _Back_shift$[rsp], 39 ; 00000027H
  00072	77 02		 ja	 SHORT $LN8@Adjust_man
  00074	eb 0c		 jmp	 SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 f4		 jne	 SHORT $LN7@Adjust_man
$LN9@Adjust_man:
  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 dc		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00088	48 8b 44 24 50	 mov	 rax, QWORD PTR _Ptr$[rsp]
  0008d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Ptr_container$[rsp]
  00092	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 153  : }

  00095	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00099	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 76   :     __declspec(allocator) static void* _Allocate(const size_t _Bytes) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 77   :         return ::operator new(_Bytes);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Bytes$[rsp]
  0000e	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 78   :     }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 646  :         return LLONG_MAX;

  00000	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 647  :     }

  0000a	c3		 ret	 0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 321  :     _THROW(bad_array_new_length{});

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
$LN2@Throw_bad_:

; 322  : }

  0001f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00023	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UEAA@XZ
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 00 00 00	 mov	 edx, 24
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR __that$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QEAA@AEBV01@@Z
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00029	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 141  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 140  :         : bad_alloc("bad array new length")

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AEAA@QEBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00026	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  :     }

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 00 00 00	 mov	 edx, 24
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR __that$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@AEBV01@@Z ; std::exception::exception
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  00029	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 129  :         : exception(_Message, 1)

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Message$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001e	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@QEBDH@Z ; std::exception::exception

; 130  :     {

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0002f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 131  :     }

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 00 00 00	 mov	 edx, 24
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 94   :     {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00013	74 0f		 je	 SHORT $LN3@what
  00015	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001e	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
  00022	eb 0b		 jmp	 SHORT $LN4@what
$LN3@what:
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0002b	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
$LN4@what:
  0002f	48 8b 04 24	 mov	 rax, QWORD PTR tv69[rsp]

; 96   :     }

  00033	48 83 c4 18	 add	 rsp, 24
  00037	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx

; 90   :         __std_exception_destroy(&_Data);

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 __std_exception_destroy

; 91   :     }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  0001b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   :         : _Data()

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 c0 08	 add	 rax, 8
  00027	48 8b f8	 mov	 rdi, rax
  0002a	33 c0		 xor	 eax, eax
  0002c	b9 10 00 00 00	 mov	 ecx, 16
  00031	f3 aa		 rep stosb

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00038	48 83 c0 08	 add	 rax, 8
  0003c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Other$[rsp]
  00041	48 83 c1 08	 add	 rcx, 8
  00045	48 8b d0	 mov	 rdx, rax
  00048	e8 00 00 00 00	 call	 __std_exception_copy

; 74   :     }

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  0001c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 65   :         : _Data()

  0001f	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 8b f8	 mov	 rdi, rax
  0002b	33 c0		 xor	 eax, eax
  0002d	b9 10 00 00 00	 mov	 ecx, 16
  00032	f3 aa		 rep stosb

; 67   :         _Data._What = _Message;

  00034	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00039	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _Message$[rsp]
  0003e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 68   :     }

  00042	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\wchar.h
;	COMDAT wmemcpy
_TEXT	SEGMENT
_S1$ = 24
_S2$ = 32
_N$ = 40
wmemcpy	PROC						; COMDAT

; 234  :     {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00011	48 8b 44 24 28	 mov	 rax, QWORD PTR _N$[rsp]
  00016	48 d1 e0	 shl	 rax, 1
  00019	48 8b 7c 24 18	 mov	 rdi, QWORD PTR _S1$[rsp]
  0001e	48 8b 74 24 20	 mov	 rsi, QWORD PTR _S2$[rsp]
  00023	48 8b c8	 mov	 rcx, rax
  00026	f3 a4		 rep movsb
  00028	48 8b 44 24 18	 mov	 rax, QWORD PTR _S1$[rsp]

; 237  :     }

  0002d	5f		 pop	 rdi
  0002e	5e		 pop	 rsi
  0002f	c3		 ret	 0
wmemcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 168  :         (void)_Size;
; 169  :         return _Where;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR _Where$[rsp]

; 170  :     }

  0000f	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
tv77 = 40
tv75 = 48
_ArgList$ = 56
__$ArrayPad$ = 64
_Format$ = 96
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00027	48 8d 44 24 68	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0002c	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00031	48 8b 44 24 38	 mov	 rax, QWORD PTR _ArgList$[rsp]
  00036	48 89 44 24 28	 mov	 QWORD PTR tv77[rsp], rax
  0003b	b9 01 00 00 00	 mov	 ecx, 1
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00046	48 89 44 24 30	 mov	 QWORD PTR tv75[rsp], rax
  0004b	4c 8b 4c 24 28	 mov	 r9, QWORD PTR tv77[rsp]
  00050	45 33 c0	 xor	 r8d, r8d
  00053	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Format$[rsp]
  00058	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv75[rsp]
  0005d	e8 00 00 00 00	 call	 _vfprintf_l
  00062	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00066	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0006f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00078	48 33 cc	 xor	 rcx, rsp
  0007b	e8 00 00 00 00	 call	 __security_check_cookie
  00080	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00084	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
